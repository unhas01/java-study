# 일반(Generic) 프로그래밍

제네릭 프로그래밍은 다양한 유형의 데이터에 작동하는 코드를 작성하는 것을 의미한다. 우리는 섹션 7.2.4에서 제네릭 프로그래밍에 대한 대안을 만났다. 여기서 우리는 정수의 동적 배열을 살펴보았다. 동적 정수 배열 작업을 위해 여기세 제시된 소스 코드는 int 유형의 데이터에만 자동한다. 그러나 double, String, Color 또는 기타 유형의 동적 배열에 대한 소스 코드는 본질적으로 동일한 코드를 반복해서 작성하는 것은 어리석은 것 같다. 이 문제에 대한 Java의 접근 방식은 매개변수화된 유형이다. 섹션 7.3에서 본 것처럼 매개변수화된 클래스는 ArrayList처럼 동적 배열을 구현한다. 매개변수화 되어 있기 때문에 String의 동적 배열을 나타내는 ArrayList<String>, 색상 유형 ArrayList<Color>, 더 일반적으로 모든 객체 유형 T를 나타내는 ArrayList<T>와 같은 유형이 있다. ArrayList는 하나의 클래스일 뿐이지만 소스 코드는 다양한 유형에서 작동한다. 이것은 제네릭 프로그래밍이다.

ArrayList 클래스는 Java의 제네릭 프로그래밍에 사용되는 많은 표준 클래스 중 하나이다. 다음 섹션에서 이러한 클래스 중 일부와 해당 클래스의 사용 방법을 살펴보고 일반 메서드와 일반 인터페이스도 있음을 살펴본다. 이 섹션에서 논의되는 클래스와 인터페이스는 `java.util` 패키지에 정의되어 있으며 이에 엑세스 하려면 프로그램 시작 부분에 import가 필요하다

섹션 10.5에서는 새로운 제네릭 클래그, 인터페이스 및 메서드를 정의하는 것이 가능하다는 것을 볼 것이다. 그때까지 우리는 Java의 사전 정의된 제네릭을 계속 사용할 것이다. 그리고 섹션 10.6에서는 제네릭을 광범위하게 사용하는 Java의 비교적 새로운 기능인 stream을 살펴 본다.

제네릭 프로그래밍을 위한 라이브러리를 설계하는 것은 쉬운 일이 아니다. Java의 솔루션에는 많은 멋진 기능이 있지만 확실히 이것이 유일한 접근 방식은 아니다. 최고는 거의 확실하지 않으며 제 생각에는 이상하다고 할 수 있는 몇 가지 기능이 있지만 Java의 전반적인 디자인 측면에서 최적에 가깝다. 제네릭 프로그래밍에 대한 관점을 얻으려면 제네릭 프로그래밍에 대한 다른 접근 방식을 간략하게 살펴보는 것이 유용하다.

## 1. 제네릭 프로그래밍에 대한 Smalltalk

스몰토크는 최최의 객체 지향 프로그래밍 언어 중 하나였다. 비록 그 사용이 흔하지는 않지만 오늘날에도 여전히 사용되고 있다. Java나 C++ 만큼 인기를 얻은 적은 없지만 이러한 언어에서 사용되는 많은 아이디어의 원천이다. 스몰토크에서는 언어의 두 가지 기본 속성으로 인해 본질적으로 모든 프로그래밍이 제네릭이다. 

우선 스몰토크는 변수의 유형이 없다. 데이터 값에는 정수 또는 문자열과 같은 유형이 있지만 변수에는 유형이 없다. 모든 변수는 모든 유형의 데이터를 보유할 수 있다. 매개변수에는 유형도 없으므로 모든 유형의 매개변수 값에 서브 루틴을 적용할 수 있다. 마찬가지로 데이터 구조는 모든 유형의 데이터 값을 보유할 수 있다. 예를 들어 스몰토크에서 이진 트리 데이터 구조를 정의한 후에는 정수, 문자열, 날짜 또는 다른 유형의 데이터를 구성된 이진 트리에 사용할 수 있다. 각 데이터 유형에 대해 새로운 코드를 작성할 필요가 없다.

둘 째, 모든 데이터 값은 객체이며 객체에 대한 모든 작업은 클래스의 메서드에 의해 정의된다. 이는 정수와 같이 Java에서 "primitive"인 유형의 경우에도 마찬가지이다. "+" 연산자를 사용하여 두 개의 정수를 더하는 경우 정수 클래스의 메서드를 호출하여 연산이 수행된다. 새 클래스를 정의할 때 "+" 연산자를 정의할 수 있으며, 그런 다음 마치 숫자를 추가하는 것 처럼 "a + b"라고 말하여 해당 클래스에 속하는 객체를 추가할 수 있다. 이제 목록의 항목을 합산하기 위해 "+" 연산자를 사용하는 서브 루틴을 작성한다고 가정한다. 서브 루틴은 정수 목록에 적용될 수 있지만 자동으로 적용될 수 있다가 정의된다. 마찬가지로 목록을 정렬하기 위해 "<" 연산자를 사용하는 서브 루틴은 "<"가 정의된 모든 유형의 데이터를 포함하는 목록에 적용될 수 있다. 각 유형에 대해 다른 정렬 서브 루틴을 작성할 필요가 없다.

이 두가지 기능을 함께 사용하면 데이터 구주와 알고리즘이 의미가 있는 모든 유형의 데이터, 즉 적절한 작업이 정의된 데이터에 대해 작동하는 언어를 갖게 된다. 이것은 실제 제네릭 프로그래밍이다. 이것은 꽤 좋게 들릴 수도 있고 왜 모든 프로그래밍 언어가 이런 방식으로 작동하지 않는지 자문할 수도 있다. 이러한 유형의 자유는 프로그램 작성을 더 쉽게 만들어 주지만, 불행하게도 정학화고 견고한 프로그램 작성을 어렵게 만든다. 모든 유형의 데이터를 포함할 수 있는 데이터 구조가 있으면 보유하려는 데이터 유형만 보유하는지 확인하기가 어려워진다. 모든 유형의 데이터를 정렬할 수 있는 서브 루틴이 있는 경우 "<" 연산자가 정의되어 있다. 특히 컴파일러가 이러한 사항을 보장할 방법이 없다. 문제는 정의되지 않은 데이터 유형에 일부 작업을 적용하려고 시도할 때 런타임에만 나타내고 프로그램이 충돌할 것이다.

## 2. C++의 제네릭 프로그래밍

스몰토크와 달리 C++는 매우 강력한 유형의 언어이다. 모든 변수에는 유형이 있으며 해당 유형의 데이터 값만 보유할 수 있다. 이는 스몰토크에서 사용되는 일반 프로그래밍이 C++에서는 불가능하다는 것을 의미한다. 그럼에도 불구하고 C++에는 강력하고 유연한 일반 프로그래밍 시스템이 있다. 이는 템플릿(templates) 이라는 언어 기능을 통해 가능해졌다. C++에서는 각 데이터 유형에 대해 서로 다른 정렬 서브 루틴을 작성하는 대신 단일 서브 루틴 템플릿을 작성할 수 있다. 템플릿은 서브 루틴이 아니다. 서브 루틴을 만드는 공장에 가깝다. C++의 구문은 Java의 구문과 매우 유사하다.

```c++
template<class ItemType>
void sort( ItemType A[], int count ) {
      // 배열 A의 항목을 오름차순으로 정렬합니다.
      // 0, 1, 2, ..., (count-1) 위치의 항목이 정렬됩니다.
      // 여기서 사용되는 알고리즘은 선택 정렬입니다.
    for (int i = count-1; i > 0; i--) {
        int position_of_max = 0;
        for (int j = 1; j <= i ; j++)
            if ( A[j] > A[position_of_max] )
                position_of_max = j;
        ItemType temp = A[i];
        A[i] = A[position_of_max];
        A[position_of_max] = temp;
    }
}
```

이 코드 조각은 서브루틴 템플릿을 정의한다. 첫 번째 줄인 "template<class ItemType>"을 제거하고 나머지 템플릿에서 "ItemType"이라는 단어를 int라는 단어로 대체하면 int 배열을 정렬하기 위한 서브 루틴이 생성된다. ("class ItemType"이라고 되어 있지만 실제로 기본 유형을 포함하여 어떤 유형으로든 대체할 수 있다.) "ItemType"을 "String"으로 대체하면 문자열 배열을 정렬하기 위한 서브루틴이 생성된다. 이는 컴파일러가 템플릿을 사용하여 수행하는 작업과 거의 같다. 프로그램에 `"sort(list, 10)"`이라고 표시되면 컴파일러는 템플릿을 사용하여 int 배열을 정렬하기 위한 서브 루틴을 생성한다. `"sort(cards, 10)"`라고 말하면, cards가 Card 유형의 객체 배열인 경우 컴파일러는 Cards 배열 정렬을 위한 서브루틴을 생성합니다. 템플릿을 비교하기 위해 ">" 연산자를 사용한다. 이 연산자가 값에 대해 정의된 경우 Card 유형이면 컴파일러는 템플릿을 성공적으로 사용하여 카드 정렬을 위한 서브 루틴을 생성한다. ">"가 Cards에 대해 정의되지 않은 경우 컴파일러는 실패한다. 그러나 이는 스몰토크에서와 같이 컴파일 타임에 발생하지 않는다. 런타임에 프로그램이 충돌할 수 있다. (그런데 C++에서는 모든 유형에 대해 ">"와 같은 연산자 정의를 작성하는 것이 가능하다. Card 유형에 대해 작동할 수 있다.)

서브 루틴 템플릿 외에도 C++에는 클래스를 만들기 위한 템플릿도 있다. 이진 트리 클래스에 대한 템플릿을 작성하는 경우 이를 사용하여 int의 이진 트리, 문자열의 이진 트리, 날짜의 이진 트리 등에 대한 클래스를 모두 하나의 템플릿에서 생성할 수 있다. 최신 C++에는 표준 템플릿 라이브러리(STL)라고 하는 사전 작성된 템플릿이 많아 포함되어 있다. STL은 상당히 복잡하다. 많은 사람들은 그것이 너무 복ㄱ잡하다고 말할 것이다. 그러나 이는 C++의 가장 흥미로운 기능 중 하나이기도 하다.

## 3. 자바의 제네릭 프로그래밍

Java의 일반 프로그래밍 기능은 여러 개발 단계를 거쳤다. 초기 버전의 Java에는 매개변수화된 유형이 없었지만 공통 데이터 구조를 나타내는 클래스가 있다. 이러한 클래스는 Objects와 함께 작동하도록 설계되었다. 즉, 모든 유형의 객체를 보유할 수 있으며 주어진 데이터 구조에 저장될 수 있는 객체 유형을 제한할 수 있는 방법이 없다. 예를 들어 ArrayList는 원래 매개변수화된 유형이 아니므로 ArrayList는 모든 유형의 객체를 보유할 수 있다. 이는 `list`가 ArrayList인 경우 `list.get(i)`가 Object 유형의 값을 반환한다는 것을 의미한다. 프로그래머가 실제로 목록을 사용하여 저장했다면 Strings에서 `list.get(i)`에 의해 반환ㄴ된 값은 문자열로 처리되도록 유형 변환되어야 한다.

```java
String item = (String) list.get(i);
```

하나의 클래스가 모든 종류의 객체에 대해 작동할 수 있기 때문에 이는 여전히 일종의 제네릭 프로그래밍이지만, 컴파일 타임에 유형 검사를 수행할 방법이 없기 때문에 정신적으로는 C++보다 스몰토크에 더 가깝다. 불행하게도 스몰토크에서와 마찬가지로 그 결과는 컴파일 타임이 아닌 런타임에만 나타나는 오류 범주이다. 프로그래머가 데이터 구조의 모든 항목이 문자열이라고 가정하고 해당 항목을 문자열로 처리하려고 시도하는 경우 실수로 다른 유형의 데이터가 데이터 구조에 추가되면 런타임 오류가 발생한다. Java에서는 프로그램이 데이터 구조에서 Object를 검색하고 이를 String 유형으로 변환하도록 오류를 발생할 가능성이 없다. 객체가 실제로 String 유형이 아닌 경우, 잘못된 유형 캐스팅은 ClassCastException 유형의 오류를 발생시킨다.

Java 5.0에서는 매개 변수화된 유형을 도입하여 런타임이 아닌 컴파일 시간에 유형 검사가 가능한 일반 데이터 구조를 생성할 수 있게 되었다. 예를 들어 `list`가 ArrayList<String> 유형인 경우 컴파일러는 String 유형의 객체만 `list`에 추가하도록 허용한다. 또한 `list.get(i)`의 반환 유형은 String이다. 게다가 `list.get(i)`의 반환 유형은 String 타입이기에 캐스팅이 필요하지 않다. Java의 매개 변수화된 클래스는 C++ 템플릿 클래스와 유사하여 이러한 도입으로 인해 Java 프로그래밍 모델은 C++에 더 가깝고 스몰토크에서는 더 멀어졌다. 이번 장에서는 매개 변수화된 유형만을 사용할 것이지만, 반드시 사용해야 하는 것은 아니라는 점을 기억해야 한다. 일반 ArrayList와 같이 매개변수화된 클래스를 매개 변수화되지 않은 유형으로 사용하는 것은 여전히 적법하다. 이 경우 모든 유형의 객체를 데이터 구조에 저장할 수 있다.

Java의 매개 변수화된 클래스와 C++의 템플릿 클래스 간에는 상당한 차이가 있다. C++의 템플릿 클래스는 실제로 클래스가 아니다. 클래스를 생성하기 위한 일종의 팩토리이다. 템플릿이 새로운 유형과 함께 사용될 때마다 새로운 컴파일된 클래스가 생성된다. Java 매개 변수화된 클래스에는 컴파일된 클래스 파일이 하나만 있다. 예를 들어, 매개변수화된 클래스 ArrayList에 대해 컴파일된 클래스 파일 `ArrayList.class` 하나만 있다. 매개 변수화된 클래스 ArrayList<String>, ArrayList<Integer>는 모두 일반 ArrayList 유형과 마찬가지로 동일한 컴파일된 클래스 파일을 사용한다. 유형 매개 변수 문자열 또는 정수, 단지 데이터 구조에 저장할 수 있는 객체 유형을 제한하도록 컴파일러에 지시한다. 유형 매개 변수는 런타임에 영향을 미치지 않으며 런타임에도 알려지지 않는다. 유형 정보는 런타임 시 "삭제"된다고 한다. 이러한 유형의 삭제(type erasure)는 어느 정도 이상한 점을 야기한다. 예를 들어 `instanceof` 연산자는 런타임에 평가되고 런타임에는 일반 ArrayList만 존재하므로 `if (list instanceof ArrayList<String>)`을 테스트할 수 없다. 마찬가지로 ArrayList<String> 유형으로 유형 변환할 수 없다. 더 나쁜 것은 `new` 연산자를 사용하여 기본 유형 ArrayList<String>을 갖는 배열을 생성할 수 없다는 것이다. 이는 실행 시 새 연산자가 평가되며 실행 시 "ArrayList<String>"과 같은 것이 없기 때문이며, 실행 시에는 매개 변수가 없는 유형의 ArrayList만 존재하다. (단, ArrayList<String>의 배열을 가질 수는 없지만 ArrayList<ArrayList<String>의 유형을 ArrayList<String>로 표기하는 ArrayList<String>의 ArrayList를 사용할 수 있으며, 이는 양호하거나 양호하다.)

다행스럽게도 이러한 문제는 상당히 고급 프로그래밍에서만 발생하기 때문에 대부분의 프로그래머는 이러한 문제를 처리할 필요가 없다. 매개변수화된 유형을 사용하는 대부분의 사람들은 문제에 직면하지 않을 것이며, 유형이 안전한 제네릭 프로그래밍의 이점을 거의 어려움 없이 얻을 것이다.

매개변수화된 유형의 유형 매개 변수가 컴파일러에 의해 추론될 수 있는 경우 유형 매개변수의 이름을 생략할 수 있다는 점은 주목할 가치가 있다. 예를 들어, 생성된 ArrayList는 변수 유형과 일치하도록 ArrayList<String>이어야 하므로 다음 문의 생성자에서 "String"이라는 단어는 선택사항이다.

```java
ArrayList<String> words = new ArrayList<>();
```

## 4. 자바 컬렉션 프레임워크

앞서 말했듯이 Java에는 공통 데이터 구조를 구현하는 여러 매개변수화된 유형이 함께 제공된다. 이 데이터 구조 클래스 및 인터페이스 컬렉션을 Java 컬렉션 프레임워크 또는 JCF라고 한다. 우리는 다음 몇 섹션에서 JCF에 대해 배운다.

Java Collection Framework의 일반 데이터 구조는 컬렉션(collection)과 맵(Maps)이라는 두 가지 범주로 나눌 수 있다. 컬렉션은 말 그대로 객체 컬렉션이다. 사전이 정의를 단어와 연결하거나 전화번호부가 전화번호를 이름과 연결하는 것처럼 맵은 한 세트의 객체에 다른 세트의 객체와 연결한다. 맵은 섹션 7.5.2에서 "연관 목록"이라고 부르는 것과 유사하다. Java에서 컬렉션과 맵은 매개변수화된 인터페이스 `Collection<T>` 및 `Map<T, S>`라고 표현된다. 여기서 "T"와 "S"는 기본 유형을 제외한 모든 유형을 나타낸다. `Map<T, S>`는 T와 S의 두 가지 유형 매개 변수가 있는 매개 변수화된 유형의 예이다. 섹션 10.3에서 맵을 더 자세히 볼 때까지 이 가능성에 대해 더 이상 다루지 않을 것이다. 이 섹션과 다음 섹션에서는 컬렉션만 살펴 본다.

컬렉션에는 목록(lists)과 세트(sets)라는 두 가지 유형이 있다. 목록은 객체가 선형 순서로 배열된 모음이다. 목록에는 첫 번째 항목, 두 번째 항목 등이 있다. 목록의 모든 항목 (마지막 항목 제외)에는 해당 항목 바로 뒤에 항목이 있다. "세트(sets)"인 컬렉션의 정의 속성은 어떤 객체도 세트에서 두 번 이상 나타날 수 없다는 것이다. 집합의 요소가 반드시 특정 순서로 존재하는 것으로 간주되는 것은 아니다. 목록과 집합의 아이디어는 매개변수화된 인터페이스 `List<T>` 및 `Set<T>`로 표현된다. 이는 `Collection<T>`의 하위 인터페이스이다. 그건 `Collection<T>`도 자동으로 구현한다. `Collection<T>` 인터페이스는 모든 컬렉션에 적용할 수 있는 작업을 지정한다. `List<T>` 및 `Set<T>`는 각각 목록과 집합에 적합한 추가 작업을 추가한다.

물론 컬렉션, 목록 또는 집합이니 실제 객체는 해당 인터페이스를 구현하는 구체적인 클래스에 속해야 한다. 예를 들어 ArrayList<T> 클래스는 List<T> 인터페이스를 구현하므로 Collection<T>도 구현한다. 이는 목록 및 컬렉션 인터페이스에 정의된 모든 메서드를 ArrayList와 함께 사용할 수 있음을 의미한다. 다음 섹션에서는 목록 및 집합 인터페이스를 구현하는 다양한 클래스를 살펴본다. 하지만 그 전에 모든 컬렉션에 사용할 수 있는 일반 작업 중 일부를 간략하게 살펴본다.

---

Collection<T> 인터페이스는 객체 컬렉션에 대해 몇 가지 기본 작업을 수행하기 위한 메서드를 지정한다. "컬렉션"은 매우 일반적인 개념이므로 모든 컬렉션에 적용할 수 있는 작업도 매우 일반적이다. 이는 다양한 유형의 객체를 포함하는 다양한 유형의 컬렉션에 적용될 수 있다는 점에서 일반적인 작업이다. `coll`이 Collection<T> 인터페이스를 구현하는 객체라고 가정한다. 다음 작업은 `coll`에 대해 정의된다. 

- `coll.size()` : 컬렉션의 객체 수를 제공하는 int 반환
- `coll.isEmpty()` : 컬렉션의 크기가 0인 경우 true인 boolean 값을 반환
- `coll.clear()` : 컬렉션에서 모든 객체를 제거
- `coll.add(toObject)` : 컬렉션에 toObject를 추가. 매개 변수는 T 유형이어야 한다.
- `coll.contains(object)` : 객체가 컬렉션에 있으면 true인 boolean 값을 반환
- `coll.remove(object)` : 컬렉션에 객체가 있는 경우 컬렉션에서 객체를 제거하고 객체가 발견되었는지 여부를 알려주는 boolean 값을 반환
- `coll.containsAll(coll2)` : coll2의 모든 객체가 coll에도 있는 경우 true인 boolean 값을 반환
- `coll.addAll(coll2)` : coll2의 모든 객체가 coll에 추가한다.
- `coll.removeAll(coll2)` : coll2 컬렉션에도 발생하는 coll에서 모든 객체를 제거한다.
- `coll.retainAll(coll2)` : coll2 컬렉션에서 발생하지 않는 coll에서 모든 객체를 제거한다. coll2에서 발생하는 객체만 "보유"한다.
- `coll.toArray()` : 컬렉션의 모든 항목을 포함하는 `Object[]` 유형의 배열을 반환한다.

이러한 메서드는 Collection<T> 인터페이스의 일부이므로 해당 인터페이스를 구현하는 모든 객체에 대해 정의되어야 한다. 그러나 여기에는 문제가 있다. 예를 들어 일부 컬렉션의 크기는 생성된 후에 변경할 수 없다. 객체를 추가하거나 제거하는 메서드는 이러한 컬렉션에 적합하지 않다. 메서드를 호출하는 것은 여전히 적법하지만 런타임에 호출이 평가되면 예외가 발생한다. 예외 유형은 `UnsupportedOperationException`이다. 게다가 Collection<T> 이후 구체적인 클래스가 아닌 인터페이스일 뿐이므로 메서드의 실제 구현은 인터페이스를 구현하는 클래스에 맡겨진다. 즉, 위에서 설명한 대로 메서드의 의미가 모든 컬렉션 객체에 대해 유효하다고 보장되지는 않는다. 그러나 Java Collection Framework의 클래스에는 유효하다. 

효율성의 문제도 있다. 여러 유형의 컬렉션에 대해 작업이 정의된 경우에도 모든 경우에 동일하게 효율적이지는 않을 수 있다. `size()` 처럼 간단한 메서드라도 효울성은 크게 다를 수 있다. 일부 컬렉션의 경우 `size()` 계산에는 컬렉션의 항목 수 계산이 포함될 수 있다. 이 프로세스의 단계 수는 항목 수와 같다. 다른 컬렉션에는 크기를 추적하는 인스턴스 변수가 있을 수 있으므로 `size()`를 평가한다. 단지 변수의 값을 반환한다는 의미이다. 이 경우 항목 수에 관계없이 계산은 한 단계만 수행된다. 컬렉션으로 작업할 때 작업이 효율적인지 파악하고 필요한 작업을 가장 효율적으로 구현할 수 있는 컬렉션을 선택하는 것이 좋다. 다음 두 섹션에서 이에 대한 구체적인 예를 살펴본다.


## 5. Iterator와 for-each 루프

Collection<T> 인터페이스는 몇 가지 기본 일반 알고리즘을 정의하지만 자신만의 일반 알고리즘을 작성한다고 가정한다. 예를 들어 컬렉션의 모든 항목을 인쇄하는 것처럼 간단한 작업을 수행한다고 가정해 본다. 일반적인 방식으로 이를 수행하려면 임의의 컬렉션을 통과하여 각 항목에 차례로 엑세스하는 방법이 필요하다. 우리는 특정 데이터 구조에 대해 이를 수행하는 방법을 살펴본다. 배열의 경우 for를 사용할 수 있다. 모든 배열 인덱스를 반복하는 루프이다. 연결된 목록의 경우 목록을 따라 포인터를 이동시키는 while 루프를 사용할 수 있다. 이진 트리의 경우 재귀 서브 루틴을 사용하여 중위 순회를 수행할 수 있다. 컬렉션은 이러한 형식과 그 외 다양한 형식으로 표현될 수 있다. 이러한 다양한 순회 메커니즘을 사용하여 완전히 다른 형식으로 저장된 컬렉션에 대해 작동하는 단일한 일반적인 방법을 어떻게 고안할 수 있나?? 이 문제는 **반복자 (iterator)** 로 해결된다. 반복자는 컬렉션을 순회하는 데 사용할 수 있는 객체이다. 다양한 유형의 컬렉션에는 다양한 방식으로 구현되는 반복자가 있지만 모든 반복자가 사용된다. 같은 방법으로 컬렉션을 순회하기 위해 반복자는 처음으로 일반 프로그래밍을 접하는 사람에게는 다소 이상하게 보일 수 있지만 어려운 문제는 우아한 방식으로 해결한다는 점을 이해해야 한다.

Collection<T> 인터페이스는 컬렉션에 대한 반복자를 얻는 데 사용할 수 있는 메서드를 정의한다. `coll`이 컬렉션인 경우 `coll.iterator`는 컬렉션을 순회하는 데 사용할 수 있는 반복자를 반환한다. 반복자는 컬렉션의 시작 부분에서 시작하고 컬렉션을 따라 한 항목에서 다음 항목으로 이동할 수 있는 일종의 일반화된 포인터로 생각해야 한다. 반복자는 `Iterator<T>`라는 매개변수화된 인터페이스에 의해 정의된다. `coll`이 특정 유형 T에 대해 Collection<T> 인터페이스를 구현하는 경우 `coll.iterator`는 Iterator<T> 유형의 반복자를 반환한다. 유형 매개변수와 동일한 유형 T를 사용한다. Iterator<T> 인터페이스는 세 가지 메서드만 정의한다. `iter`가 Iterator<T>를 구현하는 객체를 참조하는 경우 다음과 같다.

- `iter.next()` : 다음 항목을 반환하고 반복자를 전진시킨다. 반환 값은 T 유형이다. 남아 있는 항목이 없을 때 이 메서드를 호출하면 `NoSuchElementException`이 발생한다.
- `iter.hasNext()` : 처리할 항목이 더 있는지 여부를 알려주는 boolean 값을 반환한다.
- `iter.remove()` : `iter.next()`를 호출한 후 이를 호출하면 컬렉션에서 방금 본 항목이 제거된다. 이 메서드에는 매개 변수가 없다.

반복자를 사용하면 컬렉션의 모든 항목을 인쇄하는 코드를 작성할 수 있다. 예를 들어 `coll`이 Collection<String> 유형이라고 가정해 본다. 이 경우 `coll.iterator`가 반환한 값은 Iterator<String> 유형이며 다음과 같이 말할 수 있다.

```java
Iterator<String> iter;
iter = coll.iterator();

while (iter.hasNext()) {
    String item = iter.next();
    System.out.println(item);
}
```

동일한 제네릭 양식이 다른 유형의 처리에도 적용된다. 예를 들어 다음 코드는 Collection<Color> 유형의 컬렉션에도 모든 `null` 값을 제거한다.

```java
Iterator<Color> iter = coll.iterator():
while ( iter.hasNext() ) {
    Color item = iter.next();
    if (item == null)
       iter.remove();
}
```

(그런데, Collection<T>, Iterator<T> 또는 기타 매개변수화된 유형이 실제 코드에서 사용되는 경우 항상 정식 유형 매개 변수 대신 String 또는 Color와 같은 실제 유형과 함께 사용된다.)

반복자는 컬렉션의 모든 요소에 동일한 작업을 적용하는 데 자주 사용된다. 대부분의 경우 for-each 루프를 사용하면 이러한 목적으로 반복자를 사용하지 않는 것이 가능하다. for-each 루프는 배열과 함께 사용하는 경우 섹션 7.1.1에서, ArrayList와 함께 사용하는 경우 섹션 7.3.3에서 논의했다. 그러나 실제로 for-each 루프를 사용하여 모든 컬렉션을 반복할 수 있다. Collection<T> 유형의 컬렉션 `coll`의 경우 for-each 루프는 다음 형식을 사용한다.

```java
for (T x : coll) {
    // process x
}
```

여기서 x는 루프 제어 변수이다. `coll`의 각 객체는 차례로 x에 할당되고 루프 본문은 각 객체에 대해 실행된다. `coll`은 T유형 이므로 T 유형으로 선언된다. 예를 들어 `nameList`가 Collection<String> 유형인 경우 다음을 사용하여 컬렉션의 모든 이름을 인쇄할 수 있다.

```java
for (String name : nameList) {
    System.out.println(name);    
}
```

물론 이 for-each 루프는 반복자를 사용하여 while 루프로 작성할 수 있지만 for-each 루프를 따르는 것이 훨씬 쉽다.

## 6. 동등성 비교

Collection 인터페이스에는 객체의 동등성을 테스트하는 여러 메서드가 있다. 예를 들어, `coll.contains(object)` 및 `coll.remove(object)` 메서드는 컬렉션에서 object와 동일한 항목을 찾는다. 그러나 동등성은 그렇게 간단한 문제가 아니다. `==` 연산자를 사용하여 동등성성을 테스트하는 확실한 기술은 객체에 적용될 때 일반적으로 합리적인 답을 제공하지 않다. `==` 연산자는 두 객체가 메모리에서 동일한 위치를 공유한다는 점에서 동일한지 여부를 테스트한다. 그러나 일반적으로 우리는 두 객체가 동일한 값을 나타내는 경우 동일한 것으로 간주하려고 하는 데 이는 매우 다르다. 문자열 유형의 두 값이 동일한 문자 시퀀스를 포함하는 경우 동일한 것으로 간주되어야 한다. 해당 문자가 메모리의 동일한 위치에 저장되어 있는지 여부는 중요하지 않다. Date 유형의 두 값이 동일한 시간을 나타내는 경우 동일한 것으로 간주되어야 한다.

우리는 Object 클래스가 한 객체가 다른 객체와 같은지 여부를 테스트하기 위해 boolean 값 메서드인 `equals(Object)`를 정의한다는 것을 확인했다. 이 방법은 두 객체가 동일한 것으로 간주되는지 여부를 결정하기 위해 전체가 아닌 많은 컬렉션 클래스에서 사용된다. Object 클래스에서 `obj1.equals(obj2)`는 `obj1 == obj2`와 동일하게 정의된다. 그러나 Object의 많은 하위 클래스에 대해 이 정의는 타당하지 않으므로 재정의해야 한다. 예를 들어, String 클래스의 `str`인 경우 `str.equals(obj)` 값이 되도록 `equals()`를 재정의한다. `obj`도 String이고 `obj`가 `str`과 동일한 문자 시퀀스를 포함하는 경우 `true`이다.

자신만의 클래스를 작성하는 경우 객체가 동일한지 테스트할 때 올바른 동작을 얻기 위해 해당 클래스에 `equals()` 메서드를 정의할 수 있다. 예를 들어 컬렉션에서 사용될 때 올바르게 작동하는 Card 클래스는 다음과 같이 정의될 수 있다. 

```java
public class Card {
    
    private int suit;
    private int value; 

    public boolean equals(Object obj) {
        try {
            Card other = (Card)obj;  
            if (suit == other.suit && value == other.value) {
                // 다른 카드의 모양과 값이 동일합니다.
                // 이 카드이므로 동일한 것으로 간주되어야 합니다.
                return true;
            }
            else {
                return false;
            }
        }
        catch (Exception e) {
            // obj가 발생하는 경우 발생하는 NullPointerException을 포착합니다.
            // null이고 obj가 다음인 경우 발생하는 ClassCastException입니다.
            // 카드 유형이 아닙니다. 이 경우 obj는 다음과 같지 않습니다.
            // 이 카드이므로 false를 반환합니다.
            return false;
        }
    }

    // other methods and constructors
    
}
```

이 클래스에 `equals()` 메서드가 없으면 Collection<Card> 인터페이스의 `contain()` 및 `remove()`와 같은 메서드가 예상되로 작동하지 않는다.

컬렉션의 항목을 정렬할 때도 비슷한 문제가 발생한다. 정렬은 일부 기준에 따라 항목의 순서를 오름차순으로 정렬하는 것을 의미한다. 문제는 임의의 객체에 대해 오름차순이라는 자연스러운 개념이 없다는 것이다. 객체를 정렬하면 객체를 비교하기 위한 몇 가지 방법을 정의해야 한다. 비교하려는 객체는 `java.lang.Comparable` 인터페이스를 구현해야 한다. 실제로 Comparable은 T 유형의 객체와 비교할 수 있는 기능을 나타내는 매개변수화된 인터페이스인 Comparable<T>로 정의된다. 다음 한 가지 메서드를 정의한다.

```java
public int compareTo(T obj)
```

`obj1.compareTo(obj2)`에 의해 반환된 값은 객체가 오름차순으로 정렬될 때 `obj1`이 `obj2` 보다 앞에 오는 경우에만 음수여야한다. `obj1`이 `obj2` 뒤에 오는 경우에만 양수여야 한다. 반환 값이 0이면 이 비교를 위해 객체가 동일한 것으로 간주된다는 의미이다. 이는 `obj1.equals(obj2)`가 참이라는 점에서 객체가 동일하다는 의미는 아니다. 그러나 일반적으로 Comparable을 구현하는 클래스는 `obj1.equals(obj2)` 및 `obj1.compareTo(obj2) == 0`은 항상 같은 값을 갖는다.

String 클래스는 Comparable<String> 인터페이스를 구현하고 합리적인 방식으로 CompareTo를 정의한다. 이 경우 비교되는 두 문자열이 동일한 경우에만 CompareTo의 반환 값은 0이다. 자신만의 클래스를 정의하고 해당 클래스에 속하는 객체를 정렬하려면 동일한 작업을 수행해야 한다.

```java
/**
 * 이름과 성으로 구성된 전체 이름을 나타냅니다.
 */
public class FullName implements Comparable<FullName> {

    private String firstName, lastName;  

    public FullName(String first, String last) { 
        if (first == null || last == null)
            throw new IllegalArgumentException("Names must be non-null.");
        firstName = first;
        lastName = last;
    }

    public boolean equals(Object obj) {
        try {
            FullName other = (FullName)obj;  
            return firstName.equals(other.firstName)
                    && lastName.equals(other.lastName);
        }
        catch (Exception e) {
            return false; 
        }
    }

    public int compareTo( FullName other ) {
        int compareLast = lastName.compareTo(other.lastName);
        if ( compareLast < 0 ) {
            // lastName이 성보다 앞에 오는 경우
            // 다른 객체인 경우 이 FullName이 옵니다.
            // 다른 FullName 앞에. 부정적인 결과를 반환
            // 이를 나타내는 값입니다.
            return -1;
        }
        else if ( compareLast > 0 ) {
            // lastName이 성 뒤에 오는 경우
            // 다른 객체인 경우 이 FullName이 옵니다.
            // 다른 FullName 뒤에. 긍정적인 결과를 반환
            // 이를 나타내는 값입니다.
            return 1;
        }
        else {
            // 성이 동일하므로 다음을 기준으로 비교합니다.
            // String 클래스의 CompareTo를 사용하여 이름을 지정합니다.
            return firstName.compareTo(other.firstName);
        }
    }
    
}
```

여기서 클래스가 `class FullName implements Comparable<FullName>`으로 선언되고 인터페이스 이름에서 유형 매개 변수로 "FullName"이 반복되는 것이 조금 이상하다고 생각한다. 그러나 그것은 의미가 있다. 이는 FullName 클래스에 속하는 객체를 동일한 유형의 다른 객체와 비교한다는 의미이다. 이것이 유일하게 합리적인 조치임에도 불고하고 그 사실은 Java 컾아일러에 명확하지 않으며 Comparable<FullName>의 유형 매개 변수는 컴파일러를 위해 존재한다.

(섹션 7.4.1에서 FullName을 레코드 클래스로 접한 적이 있다. 레코드 클래스는 인터페이스를 구현할 수 있으므로 Comparable<FullName>을 구현하기 위해 FullName 레코드 클래스를 정의하라 수 있다는 점을 기억하자. 레코드 클래스에서 `equals()` 메서드가 이미 적절하게 정의되어 있을 것이다.)

Java에서 객체 비교를 허용하는 또 다른 방법은 비교가 가능한 별도의 객체가 제공하는 것이다. 객체는 Comparator<T> 인터페이스를 구현해야 한다. 여기서 T는 비교할 객체의 유형이다. Comparator<T> 인터페이스는 다음 메서드를 정의한다.

```java
public int compare(T obj1, T obj2)
```

이 메서드는 T 유형의 두 객체를 비교하고 `obj1`이 `obj2`가 앞에 오는지, 뒤에 오는지 또는 이 비교를 위해 동일한 것으로 간주되는지에 따라 음수, 양수 또는 0인 값을 반환한다. Comparable 인터페이스를 구현하지 않는 객체를 비교하고 동일한 객체 컬렉션에 대해 여러 가지 다른 순서로 정의하는 데 유용하다. Comparator는 기능적 인터페이스 이므로 비교기는 종종 람다식으로 정의된다. 

`obj1.equals(obj2)`가 항상 `compare(obj1, obj2) == 0`과 동일한 값을 가지지 않는 비교기를 사용하는 것이 합리적일 수 있다는 점에 유의하자. 

다음 두 섹션에서는 컬렉션과 맵의 맥락에서 Comparable과 Comparator가 어떻게 사용되는지 살펴본다.

## 7. 제네릭과 래퍼(Wrapper) 클래스

섹션 7.3에서 ArrayList를 언급한 것 처럼 Java 제네릭 프로그래밍은 기본 유형에 적용되지 않는다. 이는 일반 데이터 구조가 객체만 보유할 수 있고 기본 유형의 값은 객체가 아니기 때문이다. 섹션 7.3.2에 도입된 "래퍼 클래스"를 사용하면 이러한 제한을 상당 부분 해결할 수 있다.

각 기본 유형에는 연관된 래퍼 클래스가 관련되어 있음을 기억하자.

Integer 유형에 객체에는 int 유형의 값이 포함된다. 객체는 기본 유형값에 대한 "래퍼"역할을 하여 이를 통해 일반 데이터 구조와 같이 객체가 필요한 컨텍스트에서 사용할 수 있다. 예를 들어 정수 목록은 ArrayList<Integer> 유형의 변수에 저장될 수 있으며 Collection<Integer> 및 Set<Integer>와 같은 인터페이스가 정의된다. 또한 Integer 클래스는 `equals()`, `compareTo()`, `toString()`를 정의한다. 예상하는 작업을 수행하는 메서드는 모든 래퍼 클래스에 적용된다.

Java는 기본 유형과 해당 래퍼 유형간에 자동 변화을 수행한다는 점도 기억하자. (오토박싱, 언박싱) 이는 래퍼 클래스 중 하나에 속하는 객체를 보유하기 위해 일반 데이터 구조를 생성한 후에는 데이터 구조를 꽤 사용할 수 있음을 의미한다. 마치 실제로 기본 유형 값이 포함된 것과 같다. 예를 들어, 숫자가 Collection<Integer> 유형의 변수인 경우 `number.add(17)` 또는 `number.remove(42)`를 호출하는 것이 적법하다. 문자 그대로인 "17"은 추가할 수 없다. 그러나 Java는 자동으로 17을 해당 래퍼 객체인 `Integer.valueof(17)`로 변환하고 래퍼 객체가 컬렉션이 추가된다. 


















