# 스레드와 병렬 처리

이전 섹션 12.2.4의 예에서 대규모 작업의 일부를 실행하기 위해 병렬 처리를 사용했다. 여러 프로세서가 있는 컴퓨터에서는 이를 통해 계산을 더 빠르게 완료할 수 있다. 그러나 프로그램이 계산을 하위 작업으로 나누는 방식은 최적이 아니었다. 스레드를 관리하는 방식도 마찬가지였다. 이 섹션에서는 해당 프로그램의 두 가지 버전을 더 살펴본다. 첫 번째는 문제가 하위 작업으로 분해되는 방식을 개선한다. 두 번째는 스레드가 사용되는 방식을 개선한다. 그 과정에서 병렬 처리를 지원하기 위해 Java가 제공하는 몇 가지 내장 클래스를 소개하나다. 이 섹션 뒷 부분에서 `wait()`, `inform()`을 다룰 것 이다. 병렬 프로세스를 보다 직접적으로 제어하는 데 사용할 수 있는 하위 수준 방법이다.

## 1. 문제 분해(Decomposition)

샘플 프로그램 [MultiprocessingDemo1.java](https://math.hws.edu/javanotes/source/chapter12/MultiprocessingDemo1.java)에서는 이미지 계산 작업을 여러 하위 작업으로 나누고 각 하위 작업을 스레드에 할당한다. 이 작업은 문제 없이 작동하지만 문제가 있다. 일부 하위 작업은 다른 작업보다 훨씬 오래 걸릴 수 있다. 프로그램은 이미지를 동일한 부분으로 나누지만 사실 이미지의 일부 부분에는 다른 부분보다 더 많은 계산이 필요하다. 실제로 세 개의 스레드로 프로그램을 실행하면 중간 부분이 위쪽이나 아래쪽 부분보다 계산하는 데 약간 더 오래 걸린다는 것을 알 수 있다. 일반적으로 문제를 하위 문제로 나눌 때 각 하위 문제를 해결하는 데 걸리는 시간을 예측하기는 매우 어렵다. 특정 하위 문제 하나가 다른 모든 하위 문제보다 시간이 훨씬 오래 걸린다고 가정해 본다. 해당 하위 문제를 계산하는 스레드는 다른 모든 스레드가 완료된 후에도 상대적으로 오랜 시간 동안 계속 실행된다. 그 시간 동안에만, 컴퓨터 프로세서 중 하나가 작동 중이다. 나머지는 idle 상태이다. 

간단한 예로, 컴퓨터에 두 개의 프로세서가 있다고 가정한다. 문제를 두 개의 하위 문제로 나누고 각 하위 문제를 실행하는 스레드를 생성한다. 두 프로세서를 모두 사용하면 하나의 프로세서를 사용할 때보다 절반의 시간 안에 답을 얻을 수 있기를 바란다. 그러나 하나의 하위 문제를 해결하는 데 다른 문제보다 4배 더 오랜 시간이 걸린다면 대부분의 경우 하나의 프로세서만 작동하게 된다. 이 경우 답변을 얻는데 필요한 시간은 20%만 단축된다.

문제를 동일한 양의 계산이 필요한 하위 문제로 나누더라고 여전히 해결하는 데 동일한 시간이 필요한 모든 하위 문제에 의존할 수는 없다. 예를 들어 컴퓨터의 일부 프로세서가 다른 프로그램을 실행하는 중일 수 있다. 아니면 일부 프로세서가 다른 프로세서보다 느릴 수도 있다. (단일 컴퓨터에서 계산을 실행할 때는 이런 일이 발생하지 않지만, 이 장의 뒷부분에서 설명할 것처럼 네트워크로 연결된 여러 컴퓨터에 계산을 분산할 때는 프로세서 속도의 차이가 주요 문제가 될 수 있다.)

이 모든 것을 처리하는 일반적인 기술은 문제를 상당히 많은 수의 하위 문제(프로세서보다 더 많은 하위 문제)로 나누는 것이다. 이는 각 프로세서가 여러 하위 문제를 해결해야 함을 의미한다. 처리자가 하나의 하위 작업을 완료할 때마다 모든 하위 작업이 할당될 때까지 작업할 다른 하위 작업이 할당된다. 물론, 다양한 하위 작업에 필요한 시간에는 여전히 차이가 있다. 한 프로세서는 여러 하위 문제를 완료할 수 있고 다른 프로세서는 특히 어려운 사례를 처리할 수 있다. 느리거나 사용량이 많은 프로세서는 하위 문제가 아주 작은 한, 대부분의 프로세서는 계산이 거의 끝날 때까지 바쁜 상태를 유지할 수 있다. 

**로드 밸런싱(load balancing)** : 사용 가능한 프로세서를 최대한 바쁘게 유지하기 위해 계산 로드가 사용 가능한 프로세서 간에 균형을 이룬다. 물론 일부 프로세서는 다른 프로세서보다 먼저 완료되지만 가장 긴 하위 작업을 완료하는데 걸리는 시간보다 길지는 않다.

하위 문제는 작아야 하지만 너무 작아서는 안된다. 하위 문제를 생성하고 이를 프로세서에 할당하는 데에는 약간의 계산 오버헤드가 있다. 하위 문제가 매우 작은 경우 이 오버헤드는 수행해야 하는 총 작업량에 크게 추가될 수 있다. 예제 프로그램에서 작업은 이미지의 각 픽셀에 대한 색상을 계산하는 것이다. 해당 작업을 하위 작업으로 나누기 위한 한 가지 가능성은 각 하위 작업이 단 하나의 픽셀만 계산하도록 하는 것이다. 그러나 그런 방식으로 생성된 하위 작업은 아마도 너무 작을 것이다. 따라서 프로그램의 각 하위 작업은 한 행의 픽셀에 대한 색상을 계산한다. 이미지에는 수백 행의 픽셀이 있으므로 하위 작업의 수가 상당히 많고 각 하위 작업도 상당히 크다. 그 결과 합리적인 양의 오버헤드와 함께 상당히 좋은 로드 밸런싱이 이루어졌다.

그런데 우리가 작업하고 있는 문제는 병렬 프로그래밍에 있어서는 매우 쉬운 문제라는 점에 유의하세요. 이미지 계산 문제를 하위 문제로 나누면 모든 하위 문제가 완전히 독립적이다. 동시에 여러 작업을 수행할 수 있으며 순서에 관계없이 수행할 수 있다. 일부 하위 작업이 다른 하위 작업에 필요한 결과를 생성하면 상황이 훨씬 더 복잡해진다. 이 경우 하위 작업은 독립적이지 않으며 하위 작업이 수행되는 순서가 중요하다. 또한 한 하위 작업의 결과를 다른 작업과 공유할 수 있는 방법이 있어야 한다. 하위 작업이 다른 스레드에 의해 실행되면 공유 리소스에 대한 스레드 엑세스 제어와 관련된 모든 문제가 발생한다. 따라서 일반적으로 병렬 처리를 위해 문제를 분해하는 것은 상대적으로 간단한 예에서 나타나는 것보다 훨씬 더 어렵다. 그러나 대부분의 경우 이는 입문 프로그래밍 과정이 아닌 병렬 컴퓨팅 과정의 주제이다.

## 2. 스레드 풀과 작업 큐(대기열)

작업을 하위 작업으로 분해하는 방법을 결정한 후에는 해당 하위 작업을 스레드에 할당하는 방법에 대한 질문이 있다. 일반적으로 객체 지향 접근 방식에서는 각 하위 작업이 객체로 표시된다. 작업은 일부 계산을 나타내므로 이를 나타내는 객체가 계산을 수행하는 인스턴스 메서드를 갖는 것은 당연하다. 작업을 실행하려면 해당 계산 메서드를 호출하기만 하면 된다. 프로그램에서 계산 메서드는 `run()`이라고 하며 작업 객체는 섹션 12.1.1에서 논의한 표준 Runnable 인터페이스를 구현한다. 이 인터페이스는 계산 작업을 나타내는 자연스러운 방법이다. 각 Runnable에 대해 새 스레드를 생성하는 것이 가능하다. 그러나 작업이 많을 때는 각각의 새 스레드를 생성하는 데 상당한 양의 오버헤드가 발생하므로 이는 실제로 의미가 없다. 더 나은 대안은 몇 개의 스레드만 생성하고 각 스레드가 여러 작업을 실행하도록 하는 것이다.

사용할 최적의 스레드 수는 완전히 명확하지 않으며 해결하려는 문제가 정확히 무엇인지에 따라 달라질 수 있다. 목표는 컴퓨터의 모든 프로세서를 계속 사용하도록 유지하는 것이다. 이미지 컴퓨팅 예에서는 사용 가능한 각 프로세서에 대해 하나의 스레드를 생성하는 것이 잘 작동하지만 모든 문제에 해당되는 것은 아니다. 특히 스레드가 일부 이벤트를 기다리거나 일부 리소스에 엑세스하는 동안 적지 않은 시간 동안 차단될 수 있는 경우 다른 스레드가 차단되는 동안 프로세서가 실행될 수 있도록 추가 스레드가 있어야 한다. 섹션 12.4세어 네트워킹과 함께 스레드를 사용하게 되면 바로 그러한 상황에 직면하게 될 것이다.

작업을 수행하는 데 여러 스레드를 사용할 수 있는 경우 해당 스레드를 **스레드 풀(thread pool)**이라고 한다. 스레드 풀은 각 작업을 수행하기 위해 새 스레드가 생성되는 것을 방지하는 데 사용된다. 대신 작업을 수행해야 할 경우 "풀"의 idle 스레드에 해당 작업을 할당할 수 있다.

스레드 풀의 모든 스레드가 사용 중이며 스레드 중 하나가 idle 상태가 될 때까지 추가 작업을 기다려야 한다. 이는 큐에 대한 자연스러운 응용 프로그램이다. 스레드 풀과 연결된 것은 대기 중인 작업의 큐이다. 작업을 사용할 수 있게 되면 대기열에 추가된다. 스레드가 작업을 완료할 때마다 작업할 다른 작업을 가져오기 위해 대기열로 이동한다.

스레드 풀에는 작업 대기열이 하나만 있다. 풀의 모든 스레드는 동일한 대기열을 사용하므로 대기열은 공유 리소스이다. 항상 공유 리소스와 마찬가지로 경쟁 조건이 발생할 수 있으며 동기화가 필수적이다. 예를 들어 동기화가 없으면 큐에서 항목을 동시에 가져오려는 두 스레드가 결국 동일한 항목을 검색하게 될 수 있다. 

Java에는 이 문제를 해결하기 위해 내장 클래스인 ConcurrentLinkedQueue가 있다. 이 클래스와 병렬 ㅍ르ㅗ그래밍에 유용할 수 있는 다른 클래스는 `java.util.concurrent` 패키지에 정의되어 있다. 매개 변수화된 클래스이다. Runnable 유형의 객체를 보유할 수 있는 큐를 생성하려면 다음과 같이 말할 수 있다.

```java
ConcurrentLinkedQueue<Runnable> queue = new ConcurrentLinkedQueue<>();
```

이 클래스는 큐에 대한 작업이 적절하게 동기화되는 연결 목록으로 구현된 큐를 나타낸다. ConcurrentLinkedQueue에 대한 작업은 우리가 익숙한 큐 작업과 정확히 다르다. `queue` 끝에 새 항목 `x`를 추가하는 방법은 `queue.add(x)`이다. 앞 부분에서 항목을 제거하는 방법은 `queue.poll()`이다. 비어 있으면 `null`을 반환한다. 따라서 `poll()`은 대기열이 비어 있지 않은지 테스트 하는 것은 경쟁 조건과 관련되므로 이런 방식으로 작업을 수행하는 것이 합리적이다. 동기화가 없으면 다른 스레드가 해당 시간 사이에 대기열에서 마지막 항목을 제거할 수 있다. 대기열이 비어 있지 않은지 확인하고 대기열에서 항목을 가져오라고 하는 시간이다. 아이템을 얻으려고 할 때 거기에는 아무것도 없다. 반면, `queue.poll()`은 "atomic" 작업이다.

---

이미지 컴퓨팅 예제에서 ConcurrentLinkedQueue를 사용하려면 스레드 풀과 함께 대기열을 사용할 수 있다. 이미지 계산을 시작하려면 이미지를 구성하는 모든 작업을 생성하고 이를 대기열에 추가한다. 그런 다음 작업을 실행할 작업자 스레드를 만들고 시작할 수 있다. 각 스레드는 대기열의 `poll()` 메서드를 호출하여 대기열에서 하나의 작업을 가져와 해당 작업을 수행하는 루프에서 실행된다. 작업은 Runnable 유형의 객체이므로 스레드가 작업의 `run()` 메서드를 호출하는 것만 필요하다. `poll()` 메서드가 `null`을 반환하는 경우, 대기열은 비어 있고 모든 작업이 스레드에 할당되었기 때문에 스레드가 종료될 수 있다.

샘플 프로그램 [MultiprocessingDemo2.java](https://math.hws.edu/javanotes/source/chapter12/MultiprocessingDemo2.java)는 이 아이디어를 구현한다. ConcurrentLinkedQueue<Runnable> 유형의 대기열 `tashQueue`를 사용하여 작업을 보관한다. 또한 사용자가 계산이 끝나기 전에 중단할 수 있도록 하기 위해 `volatile` boolean 변수인 `running`을 사용하여 사용자가 계산을 중단할 때 스레드에 신호를 보낸다. 대기열에 아직 작업이 남아 있더라도 이 변수가 `false`로 설정되면 스레드가 종료되어야 한다. 스레드는 WorkerThread 라는 중첩 클래스에 의해 정의된다. 

```java
private class WorkerThread extends Thread {
    public void run() {
        try {
            while (running) {
                Runnable task = taskQueue.poll(); // 대기열에서 작업을 가져옴
                if (task == null)
                    break; 
                task.run();  // 작업을 실행
            }
        }
        finally {
            threadFinished(); // 이 스레드가 종료되었다는 사실을 기록
                                // 호출되었는지 확인하기 위해 마지막으로 완료되었다.
        }
    }
}
```

이 프로그램은 `MandelbrotTask` 라는 중첩 클래스를 사용하여 이미지에서 한 행의 픽셀을 계산하는 작업을 나타낸다. 이 클래스는 Runnable 인터페이스를 구현한다. `run()` 메서드는 실제 작업, 즉 각 픽셀의 색상을 계산하고 해당 색상을 이미지에 적용하는 작업을 수행한다. 다음은 계산을 시작하기 위해 프로그램이 수행하는 작업이다.

```java
taskQueue = new ConcurrentLinkedQueue<Runnable>(); // 큐를 생성
for (int row = 0; row < height; row++) {  // 높이는 이미지의 행 수
    MandelbrotTask task;
    task = ... ;  // 이미지의 한 행을 계산하는 작업을 만든다.
    taskQueue.add(task); // 대기열에 작업을 추
}

int threadCount = ... ; // Number of threads in the pool (selected by user).
workers = new WorkerThread[threadCount];
running = true;  // Set the signal before starting the threads!
threadsRemaining = workers;  // Records how many threads are still running.
for (int i = 0; i < threadCount; i++) {
    workers[i] = new WorkerThread();
    try {
        workers[i].setPriority( Thread.currentThread().getPriority() - 1 );
    } catch (Exception e) {
    }
    workers[i].start();
}
```

스레드가 시작되기 전에 작업을 대기열에 추가하는 것이 중요하다. 스레드는 빈 대기열을 종료 신호로 간주한다. 스레드가 시작될 때 대기열이 비어 있으면 빈 대기열이 표시되어 작업을 수행하지 않고 시작된 직후 종료될 수 있다. 

MultiprocessingDemo2를 사용해 보세요. 동일한 이미지를 계산 하지만 픽셀 행은 해당 프로그램과 동일한 순서로 계산되지 않는다. 주의 깊게 살펴보면 픽셀 행이 위에서 아래로 엄격한 순서로 이미지에 추가되지 않은 것을 볼 수 있다. 이는 한 스레드가 행 번호 `i+1`을 완료하는 동안 다른 스레드가 여전히 행 `i` 또는 그 이전 행에서 작업하는 것이 가능하기 때문이다.

## 3. 생산자(Producer)/소비자(Consumer) 및 차단 대기열




