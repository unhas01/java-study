# Section 2: 알고리즘 개발

프로그래밍은 어렵다 (유용하고 가치 있는 많은 활동들과 마찬가지다 — 또한 그러한 활동들의 대부분과 같이, 보람도 있고 상당히 재미도 있다). 프로그램을 쓸 때에는, 컴퓨터에게 무엇을 해야 하는지에 관한 모든 작은 세부사항들을 알려야 한다. 그리고 컴퓨터는 맹목적으로 당신의 프로그램을 그대로 따를 것이기 때문에 모든 것을 정확하게 맞도록 해야 한다. 그렇다면, 사람들은 가장 간단한 프로그램만을 작성할까? 실제로 이는 큰 미스터리는 아니다. 이는 올바른 사고방식을 배우는 것에 관한 문제이다.

프로그램은 아이디어의 표현이다. 프로그래머는 컴퓨터가 수행할 작업에 대한 일반적인 아이디어로 시작한다. 아마도 프로그래머는, 적어도 개괄적으로는 수동으로 작업을 수행하는 방법에 대한 몇몇 아이디어가 있을 것이다. 문제는 그 개괄을 완벽하고, 모호하지 않은, 단계별 작업 절차로 구체화하는 것이다. 그러한 절차를 "알고리즘"이라고 한다. (기술적으로 **알고리즘(algorithm)** 은 한정된 수의 단계 후에 항상 종료되는, 모호하지 않은 단계별 절차다. 영원히 진행될 수도 있는 절차를 세고 싶지는 않을 것이다.) 알고리즘은 프로그램과 같지 않다. 프로그램은 어떤 특정한 프로그래밍 언어로 쓰여져 있다. 알고리즘은 프로그램 이면에 있는 **아이디어**에 더 가깝지만, 그것은 결국 그 과제가 무엇을 성취해야 하는가에 대한 아이디어만이 아니라, 프로그램이 그 임무를 수행하기 위해 취할 **단계들(steps)** 에 대한 아이디어이다. 알고리즘을 설명할 때, 단계가 명확하고 단계를 수행하면 할당된 작업이 수행된다는 것이 분명한 한, 단계가 반드시 완전히 상세하게 명시될 필요는 없다. 알고리즘은 영어를 포함한 모든 언어로 표현될 수 있다. 물론 알고리즘은 모든 세부 사항을 기재한 경우에만 실제 프로그램으로 표현될 수 있다.

그렇다면 알고리즘은 어디에서 오는 것일까? 통상적으로, 이들은 종종 많은 사고와 힘든 작업과 함께 개발되어야 한다. 알고리즘 개발 기술은 연습으로 나오는 무언가이지만, 도움이 될 수 있는 기술과 지침이 있다. 여기서 "소규모의 프로그래밍"과 관련된 몇 가지 기법과 지침에 대해 이야기 할 것이며, 이후 장에서 해당 주제로 여러 번 돌아갈 것이다.

<hr>

## 1. 유사코드 및 단계적 개량
소규모 프로그래밍을 할 때, 함께 할 몇 가지 기본적인 것들이 있다: 변수, 할당문 및 입출력 루틴. 당신이나 다른 사람이 이미 작성한 서브루틴, 객체 또는 다른 구성 요소도 있을 수 있다. (입력/출력 루틴은 이 클래스에 속한다.) 이러한 기본 명령어들의 나열을 구성하고, `while` 루프 및 `if` 문과 같은 보다 복잡한 제어 구조로 이들을 결합할 수도 있다.

컴퓨터가 수행하도록 염두에 둔 작업이 있다고 가정하자. 작업을 진행하는 한 가지 방법은 작업에 대한 설명을 작성하고, 그 설명을 개발하려는 알고리즘의 초안(outline)으로 삼는 것이다. 그런 다음, 프로그래밍 언어로 직접 번역될 수 있는 완전한 알고리즘을 가질 때까지 단계와 세부사항을 점진적으로 추가하면서, 해당 설명을 다듬고 정교하게 할 수 있다. 이런 방법을 **단계적 개량(stepwise refinement)** 라고 하는데, 하향식 디자인의 일종이다. 단계적 개량 단계를 진행하면서, **유사코드(pseudocode)** 로 알고리즘에 대한 설명을 작성할 수 있다 — 이는 실제 프로그램 코드의 완전한 세부사항과 완벽한 구문이 없는 프로그래밍 언어의 구조를 모방한 약식의 명령어들이다.

예를 들어, 5년간의 투자금을 계산하는 이전 절의 프로그램을 어떻게 개발할 수 있는지 살펴보자. 프로그램이 수행하기를 원하는 과제는 "사용자에 의해 초기 투자금과 이자가 명시되는 상황에서, 향후 5년간의 투자금을 계산하고 표시하라"이다. 그런 다음 이는 다음과 같이 부연될 수 있다고 작성 — 혹은 십중팔구는 그저 생각하기만 — 할 것이다:

```java
사용자의 입력을 받는다
1년 후의 투자금액을 계산한다
금액을 표시한다
2년 후의 금액을 계산한다
금액을 표시한다
3년 후의 금액을 계산한다
금액을 표시한다
4년 후의 금액을 계산한다
금액을 표시한다
5년 후의 금액을 계산한다
금액을 표시한다
```

이는 맞지만 다소 반복적이다. 그리고 해당 반복을 보면, 루프를 사용할 기회를 인식할 것이다. 루프는 타이핑을 적게 할 것이다. 더 중요한 사실은, 이것이 더 **일반적(general)** 이라는 것이다: 아무리 많은 해를 처리하길 바라더라도 본질적으로 동일한 루프가 작동할 것이다. 따라서 위 단계의 순서를 다음과 같이 다시 작성할 수 있다:

```java
사용자의 입력을 받는다
처리할 많은 해가 있는 동안에는:
다음 해의 금액을 계산한다
금액을 표시한다
```

이 알고리즘을 따르면 해당 문제는 해결되지만, 컴퓨터에 대해 "사용자의 입력을 얻는" 방법, "다음 해 이후의 금액를 계산하는" 방법, 그리고 "처리할 많은 해가 더 있다"는 말의 의미에 관하여 좀 더 명확하게 설명해야 할 것이다. 해당 단계인 "사용자의 입력을 얻는" 것을 다음과 같이 확장할 수 있다:

```java
사용자에게 초기 투자금에 대해 묻는다
사용자의 응답을 읽는다
사용자에게 이자에 대해 묻는다
사용자의 응답을 읽는다
```

"다음 해 이후의 금액 계산" 단계의 세부사항을 채우려면, 직접 계산하는 방법을 알아야 한다. (아마도 상사나 교수님께 설명을 부탁해야할까?) 당신이 해당 금액은 이전의 금액에 약간의 이자를 더해 계산된다는 사실을 알고 있다고 하자. 그러면 `while` 루프를 다음과 같이 개량할 수 있다:

```java
처리할 많은 해가 있는 동안에는:
이자를 계산한다
금액에 이자를 더한다
금액을 표시한다
```

처리할 해가 더 남았는지 테스트하는 것에 대해, 할 수 있는 유일한 방법은 스스로 연도를 세는 것이다. 이는 매우 일반적인 패턴(pattern)을 보여주며, 많은 프로그램에서 비슷한 것을 사용하기를 기대해야 한다. 우리는 0년으로 시작하고, 한 해를 처리할 때마다 1년을 더해야 하며, 원하는 해에 도달하면 멈춰야 한다. 이를 종종 **계수 루프(counting loop)** 라고 한다. 그리하여 `while` 루프는 다음과 같이 된다:

```java
years = 0
while years < 5:
    years = years + 1
    이자를 계산한다
    금액에 이자를 더한다
    금액을 표시한다
```

우리는 여전히 이자를 계산하는 방법을 알아야 한다. 이자율을 투자금의 현재 금액에 곱하여 이자를 계산한다고 하자. 이를 사용자의 입력을 얻는 알고리즘 부분과 함께 종합하면, 다음과 같은 완전한 알고리즘을 얻게 된다:

```java
사용자에게 초기 투자금(initial investment)에 대해 묻는다
사용자의 응답을 읽는다
사용자에게 이자(interest)에 대해 묻는다
사용자의 응답을 읽는다
years = 0
while years < 5:
    years = years + 1
    이자를 계산한다. 이자 = 금액 * 이자율(interest rate)
    금액에 이자를 더한다
    금액을 표시한다
```

마지막으로, 적절한 프로그래밍 언어 구문으로 직접 번역할 수 있는 시점이 되었다. 변수의 이름을 선택하고, 사용자에게 말하고 싶은 것이 정확히 무엇인지 결정하는 등의 해야 할 일이 여전히 존재한다. 이를 완료하면 다음과 같이 자바로 우리의 알고리즘을 표현할 수 있다:

```java
double principal, rate, interest;  // 변수 선언
int years;
System.out.print("초기 투자금을 입력: ");
principal = TextIO.getlnDouble();
System.out.print("이율을 입력: ");
rate = TextIO.getlnDouble();
years = 0;
while (years < 5) {
    years = years + 1;
    interest = principal * rate;
    principal = principal + interest;
    System.out.println(principal);
}
```

이것은 여전히 완전한 프로그램으로 포장될 필요가 있고, 주석이 달려야 하며, 사용자를 위해 더 좋은 형식으로 더 많은 정보를 출력해야 한다. 하지만 이는 본질적으로 이전 절의 것과 같은 프로그램이다. (유사코드 알고리즘은 들여쓰기를 사용하여 루프 내부에 어떤 문장이 있는지 표시한다는 점에 유의하라. 자바에서는 들여쓰기가 컴퓨터에 의해 완전히 무시되기 때문에, 어떤 문장이 루프에 있는지 컴퓨터에 알려주기 위해서는 한 쌍의 중괄호가 필요하다. 중괄호를 제외할 경우, 루프 내부의 유일한 문장은 "`years = years + 1`"이 될 것이다. 다른 문장은 루프가 종료된 후 한 번만 실행될 것이다. 고약한 것은 "`(years < 5)`" 주변의 괄호를 빼버린 경우처럼 컴퓨터가 이 오류를 알아채지 못한다는 것이다. 괄호는 `while` 문장의 구문에 의해 요구된다. 중괄호는 의미론적으로만 필요하다. 컴퓨터는 구문 오류는 인식할 수 있지만 의미론적 오류는 인식할 수 없다.)

여기서 한 가지 인식했어야 할 사실은 문제에 대한 필자의 본래 명세(original specification) — "향후 5년 동안의 투자금을 계산하고 표시하라" — 는 완성된 것과는 거리가 멀다는 점이다. 프로그램 작성을 시작하기 전, 프로그램이 수행해야 하는 작업에 대한 완전한 명세를 갖추었는지 확인해야 한다. 특히 프로그램이 어떤 정보를 입출력하고 어떤 계산을 수행할지 알아야 한다. 이 예제에서 문제에 관한 상당히 완전한 명세는 다음과 같다:

```html
"향후 5년 동안의 투자액을 계산하고 표시할 프로그램을 작성하라. 
매년, 해당 금액에 이자가 더해진다. 이자는 현재 가치에 고정 이율을 곱하여 계산된다.
프로그램이 실행될 때 사용자에 의해 초기 금액과 이자율이 입력된다 가정한다."
```

## 2. 3N+1 문제
이번에는, 아직 접하지 못한 프로그램으로 작동하는 다른 예를 들어보자. 여기 과제는 내가 가장 좋아하는 프로그래밍 연습문제 중 하나인 추상적인 수학 문제다. 이번에는 수행되어야 할 작업에 대한 보다 완전한 명세부터 시작하고자 한다:

```html
"양의 정수 N이 주어지며, N부터 시작하는 '3N+1' 순서(sequence)를 다음과 같이 정의한다: 
N이 짝수일 경우, N을 2로 나눈다; N이 홀수일 경우, N을 3으로 곱하고 1을 더한다.
N이 1이 될 때까지 이 방법으로 숫자를 계속 생성하라.
예를 들어, N = 3부터 시작하면, 홀수인 3을 곱하고 1을 더하면 N = 3*3+1 = 10이 된다.
그러면, N이 짝수이므로 2로 나누어서 N = 10/2 = 5를 얻는다. 이런 식으로 계속하면서, 1에 다다르면 멈춘다.
전체 순서는 3, 10, 5, 16, 8, 4, 2, 1이다."

"사용자에게서 양의 정수를 읽고 그 정수로부터 3N+1 순서를 출력할 프로그램을 작성하라.
해당 프로그램은 또한 순서의 항목들 수를 세고 출력해야 한다."
```

우리가 원하는 프로그램 알고리즘의 일반적인 개요는 다음과 같다:

```html
사용자로부터 양의 정수 N을 얻는다.
순서에서 각각의 숫자를 계산하고, 출력하고, 그 수를 센다.
항목들의 수를 출력한다.
```

그 프로그램의 대부분은 두 번째 단계에 있다. 1이 나올 때까지 숫자를 계속 계산하고 싶기에 루프가 필요할 것이다. 이를 `while` 루프에 적합하게 하기 위해, 언제 이를 멈추어야 하는지보다 언제 루프를 **계속해야(continue)** 하는지를 알 필요가 있다: 우리는 해당 숫자가 1이 아닌 한 계속되길 바란다. 그래서 우리의 유사코드 알고리즘을 다음과 같이 확장할 수 있다:

```java
사용자로부터 양의 정수 N을 얻는다;
N이 1이 아니라면 그 동안에는:
N = 다음 항목을 계산한다;
N을 출력한다;
이 항목의 수를 센다;
항목들의 수를 출력한다;
```

다음 항목를 계산하기 위해서는 컴퓨터가 N이 짝수인지 홀수인지에 따라 다른 행동을 취해야 한다. 두 경우 사이에서 하나를 결정할 `if` 문이 필요한 것이다:

```java
사용자로부터 양의 정수 N을 얻는다;
N이 1이 아니라면 그 동안에는:
    만약 N이 짝수라면:
        N = N/2를 계산한다;
    아니라면:
        N = 3 * N + 1을 계산한다;
    N을 출력한다;
    이 항목의 수를 센다;
항목들의 수를 출력한다;
```

거의 다 왔다. 남은 한 가지 문제는 계수(counting)이다. 수를 세는 것은 0부터 시작하여, 셀 것이 있을 때마다 하나를 더하는 일을 뜻한다. 계수를 하려면 변수가 필요하다. 해당 변수는 루프가 시작되기 **전에** 한 번은 0으로 설정되어야 하며, 루프 내에서 증가되어야 한다. (반복하지만, 이것은 계속하여 볼 것이 예상되는 일반적인 패턴이다.) 카운터(counter)를 추가하면 다음과 같은 이점을 얻을 수 있다.

```java
사용자로부터 양의 정수 N을 얻는다;
카운터 = 0으로 설정한다;
N이 1이 아니라면 그 동안에는:
    만약 N이 짝수라면:
        N = N/2를 계산한다;
    아니라면:
        N = 3 * N + 1을 계산한다;
    N을 출력한다;
    카운터에 1을 더한다;
카운터를 출력한다;
```

여전히 가장 첫 번째 단계에 대해 걱정해야 한다. 어떻게 하면 사용자로부터 **양의(positive)** 정수를 얻을 수 있을까? 단순히 숫자로만 읽으면 사용자가 음수로 입력하거나 0으로 입력될 가능성이 있다. N의 값이 음수일 때나 0일 때 일어나는 일을 따라가면, N의 값이 결코 1과 같아질 수 없기 때문에 프로그램이 영원히 계속된다는 것을 알게 된다. 이는 나쁜 일이다. 이 경우에 해당 문제는 아마도 별 일이 아닐 테지만, 일반적으로는 잘못될 수가 없는(foolproof) 프로그램을 쓰도록 노력해야 한다. 이 문제를 해결하는 한 가지 방법은 사용자가 양수로 입력할 때까지 숫자를 계속 읽는 것이다:

```java
사용자에게 양수를 입력하도록 요청한다;
N이 사용자의 응답이 되도록 설정한다;
N이 양수가 아니라면 그 동안에는:
    에러 메시지를 출력한다;
    N의 다른 값을 읽는다;
카운터 = 0으로 설정한다;
N이 1이 아니라면 그 동안에는:
    만약 N이 짝수라면:
        N = N/2를 계산한다;
    아니라면:
        N = 3 * N + 1을 계산한다;
    N을 출력한다;
    카운터에 1을 더한다;
카운터를 출력한다;
```

첫 번째 `while` 루프는 요청한 대로 N이 양수일 때만 종료된다. (일반적으로 시작하는 초보 프로그래머의 오류는 여기서 `if` 문을 `while` 문 대신 사용하는 것이다: "N이 양수가 아니면, 사용자에게 다른 값을 입력하도록 요청한다." 사용자가 입력한 두 번째 번호가 양수가 아닌 경우에도 문제가 발생한다. if 문은 한 번만 실행되기 때문에, 두 번째 입력 번호는 절대 테스트되지 않고 프로그램은 무한 루프로 돌입한다. 두 번째 숫자가 입력된 후, 컴퓨터는 `while` 루프에 의해 다시 루프의 시작으로 돌아가 두 번째 숫자가 양수인지 여부를 테스트한다. 그렇지 않을 경우 사용자에게 세 번째 번호를 요청하며, 사용자가 허용되는 입력을 할 때까지 번호를 계속 요청한다. `while` 루프가 종료되면 N이 양수라는 것을 절대적으로 확신할 수 있게 된다.)

이 알고리즘을 구현하는 자바 프로그램이 여기에 있다. 사용된 연산자 <=는 "대상보다 작거나 같음"을 의미하며 `!=`는 "같지 않음"를 의미한다. N이 짝수인지 여부를 테스트하기 위해 "`N % 2 == 0`"을 사용한다. 여기서 사용하는 모든 연산자는 제2장 제5절에서 논의되었다.

```java
import textio.TextIO;

/**
* This program prints out a 3N+1 sequence starting from a positive
* integer specified by the user.  It also counts the number of
* terms in the sequence, and prints out that number.
*/
public class ThreeN1 {

public static void main(String[] args) {

        int N;       // 순서에서 항목들을 계산하기 위함
        int counter; // 항목들을 세기 위함

        System.out.print("순서의 시작점: ");
        N = TextIO.getlnInt();
        while (N <= 0) {
           System.out.print(
                  "순서의 시작점은 반드시 양수여야 합니다. 다시 입력하세요: " );
           N = TextIO.getlnInt();
        }
        // 이 시점에서 N > 0임을 알게 됨

        counter = 0;
        while (N != 1) {
            if (N % 2 == 0)
               N = N / 2;
            else
               N = 3 * N + 1;
            System.out.println(N);
            counter = counter + 1;
        }

        System.out.println();
        System.out.print("순서에는 ");
        System.out.print(counter);
        System.out.println(" 개의 항목이 있습니다.");

}  // main() 종료

}  // ThreeN1 클래스 종료
```

이 프로그램에 대한 두 가지의 마지막 첨언: 첫째, 순서의 첫 번째 항목 — 사용자가 입력하는 N의 값 — 이 이 프로그램에 의해 인쇄되거나 세어지지 않는다는 것을 알아차렸을 것이다. 이는 오류인가? 그렇다 하긴 어렵다. 프로그램의 명세는 신중하게 결정되었는가? 이것은 상사/교수에게 해명하기 위해 당신을 돌려보낼 수 있는 종류의 것이다. 해당 문제(만약 하나라면!)는 쉽게 고칠 수 있다. 그저 `while` 루프 전의 "`counter = 0`" 행을 다음 두 행으로 교체하면 된다:

```java
System.out.println(N);   // 최초 항목을 출력
counter = 1;       // 해당 항목을 셈
```

둘째, 왜 이 문제가 흥미로운가에 대한 의문이 있다. 흐음, 수학자들과 컴퓨터 과학자들에게는 흥미로울 것이다. 그들이 대답할 수 없었던 간단한 질문 때문이다: 3N+1 순서를 계산하는 과정은 모든 가능한 시작 값 N에 대해 한정된 단계의 수를 거쳐 끝날 것인가? 개별 순서를 계산하기는 쉽지만, 누구도 일반적인 질문에 대답할 수는 없었다. 다른 방법으로 말하면, 알고리즘은 한정된 단계의 수 이후에 종료될 것이 요구되기에, 3N+1 순서를 계산하는 과정이 알고리즘이라고 적절하게 불릴 수 있는지를 아무도 알지 못한다는 것이다! (참고: 이 논의는 자료형 int의 값이 아니라 정수에 정말로 적용되는 것이다! 즉, N의 값이 임의의 큰 정수 값을 취할 수 있다고 가정하는데, 이는 자바 프로그램의 자료형 int의 변수에 대해서 참이 아니다. 프로그램에서 N의 값이 32비트 int로 나타내기에 너무나 큰 경우, 프로그램에 의해 산출되는 값은 더 이상 수학적으로 정확하지 않다. 그렇기에 N이 너무 커지면 자바 프로그램은 정확한 3N+1 순서를 계산하지 않는다. 연습문제 8.2를 보라.)

<hr>

## 3. 코딩, 테스팅, 디버깅
프로그램을 위한 알고리즘을 개발해서, 느긋하게, 버튼을 누르고, 완벽하게 작동하는 프로그램을 얻을 수 있다면 좋을 것이다. 안타깝게도, 알고리즘을 자바 소스코드로 바꾸는 과정이 항상 순조롭게 진행되지는 않는다. 또한 작동하는 프로그램의 단계에 도달했을 때, 이는 종종 **무언가**를 한다는 의미에서만 작용한다. 불행히도 이는 당신이 원하는 게 아니다.

프로그램 설계 후엔 코딩이 등장한다: 해당 설계를 자바 또는 다른 언어로 작성된 프로그램으로 변환하는 것이다. 보통은 아무리 조심해도 어딘가에서 몇 개의 구문 오류가 슬금슬금 기어오고, 자바 컴파일러는 어떤 오류 메시지와 함께 당신의 프로그램을 거부할 것이다. 불행히도, 컴파일러는 항상 구문 오류를 감지하지만, 무엇이 잘못되었는지 정확히 알려주는 것은 그리 좋지는 않다. 때로는 진짜 오류가 어디에 있는지 말해주는 것도 좋지 않다. 철자 오류 또는 45번 행에서의 "{" 누락은 105번 행에서 컴파일러를 질식시킬 수 있다. 언어의 구문 규칙을 정말로 이해하고 몇 가지 기본적인 프로그래밍 지침을 따름으로써 많은 오류를 피할 수 있다. 예를 들어 필자는 대응되는 "}"의 입력 없이는 절대로 "{"를 입력하지 않는다. 그런 후에 돌아가서 중괄호 사이의 문장들을 작성한다. 누락되거나 추가된 중괄호는 거대한 프로그램에서 찾기 가장 어려운 오류 중 하나가 될 수 있다. 항상, 언제나 프로그램을 잘 들여쓰기 바란다. 프로그램을 변경할 경우 들여쓰기가 일치되도록 변경하라. 수고할 가치가 있는 일이다. 일관성 있는 명명 체계(scheme)를 사용하여, 해당 변수를 `interestrate`이라 불렀는지 아니면 `interestRate`라고 불렀는지 기억하려고 애쓸 필요가 없도록 하라. 일반적으로 컴파일러가 여러 오류 메시지를 제공할 때, 첫 번째 오류 메시지를 수정할 때까지 컴파일러의 두 번째 오류 메시지를 수정하지 마라. 컴파일러가 프로그램에서 오류를 발견하면 혼동할 수 있으며, 나머지 오류 메시지는 단순히 추측일 수도 있다. 아마도 가장 좋은 조언은 다음과 같다: 오류를 수정하기 전에 시간을 들여 오류를 이해하라. 프로그래밍은 실험 과학(experimental science)이 아니다.

프로그램이 오류 없이 컴파일될 때, 이는 여전히 완료되지 않은 것이다. 프로그램이 제대로 작동하는지 테스트해야 한다. 교수님이 수업 중에 준 두 가지 샘플 입력에 대한 올바른 출력을 얻는 것이 목표라는 것을 기억하라. 목표는 모든 합리적인 입력에 대해 올바르게 작동하는 프로그램이다. 이상적으로는, 불합리한 입력에 직면했을 때, 충돌하기보다는 사용자를 부드럽게 꾸짖음으로써 대응해야 한다. 매우 폭넓은 입력들로 프로그램을 테스트하라. 프로그램에 코딩한 전체 기능 범위를 테스트할 입력 집합을 찾아보라. 더 큰 프로그램을 쓰기 시작할 때, 단계별로 프로그램을 작성하고 도중에 각 단계를 테스트하라. 심지어 테스트를 수행하기 위해 코드를 추가로 작성해야 할 수도 있다. — 예를 들어 방금 작성한 서브루틴을 호출하는 것. 피할 수 있다면, 어딘가에 오류가 있는 새로 작성된 500줄의 코드에 직면하고 싶지는 않을 것이다.

테스트의 목적은 **버그(bug)** 를 찾는 것이다 — 이는 컴파일 오류라기 보다는 잘못된 행위로써 나타나는 의미론적 오류이다. 그리고 슬픈 사실은 아마도 이들을 찾을 것이라는 점이다. 반복하거니와, 세심한 설계와 세심한 코딩으로 버그를 최소화할 수는 있지만, 어느 누구도 버그를 아예 피할 방법을 찾지는 못했다. 일단 버그를 발견하면 **디버깅(debugging)** 할 시간이다. 프로그램의 소스 코드에 있는 버그 원인을 추적해 제거해야 한다. 디버깅은 프로그래밍의 다른 측면과 마찬가지로 숙달하기 위해 연습이 필요한 기술이다. 그러니 버그를 두려워하지 마라. 그들에게서 배워라. 한 가지 필수적인 디버깅 기술은, 실제로 컴퓨터가 무얼 하는지를 알기 위해 소스 코드를 기계적으로, 단계별로 읽을 수 있는 능력 — 즉 자신이 생각하는 것에 대한 선입견을 제쳐두고 컴퓨터가 하는 방식을 따르는 것 — 이다. 이는 어렵다. 필자는 "i"가 있어야만 하는 자리에, 열 번이나 살펴봤던 코드의 행에 "1"이 있음을 찾는 버그를 보느라 몇 시간을 보냈던 때를 아직도 기억할 수 있다. 또는 컴퓨터가 `windowClosing` (소문자 "w"로 된)을 찾아다녔던 점을 제외하곤 필자가 바랬던 것을 정확히 하였던 `WindowClosing`이란 이름의 서브루틴을 작성했을 때가 그것이다. 때로는 선입견을 공유하지 않는 사람에게 코드를 보게 하는 것이 도움이 될 수도 있다.

종종, 오류가 포함된 프로그램의 부분을 찾는 것만으로도 문제가 된다. 대부분의 프로그래밍 환경에는 버그를 찾는 데 도움을 줄 수 있는 **디버거(debugger)** 가 있다. 일반적으로 프로그램은 디버거의 제어 하에 실행될 수 있다. 디버거를 사용하면 프로그램에서 "중단점(breakpoint)"을 설정할 수 있다. 중단점은 디버거가 프로그램을 일시 중지하여 프로그램 변수의 값을 볼 수 있는 지점이다. 프로그램 실행 과정에서 언제부터 일이 잘못되기 시작했는지 정확히 추적하자는 취지다. 디버거는 또한 한 번에 한 줄씩 프로그램을 실행할 수 있게 하여, 버그가 도사리고 있는 프로그램의 일반 영역을 알게 되면 어떤 일이 벌어지는지 자세히 볼 수 있게 해 줄 것이다.

필자 스스로 디버거를 사용하는 경우는 가끔이라고 고백해야겠다. 디버깅에 대한 더 전통적인 접근법은 프로그램에 디버깅문(debugging statement)을 삽입하는 것이다. 이는 프로그램 상태에 대한 정보를 출력하는 출력문이다. 일반적으로 디버깅문은 다음과 같은 것을 말한다:

```java
System.out.println("At start of while loop, N = " + N);
```

프로그램에서 출력이 어디에서 나오는지 구별할 수 있기를 원하고, 중요한 변수들의 값을 알고 싶어할 것이다. 때때로, 실행될 것이라 생각하였던 프로그램의 일부조차 컴퓨터가 도달하지 못하고 있다는 점을 발견할 것이다. 그 목표는 프로그램에서 해당 상태가 있는 첫 지점을 찾는 것이지, 당신이 있길 바라는 것이 아님을 기억하라. 버그가 있는 곳은 바로 그곳이기 때문이다.

마지막으로, 디버깅의 황금률(golden rule)을 기억하라: 당신의 프로그램의 모든 것이 옳다고 절대적으로 확신한다면, 그리고 여전히 프로그램이 작동하지 않는다면, 절대적으로 확신하는 것 중 하나는 잘못되었다는 것이다.