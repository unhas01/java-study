# 이진 트리(Binary Trees)

우리는 이전  두 섹션에서 객체가 목록에 연결되는 방법을 살펴보았다. 객체에 동일한 유형의 객체에 대한 두 개의 포인터가 포함되어 있으면 연결 목록보다 훨씬 복잡한 구조가 생성될 수 있다. 이 섹션에서는 이 유형의 가장 기본적이고 유용한 구조 중 하나인 이진 트리를 살펴본다. 이진 트리의 각 객체에는 일반적으로 `left` 및 `right` 라는 두 개 포인터가 포함된다. 물론 이러한 포인터 외에도 노드에는 다른 유형의 데이터가 포함될 수 있다.

```java
class TreeNode {
    int item;
    TreeNode left;
    TreeNode right;
}
```

`TreeNode`의 왼쪽 및 오른쪽 포인터는 `null`이거나 `TreeNode` 유형의 다른 객체를 가리킬 수 있다. 다른 노드를 가리키는 노드는 해당 노드의 부모 노드라고 하며, 그것이 가리키는 노드를 자식 노드라고 한다. 이진 트리에서 자식은 "왼쪽 자식" 또는 "오른쪽 자식"이며 노드는 왼쪽 자식이 없더라고 오른쪽 자식을 가질 수 있다. 예를 들어 아래 그림 노드 3은 노드 6의 부모이고 노드 4와 5는 노드 2의 자식이다. 트리 노드로 구성된 모든 연결된 구조가 이진 트리는 아니다. 이진 트리에는 다음 속성이 있어야 한다. 트리에는 부모가 없는 노드가 정확히 하나 있다. 이 노드를 트리의 **루트(root)** 라고 한다. 트리의 다른 모든 노드에는 정확히 하나의 상위 노드가 있다. 마지막으로 이진 트리에는 루프가 있을 수 없다. 즉, 어떤 노드에서 시작하여 동일한 노드로 다시 도착하는 포인터 체인을 따라가는 것은 불가능하다.


![트리 노드](./images/트리%20노드.png)

자식이 없는 노드를 **리프(leaf)** 라고 한다. 리프 노드는 노드의 왼쪽 포인터와 오른쪽 포인터가 모두 `null`이라는 사실로 인식될 수 있다. 이진 트리의 표준 그림에서 루트 노드는 상단에 표시되고 리프 노드는 하단에 표시된다. 이는 실제 트리와의 유사성을 별로 존중하지 않다. 그러나 적어도 이진 트리에 이름을 부여하는 분기형 트리형 구조를 볼 수 있다.

## 1. 트리 순회(Traversal)

이진 트리의 모든 노드를 고려하세요. 해당 노드를 모든 하위 항목(즉, 해당 하위 항목, 하위 항목의 하위 항목 등등)과 함께 살펴본다. 이 노드 집합은 원래 트리의 하위 트리(sub tree)라고 불리는 이진 트리를 형성한다. 예를 들어 그림에서 노드 2, 4, 5는 하위트리를 형성한다. 이 하위 트리를 루트의 왼쪽 하위 트리(left subtree)라고 한다. 마찬가지로 노드 3과 6은 루트의 오른쪽(right subtree)를 구성한다. 비어 있지 않은 이진 트리는 루트 노드, 왼쪽 하위 트리, 오른족 하위 트리로 구성된다고 생각할 수 있다. 하위 트리 중 하나 또는 둘 다 비어있을 수 있다. 이는 클래스 `TreeNode`의 재귀 정의와 일치하는 재귀 정의이다. 따라서 재귀 서브 루틴이 트리를 처리하는 데 자주 사용되는 것은 놀라운 일이 아니다.

이진 트리의 노드 수를 계산하는 문제를 생각해 보자. 연습으로서 계산을 수행하기 위한 비재귀적 알고리즘을 생각해 내려고 시도할 수 있지만 쉽게 찾을 수 있을 것이라고 기대해서는 안된다. 문제의 핵심은 계산할 노드가 남아 있는지 추적하는 것이다. 이를 수행하는 것은 그리 쉽지 않으며 실제로 스택이나 큐와 같은 보조 데이터 구조 없이는 불가능하다. 그러나 재귀를 사용하면 알고리즘이 거의 간단해진다. 트리는 비어 있거나 루트와 두 개의 하위 트리로 구성된다. 트리가 비어 있으면 노드 수는 0이다. (이것이 재귀의 기본 사례이다.) 그렇지 않으면 재귀를 사용하여 각 하위 트리의 노드 수를 계산한다. 하위 트리의 결과를 함께 추가하고 하나를 추가하여 루트를 계산한다. 

```java
/**
 * 루트가 가리키는 이진 트리의 노드 수를 세고,
 * 답변을 반환합니다. 루트가 null이면 대답은 0입니다.
 */
static int countNodes( TreeNode root ) {
    if ( root == null ) {  // 기본 사례: 빈 트리.
        return 0;  // 빈 트리에는 노드가 없습니다.
    }
    else {  // 재귀 사례: 루트 노드와 두 개의 하위 트리.
        int count = 1;  
        count += countNodes(root.left);  // 노드 수를 추가합니다.
                                        // 왼쪽 하위 트리에 있습니다.
        count += countNodes(root.right); // 노드 수를 추가합니다.
                                        // 오른쪽 하위 트리에 있습니다.
        return count;  // Return the total.
    }
}
```

또는 이진 트리의 항목을 인쇄하는 문제를 생각해 보자. 트리가 비어 있으면 아무 것도 할 수 없다. 트리가 비어 있지 않으면 루트와 두 개의 하위 트리로 구성된다. 루트의 항목을 인쇄하고 재귀를 사용하여 하위 트리의 항목을 인쇄한다. 

```java
/**
 * 루트가 가리키는 트리의 모든 항목을 인쇄합니다.
 * 루트에 있는 항목이 먼저 인쇄되고 그 다음에 해당 항목이 인쇄됩니다.
 * 왼쪽 하위 트리의 항목, 그 다음에는 왼쪽 하위 트리의 항목
 * 오른쪽 하위 트리.
 */
static void preorderPrint( TreeNode root ) {
    if ( root != null ) {
        System.out.print( root.item + " " );
        preorderPrint( root.left );
        preorderPrint( root.right );
    }
}
```

이 루틴은 선주문 순회(preorder traversal)을 사용하기 때문에 "preorderPrint"라고 한다. 선주문 순회에서는 트리의 루트 노드를 먼저 처리한 다음 왼쪽 하위 트리를 순회한 다음 오른쪽 하위 트리를 순회한다. 후위 순휘(postorder traversal)에서는 왼쪽 하위 트리를 순회한 다음 오른쪽 하위 트리, 루트 노드를 순회한다. 그리고 중위 순회(inorder traversal)에서는 왼쪽 하위 트리를 먼저 순회하고 루트 노드를 처리한 다음 오른쪽 하위 트리를 순회한다. 트리의 내용을 인쇄하기 위해 후위 및 중위 순회를 사용하는 서브 루틴은 루트 항목을 출력하는 명령문의 배치에서만 `preeorderPrint()`와 다르다.

```java
/**
 * 루트가 가리키는 트리의 모든 항목을 인쇄합니다.
 * 왼쪽 하위 트리의 항목이 먼저 인쇄되고, 그 다음 오른쪽 하위 트리의 항목이 
 * , 루트 노드의 항목 
 * 이 인쇄됩니다.
 */
static void postorderPrint( TreeNode root ) {
    if ( root != null ) {
        postorderPrint( root.left );   // Print items in left subtree.
        postorderPrint( root.right );  // Print items in right subtree.
        System.out.print( root.item + " " );  // Print the root item.
   }
}

/**
 * 루트가 가리키는 트리의 모든 항목을 인쇄합니다.
 * 왼쪽 하위 트리의 항목이 먼저 인쇄되고, 
 * 루트 노드의 항목이 *, 오른쪽 하위 트리의 항목 
 * 이 인쇄 됩니다.
 */
static void inorderPrint( TreeNode root ) {
    if ( root != null ) {
        inorderPrint( root.left );   // Print items in left subtree.
        System.out.print( root.item + " " );  // Print the root item.
        inorderPrint( root.right );  // Print items in right subtree.
    }
}
```

이러한 각 서브 루틴은 이 섹션 시작 부분의 그림에 표시된 이진 트리에 적용될 수 있다. 항목이 인쇄되는 순서는 각 경우에 따라 다르다.

```
preorderPrint outputs:   1  2  4  5  3  6

postorderPrint outputs:  4  5  2  6  3  1

inorderPrint outputs:    4  2  5  1  3  6
```

예를 들어, `preorderPrint`에서는 트리 루트에 있는 항목인 1이 다른 것보다 먼저 출력된다. 그러나 전위 인쇄는 루트의 각 하위 트리에도 적용된다. 왼쪽 하위 트리의 루트 항목인 2는 해당 하위 트리인 4 및 5의 다른 항목보다 먼저 인쇄된다. 루트의 오른쪽 하위 트리에서는 6보다 먼저 3이 출력된다. 전위 순회는 트리의 모든 수준에 적용된다. 다른 두 가지 순회 순서도 비슷하게 분석할 수 있다.

## 2. 이진 정렬 트리

섹션 9.2의 예 중 하나, 문자열의 연결 목록으로 문자열이 오름차순으로 유지된다. 연결된 목록은 소수의 문자열에는 잘 작동하지만 항목 수가 많으면 비효율적이다. 목록에 항목을 삽입할 때 해당 항목의 위치를 검색하려면 평균적으로 목록에 있는 항목의 절반을 살펴봐야 한다. 목록에서 항목을 찾는 데도 비슷한 시간이 필요하다. 문자열이 연결 목록 대신 정렬된 배열에 저장되면 이진 검색을 사용할 수 있으므로 검색이 더 효율적이 된다. 그러나 배열에 새 항목을 삽입하는 것은 새 항목을 위한 공간을 만들기 위해 평균적으로 배열 항목의 절반을 이동하는 것을 의미하므로 여전히 비효율적이다. 이진 트리는 검색과 삽입을 모두 효율적으로 수행하는 방식으로 정렬된 목록을 저장하는 데 사용할 수 있다. 이진 정렬 트리 또는 BST 같은 방식이다.

이진 정렬 트리는 다음 속성을 가진 이진 트리이다. 트리의 모든 노드에 대해 해당 노드의 항목은 해당 노드의 왼쪽 하위 트리에 있는 모든 항목보다 크거나 같고 모든 항목보다 작거나 같다. 해당 노드의 오른쪽 하위 트리에 있는 항목이다. 예를 들어 String 유형의 항목을 포함하는 이진 정렬 트리가. 있다. (이 그림에서 포인터 변수를 일일이 그러지 ㅇ낳았다. `null`이 아닌 포인터는 화살표로 표시된다.)

![이진 정렬 트리](./images/이진%20정렬%20트리.png)

이진 정렬 트리에는 다음과 같은 유용한 속성이 있다. 트리를 중위 순회하면 항목이 오름차순으로 처리된다. 사실 이것은 정의를 표현하는 또 다른 방법일 뿐이다. 예를 들어, 위에 표시된 트리의 항목을 인쇄하기 위해 중위 순회를 하는 경우 항목은 알파벳순으로 표시된다. 중위 순회 정의는 "judy"의 왼쪽 하위 트리에 있는 모든 항목이 "judy" 앞에 인쇄되고 "judy"의 오른쪽 하위 트리에 있는 모든 항목이 "judy" 뒤에 인쇄되도록 보장한다. 그러나 이진 정렬 트리 속성은 "judy"의 왼쪽 하위 트리에 있는 항목이 정확히 알파벳 순서로 "judy"앞에 오는 항목이고 오른쪽 하위 트리에 있는 모든 항목이 알파벳 순서로 "judy" 뒤에 오도록 보장한다. 그래서 우리는 "judy"가 올바른 알파벳 위치로 출력된다는 것을 알고 있다. 그러나 동일한 주장이 하위 트리에도 적용된다. "Bill"은 "alice" 뒤, "fred" 및 그 하위 항목 앞에 출력된다.

이진 검색 트리에서 주어진 항목을 검색한다고 가정해 본다. 해당 항목을 트리의 루트 항목과 비교한다. 만약 그들이 같다면, 우리는 끝났다. 찾고 있는 항목이 루트 항목 보다 작으면 루트의 왼쪽 하위 트리를 검색해야 한다. 오른쪽 하위 트리에 루트보다 크거나 같은 항목만 포함되어 있으므로 제거될 수 있다. 마찬가지로 우리가 찾고 있는 항목이 루트에 있는 항목보다 크면 오른쪽 하위 트리만 보면 된다. 두 경우 모두 동일한 절차를 적용하여 하위 트리를 검색할 수 있다. 새 항목을 삽입하는 것도 비슷하다. 새 항목이 속한 위치를 트리에서 검색하는 것부터 시작하다. 해당 위치를 찾으면 새 노드를 생성하고 해당 위치의 트리에 연결한다.

트리가 균형을 이루고 있는 경우 검색 및 삽입은 이진 검색 트리에서 효율적인 작업이다. 각 노드에 대해 해당 노드의 왼쪽 하위 트리에 오른쪽 하위 트리와 대략 동일한 수의 노드가 포함되어 있으면 이진 트리가 균형을 이루고 있다. 완벽하게 균형 잡힌 트리에서 두 숫자는 최대 1만큼 다르다. 모든 이진 트리가 균형을 이루고 있는 것은 아니지만, 임의의 순서로 항목을 삽입하여 생성한 경우 트리가 거의 균형을 이루고 있을 확률이 높다. (그러나 삽입 순서가 무작위가 아닌 경우 트릐가 매우 불균형할 가능성이 높다.) 이는 정렬 트리가 검색하는 동안 모든 비교는 추가 고려 사항에서 두 하위 트리 중 하나를 제거한다. 트리가 균형을 이룬다면 아직 고려 중인 항목 수가 절반으로 줄어드는 것을 의미한다. 이는 이진 검색 알고리즘과 정확히 동일하며 결과는 비슷하게 효율적인 알고리즘이다.

점근적 분석 측면에서, 이진 검색 트리에서 검색, 삽입 및 삭제는 평균 실행 시간 Θ(log(n))을 갖는다. 문제 크기 n은 트리에 있는 항목 수이며, 항목이 트리에 삽입될 수 있는 모든 다른 순서에 대한 평균이다. 실제 삽입 순서가 무작위인 한, 실제 실행 시간은 평균에 가까울 것으로 예상할 수 있다. 그러나 이진 검색 트리 작업의 최악의 런타임은 Θ(n)이며 이는 Θ(log(n))보다 훨씬 나쁘다. 최악의 경우는 특정 신청에 발생한다. 예를 들어 항목이 크기가 증가하는 순서대로 트리에 삽입되면 삽입된 모든 항목은 트리 아래에 이동할 때 항상 오른쪽으로 이동한다. 결과는 `right` 자식 포인터로 연결된 노드의 선형 문자열로 구성되어 있기 때문에 링크된 목록처럼 보이는 "트리"이다. 이러한 트리에 대한 작업은 연결된 목록에 대한 작업과 동일한 성능을 갖는다. 이제 노드 삽입 및 삭제가 항상 트리의 균형을 유지하거나 거의 균형을 이루는 방식으로 구현된다는 점을 제외하면 간단한 이진 정렬 트리와 유사한 데이터 구조가 있다. 이러한 데이터 구조의 경우 검색, 삽입 및 삭제에는 평균 사례 실행 시간과 최악 사례 실행 시간이 모두 Θ(log(n))이다. 그러나 여기서는 삽입과 검색의 간단한 버전만 살펴본다.

샘플 프로그램 [SortTreeDemo.java](https://math.hws.edu/javanotes/source/chapter9/SortTreeDemo.java)는 이진 정렬 트리의 데모이다. 프로그램에는 중위 순회, 검색 및 삽입을 구현하는 서브 루틴이 포함되어 있다. 

SortTreeDemo에서 이진 트리의 노드는 노드를 더 쉽게 생성할 수 있도록 하는 간단한 생성자를 포함하는 다음과 같은 정적 중첩 클래스를 사용하여 표현된다.

```java
/**
 * TreeNode 유형의 객체는 문자열의 이진 트리에서 하나의 노드를 나타냅니다.
 */
private static class TreeNode { 
    String item;
    TreeNode left;
    TreeNode right;
    TreeNode(String str) {
        item = str;
    }
}
```

TreeNode 유형의 정적 멤버 변수는 프로그램에서 사용되는 이진 정렬 트리를 가리킨다.

```java
private static TreeNode root;
```

`treeContains`라는 재귀 서브 루틴은 트리에서 특정 항목을 검색하는 데 사용된다. 이 루틴은 위에 설명된 이진 트리에 대한 검색 알고리즘을 구현한다.

```java
/**
 * 항목이 바이너리의 항목 중 하나이면 true를 반환합니다.
 * 루트가 가리키는 트리를 정렬합니다. 그렇지 않은 경우 false를 반환합니다.
 */
static boolean treeContains( TreeNode root, String item ) {
    if ( root == null ) {
        // 트리는 비어 있으므로 확실히 항목을 포함하지 않습니다.
        return false;
    }
    else if ( item.equals(root.item) ) {
        // 예, 루트 노드에서 항목을 찾았습니다.
        return true;
    }
    else if ( item.compareTo(root.item) < 0 ) {
        // 항목이 발생하면 왼쪽 하위 트리에 있어야 합니다.
        return treeContains( root.left, item );
    }
    else {
        // 항목이 발생하면 오른쪽 하위 트리에 있어야 합니다.
        return treeContains( root.right, item );
    }
}
```

이 루틴이 `main()` 루틴에서 호출될 때 첫 번째 매개변수는 전체 이진 정렬 트리의 루트를 가리키는 정적 멤버 변수 `root`이다.

이 경우 재귀가 실제로 필수적인 것은 아니라는 점은 주목할 가치가 있다. 이진 정렬 트리를 검색하기 위한 간단한 비재귀 알고리즘은 다음과 같은 규칙을 따른다. 루트에서 시작하여 항목을 찾거나 널포인터에 도달할 때까지 트리 아래로 이동한다. 검색은 트리 아래의 단일 경로를 따르기 때문에 `while` 루프로 구현될 수 있다. 다음은 비재귀 버전이다.

```java
private static boolean treeContainsNR( TreeNode root, String item ) {
    TreeNode runner;  // 트리 아래로 "실행"합니다.
    runner = root;    // 루트 노드에서 시작합니다.
    while (true) {
        if (runner == null) {
        // 아이템을 찾지 못한 채 나무에서 떨어졌습니다.
            return false;
        }
        else if ( item.equals(runner.item) ) {
            // 아이템을 찾았습니다.
            return true;
        }
        else if ( item.compareTo(runner.item) < 0 ) {
            // 항목이 발생하면 왼쪽 하위 트리에 있어야 합니다.
            // 따라서 러너를 왼쪽으로 한 레벨 아래로 전진시킵니다.
            runner = runner.left;
        }
        else {
            // 항목이 발생하면 오른쪽 하위 트리에 있어야 합니다.
            // 따라서 러너를 오른쪽으로 한 레벨 아래로 전진시킵니다.
            runner = runner.right;
        }
    }  
}
```

트리에 새 항목을 삽입하는 서브 루틴은 재귀 검색 루틴보다는 비재귀 검색 루틴과 더 유사한 것으로 나타난다. 삽입 루틴은 트리가 비어 있는 경우를 처리해야 한다. 이 경우 새 항목이 포함된 노드를 가리키도록 `root` 값을 변경해야 한다.

```java
root = new TreeNode(newItem);
```

그러나 이는 사실상 서브 루틴이 실제 매개 변수에 저장된 값을 변경하는 것이 불가능하기 때문에 루트를 서브 루틴에 매개 변수로 전달할 수 없음을 의미한다. 재귀에서는 매개 변수를 필수적인 방식으로 사용한다. 문제를 해결하는 추악한 방법이 있지만 가장 쉬운 방법은 정적 멤버 변수 `root`에 직접 엑세스하는 비재귀 삽입 루틴을 사용하는 것이다. 항목 삽입과 항목 검색의 한 가지 차이점은 나무에서 떨어지지 않도록 조심해야 한다는 것이다. 즉, `runner`가 `null`이 되기 직전에 검색을 중지해야 한다.

```java
/**
 * 전역 변수가 있는 이진 정렬 트리에 항목을 추가합니다.
 * "루트"를 의미합니다. (루트는 매개변수로 전달될 수 없습니다.
 * 루트의 값이 변경될 수 있고 변경 사항이 발생할 수 있으므로 이 루틴은
 * 형식 매개변수 값은 실제 매개변수를 변경하지 않습니다.)
 */
private static void treeInsert(String newItem) {
    if ( root == null ) {
        // 트리가 비어 있습니다. 다음을 포함하는 새 노드를 가리키도록 루트를 설정합니다.
        // 새 항목입니다. 이것이 트리의 유일한 노드가 됩니다.
        root = new TreeNode( newItem );
        return;
    }
    TreeNode runner;  // newItem을 위한 장소를 찾기 위해 트리를 따라 실행합니다.
    runner = root;   // 루트에서 시작합니다.
    while (true) {
        if ( newItem.compareTo(runner.item) < 0 ) {
            // 새 항목이 러너의 항목보다 작으므로,
            // 러너의 왼쪽 하위 트리에 속합니다. 만약 거기에
            //는runner.left에 열린 공간입니다. 거기에 새 노드를 추가합니다.
            // 그렇지 않으면 러너를 왼쪽으로 한 레벨 아래로 전진시킵니다.
            if ( runner.left == null ) {
                runner.left = new TreeNode( newItem );
                return;  // 트리에 새 항목이 추가되었습니다.
            }
            else
                runner = runner.left;
        }
        else {
            // 새 항목이 이전 항목보다 크거나 같기 때문에
            // 러너, 러너의 오른쪽 하위 트리에 속합니다. 만약 거기에
            //는runner.right의 열린 공간입니다. 거기에 새 노드를 추가합니다.
            // 그렇지 않으면 러너를 오른쪽으로 한 레벨 아래로 전진시킵니다.
            if ( runner.right == null ) {
                runner.right = new TreeNode( newItem );
                return;  // 트리에 새 항목이 추가되었습니다.
            }
            else
                runner = runner.right;
        }
    } 
}
```

## 3. 표현식 트리

트리의 또 다른 적용은 15*(x+y) 또는 sqrt(42)+7과 같은 수학적 표현식을 편리한 형식으로 저장하는 것이다. 잠시 동안 숫자와 연산자 +, -, *, /로 구성된 표현식을 살펴본다. 3*((7+1)/4)+(17-5) 표현식을 고려하자. 이 표현식은 연산자 " + "와 결합된 두 개의 하위 표현식 3*((7+1)/4) 및 (17-5)로 구성된다. 식을 이진 트리로 표현하면 루트 노드는 연산자 +를 유지하고 루트 노드의 하위 트리는 하위 식 3*(7+1)/4) 및 (17-5)를 나타낸다. 트리의 모든 노드는 숫자나 연산자를 보유한다. 숫자를 보유하는 노드는 트리의 리프 노드이다. 연산자를 보유하는 노드에는 연산자가 적용되는 피연산자를 나타내는 두 개의 하위 트리가 있다. 아래 그림에 트리가 있다. 이 유형의 트리를 표현식 트리(expression tree)라고 한다. 

표현식 트리가 주어지면 그것이 나타내는 표현식의 값을 쉽게 찾을 수 있다. 트리의 각 노드에는 연관된 값이 있다. 노드가 리프 노드인 경우 해당 값은 단순히 노드에 포함된 숫자이다. 노드에 연산자가 포함된 경우 먼저 하위 노드의 값을 찾은 다음 해당 값에 연산자를 적용하여 관련 값을 계산한다. 프로세스는 그림에서 위쪽 화살표로 표시된다. 루트 노드에 대해 계산된 값은 표현식 전체의 값이다. 표현식 트리에는 다른 용도도 있다. 예를 들어, 트리의 후위 순회는 표현식의 후위 형식을 출력한다.

![표현식 트리](./images/표현식%20트리.png)

식 트리에는 숫자가 포함된 노드와 연산자가 포함된 노드라는 두 가지 유형의 노드가 포함되어 있다. 또한 변수를 포함하는 노드와 같이 트리를 더욱 유용하게 만들기 위해 다른 유형의 노드를 추가할 수도 있다. Java에서 표현식 트리를 사용하여 작업하려는 경우 이러한 다양한 노드를 어떻게 처리할 수 있나? 객체 지향 순수주의자들이 눈살을 찌푸리게 될 한 가지 방법은 각 노드 객체에 인스턴스 변수를 포함하여 노드 유형을 기록하는 것이다.

```java
enum NodeType { NUMBER, OPERATOR }   
   
class ExpNode {  
    
    NodeType kind;
    double number;
    char op;       
    ExpNode left;  
    ExpNode right; 
    
    ExpNode( double val ) {
        kind = NodeType.NUMBER;
        number = val;
    }
 
    ExpNode( char op, ExpNode left, ExpNode right ) {
        kind = NodeType.OPERATOR;
        this.op = op;
        this.left = left;
        this.right = right;
    }
}
```

이 정의가 주어지면 다음 재귀 서브루틴은 표현식 트리의 값을 찾는다.

```java
static double getValue( ExpNode node ) {
    // 표현된 표현식의 값을 반환합니다.
    // 노드가 참조하는 트리입니다. 노드는 null이 아니어야 합니다.
        
    if ( node.kind == NodeType.NUMBER ) {
        // NUMBER 노드의 값은 노드가 보유하는 숫자입니다.
        return node.number;
    }
    else {  // The kind must be OPERATOR.
        // 피연산자의 값을 가져와서 결합합니다.
        // 연산자를 사용합니다.
        double leftVal = getValue( node.left );
        double rightVal = getValue( node.right );
        switch ( node.op ) {
            case '+':  return leftVal + rightVal;
            case '-':  return leftVal - rightVal;
            case '*':  return leftVal * rightVal;
            case '/':  return leftVal / rightVal;
            default:   return Double.NaN;  // Bad operator.
        }
    }
}
```

이 접근 방식은 효과가 있지만 보다 객체 지향적인 접근 방식은 두 가지 유형의 노드가 있으므로 이를 나타내는 두 개의 클래스 (ConstNode, BinOpNode)가 있어야 한다는 점에 유의하는 것이다. 표현식 트리에서 노드의 일반적인 개념을 표현하려면 ExpNode라는 또 다른 클래스가 필요하다. ConstNode와 BipOpNode는 모두 ExpNode의 하위 클래스이다. 실제 노드는 ConstNode 또는 BinOpNode이므로 ExpNode는 추상 클래스여야 한다. 노드로 수행하려는 작업 중 하나는 해당 값을 찾는 것이므로 각 클래스에는 값을 찾기 위한 인스턴스 메서드가 있어야 한다.

```java
abstract class ExpNode {
    // 표현식 트리에 있는 모든 유형의 노드를 나타냅니다.
    abstract double value(); // 이 노드의 값을 반환합니다.
}

class ConstNode extends ExpNode {
    // 숫자를 보유하는 노드를 나타냅니다.
    double number;  // 노드의 번호입니다.

    ConstNode( double val ) {
        // 생성자. Val을 보유할 노드를 만듭니다.
        number = val;
    }

    double value() {
        // 값은 노드가 보유하고 있는 숫자일 뿐입니다.
        return number;
    }

}

class BinOpNode extends ExpNode {
    // 연산자를 보유하는 노드를 나타냅니다.

    char op;        // 연산자.
    ExpNode left;   // 왼쪽 피연산자.
    ExpNode right;  // 오른쪽 피연산자.

    BinOpNode( char op, ExpNode left, ExpNode right ) {
        // 생성자. 주어진 데이터를 보관할 노드를 만듭니다.
        this.op = op;
        this.left = left;
        this.right = right;
    }

    double value() {
        // 값을 얻으려면 왼쪽과 오른쪽의 값을 계산합니다.
        // 오른쪽 피연산자를 선택하고 연산자와 결합합니다.
        double leftVal = left.value();
        double rightVal = right.value();
        switch ( op ) {
            case '+':  return leftVal + rightVal;
            case '-':  return leftVal - rightVal;
            case '*':  return leftVal * rightVal;
            case '/':  return leftVal / rightVal;
            default:   return Double.NaN;  // Bad operator.
        }
    }

}
```

BinOpNode의 왼쪽 및 오른쪽 피연산자는 BipOpNode가 아닌 ExpNode 유형이다. 이를 통해 피연산자는 ConstNode 또는 다른 BinOpNode 또는 최종적으로 생성할 수 있는 다른 유형의 ExpNode가 될 수 있다. 모든 ExpNode에는 `value()` 메서드가 있으므로 `left.value()`를 호출하여 왼쪽 피연산자의 값을 계산할 수 있다. `left`가 실제로 ConstNode인 경우 ConstNode 클래스의 `value()` 메서드가 필요하다. 실제로 BinOpNode이면 `left.value()`는 BinOpNode 클래스의 `value()` 메서드를 호출한다. 각 노드는 자신의 값을 계산하는 방법을 알고 있다.

처음에는 더 복잡해 보일 수도 있지만 객체 지향 접근 방식에는 몇 가지 실질적인 장점이 있다. 우선 메모리를 낭비하지 않는다. 원래 ExpNode 클래스에는 각 노드의 인스턴스 변수 중 일부만 실제로 사용되었으며 노드 유형을 추적하려면 추가 인스턴스 변수가 필요했다. 그러나 더 중요한 것은 기존 클래스를 수정하는 대신 ExpNode의 새 하위 클래스를 생성하여 수행할 수 있기 때문에 새로운 유형의 노드를 보다 깔끔하게 추가할 수 있다는 사실이다.










