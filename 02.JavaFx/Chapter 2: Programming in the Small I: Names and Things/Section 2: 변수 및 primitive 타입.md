# Section 2: 변수 및 primitive 타입

이름은 프로그래밍의 기초 이다. 프로그램에서 이름은 많은 다른 종류의 것들을 가리키는 데 사용된다. 이러한 것들을 사용하기 위해서, 프로그래머는 그들에게 이름을 부여하는 규칙과 이들을 다루기 위해 이름을 사용하는 규칙을 이해해야 한다. 즉, 프로그래머는 이름에 대한 구문과 의미론을 이해해야 한다.

자바의 구문 규칙에 따르면 가장 기본적인 이름은 식별자(identifier)다. 식별자를 사용하여 클래스, 변수 및 서브루틴의 이름을 지정할 수 있다. 식별자는 하나 또는 그 이상의 문자의 배열이다. 문자 또는 밑줄로 시작해야 하며, 문자, 숫자 및 밑줄로 전적으로 구성되어야 한다. ("밑줄(Underscore)"는 문자 '_'를 가리킨다.) 예를 들어 다음과 같은 몇 가지 허용되는 식별자가 있다.

`N n rate x15 quite_a_long_name HelloWorld`

식별자에는 띄어쓰기(space)가 허용되지 않는다; `HelloWorld`는 허용된 식별자지만 "Hello World"는 그렇지 않다. 대문자와 소문자가 다른 것으로 간주되기에 `HelloWorld`, `helloworld`, `HELLOWORLD`, 그리고 `hElloWorLD`는 모두 별개의 이름이다. 어떤 단어들은 자바에서 특별한 용도를 위해 예약되어 있으며, 식별자로 사용할 수 없다. 이러한 **예약어(reserved words)** 에는 `class`, `public`, `static`, `if`, `else`, `while`, 그리고 수십 개의 다른 단어들이 포함된다. (예약어는 사물의 이름으로 사용할 수 없으므로 식별자가 아님을 기억하라.)

자바는 실제로 글자 또는 숫자로 취급되는 것들에 대해 꽤나 자유분방하다. 자바에서는 유니코드 문자 집합을 사용하는데, 유니코드 문자 집합에는 여러 다른 언어와 알파벳에서 나온 수천 개의 문자를 포함하며, 이들 문자 중 많은 수가 문자나 숫자로 취급된다. 하지만, 나는 일반적인 영어 키보드로 타이핑할 수 있는 것을 고수할 것이다.

이름짓기에 관한 실용주의는 사물의 이름을 선택하는 방법에 대한 스타일 지침이 포함되어 있다. 예를 들어, 변수의 이름과 서브루틴의 이름은 소문자로 시작하는 반면, 클래스의 이름은 대문자로 시작하는 것이 관례이다; 자신의 프로그램에서 이 표준 규약을 따름으로써 많은 혼란을 피할 수 있다. 대부분의 자바 프로그래머들은 이름에 밑줄을 사용하지 않지만, 어떤 사람들은 특정한 종류의 변수의 이름의 시작 부분에 밑줄을 사용한다. 이름이 `HelloWorld`나 `interestRate`과 같은 여러 단어로 이루어져 있을 때에는, 첫 번째 단어를 제외한 각 단어를 대문자로 시작하는 것이 관례이다; 이것은 때때로 이름 가운데에 있는 대문자가 낙타 등에 있는 혹처럼 보이게 하기 때문에 **낙타 케이스(camel case)** 라고 언급된다.

마지막으로, 자바에 있는 사물들은 단순한 식별자 외에도, 마침표(periods)로 구분되고 여러 개의 단순한 이름으로 이루어진 **복합 이름(compound name)** 을 가질 수 있다는 것을 언급하고자 한다. (복합 이름은 **정규화된 이름(qualified name)** 이라고도 한다.) 당신은 이미 예시를 접했다: `System.out.println`. 여기서의 개념은 자바에 있는 것들은 다른 것들을 포함할 수 있다는 것이다. 복합 이름은 하나 또는 그 이상의 봉쇄 단계를 통과하는 한 항목으로 이어진 경로의 일종이다. `System.out.println`이라는 이름은 "System"이라고 불리는 무언가가 "out"이라고 불리는 것을 포함하고 있고, 다시 "println"이라고 불리는 것을 포함하고 있다는 것을 나타낸다.

## 1. 변수

프로그램은 메모리에 저장된 데이터를 조작한다. 기계 언어에서 데이터는 데이터가 저장된 메모리 위치의 숫자로 나타낸 주소를 부여해야만 참조할 수 있다. 자바와 같은 고급 언어에서는 데이터를 참조하기 위해 숫자 대신 이름을 사용한다. 데이터가 실제로 저장된 위치를 추적하는 것은 컴퓨터의 일이다; 프로그래머는 이름만 기억하면 된다. 이런 방식으로 사용되는 이름 — 메모리에 저장된 데이터를 참조하기 위한 — 을 **변수(variable)** 라고 한다.

변수는 사실 다소 미묘하다. 적절하게 말하면, 변수는 데이터 자체에 대한 이름이 아니라 데이터를 저장할 수 있는 메모리의 위치에 대한 이름이다. 변수를 나중에 사용해야 할 데이터를 저장할 수 있는 용기 또는 상자로 생각해야 한다. 변수는 상자를 직접적으로 가리키며 상자의 데이터는 간접적으로만 가리킨다. 상자 안의 데이터는 변할 수 있기 때문에 변수는 프로그램 실행 중 서로 다른 시간대에서 다른 데이터 값을 가리킬 수 있지만, 언제나 같은 상자를 가리킨다. 특히 초보 프로그래머에게 혼란이 발생할 수 있는데, 왜냐하면 변수가 프로그램에서 특정 방식으로 사용될 때는 상자를 참조하지만, 다른 방식으로 사용될 때는 상자에 있는 데이터를 참조하기 때문이다. 아래에서 두 가지 사례 모두를 볼 것이다.

자바에서 변수에 데이터를 들이는 — 즉, 변수 이름의 상자에 넣는 — 유일한 방법은 **할당문(assignment statement)** 을 사용하는 것이다. 할당문은 다음과 같은 형식을 취한다.

`variable = expression;`

여기서 expression은 데이터 값을 참조하거나 계산하는 모든 것을 나타낸다. 프로그램을 실행하는 과정에서 컴퓨터가 할당문에 도달하면 식을 평가하고 그 결과 데이터 값을 변수에 넣는다. 예를 들어, 다음의 간단한 할당문을 생각해보자.

`rate = 0.07;`

이 할당문에서 variable은 `rate`이며, expression은 숫자 0.07이다. 컴퓨터는 숫자 0.07을 변수 rate에 넣으면서 이전에 그것에 있었던 것이 무엇이든 이를 대체함으로써 해당 할당문을 실행한다. 이제 동일한 프로그램에서 이후에 나올 법한 다음과 같은 복잡한 할당문을 생각해보자:

`interest = rate * principal;`

여기서, "`rate * principal`"이라는 표현식의 값이 변수 `interest`에 할당되고 있다. 표현식에서 는 "곱셈 연산자(multiplication operator)"로, 컴퓨터에게 `rate`와 `principal`을 곱하라고 지시한다. `rate`와 `principal`은 그 자체로 변수인데, 실제로는 그 변수들에 저장된 값들이 곱해지는 것이다. 표현식에 변수를 사용할 때 중요한 것은 변수에 저장된 값이라는 것이다; 이 경우 변수는 상자 자체보다는 상자의 데이터를 참조하는 것처럼 보인다. 컴퓨터가 이 할당문를 실행하면 `rate`의 값을 취하여 `principal`의 값과 곱하고, `interest`에 의해 참조되는 상자에 답을 저장한다. 할당문에서 왼쪽에 변수를 사용할 경우, 이는 변수에 의해 이름이 지정된 상자를 가리킨다.

(그런데, 할당문은 특정 시간에 컴퓨터가 실행하는 명령이라는 점에 유의하라. 그것은 진실의 문장이 아니다. 예를 들어 프로그램에 "`rate = 0.07;`"이라는 문장이 포함되어 있다고 가정하자. 프로그램 후반부에 "`interest = rate * principal;`"이라는 문장이 실행된다면, `principal`에 0.07을 곱한다고 말할 수 있는가? 아니다! 그 사이에 다른 문장에 의해 `rate`의 값이 바뀌었을지도 모른다. 할당문의 의미는, 둘 다 기호 "="를 사용함에도 불구하고 수학에서 방정식의 의미와는 완전히 다르다.

<hr>

## 2. 자료형
자바의 변수는 오직 하나이자 특정한 자료형의 데이터만을 보유하도록 설계되었다; 그것은 그러한 허용된 자료형의 데이터를 보유할 수 있고 다른 것은 보유할 수 없다. 잘못된 자료형의 값을 변수에 할당하여 이 규칙을 위반하려고 할 경우 컴파일러는 이를 구문 오류로 간주할 것이다. 우리는 자바가 이 규칙을 강제하기 때문에 **엄격한 형태의(strongly typed)** 언어라고 말한다.

자바에는 소위 8개의 **원시 자료형(primitive type)** 이 내장되어 있다. 원시 자료형은 byte, short, int, long, float, double, char, 그리고 boolean이라고 명명된다. 처음 네 가지 자료형은 정수(17, -38477, 그리고 0과 같은 수)를 보유한다. 네 가지 정수 자료형은 보유할 수 있는 정수 범위에 의해 구별된다. float와 double 자료형은 실수 (3.6 및 -145.99과 같은 수)를 보유한다. 다시 말하지만, 실제의 두 자료형은 그 범위와 정확도로 구별된다. char 자료형의 변수는 유니코드 문자 집합의 단일 문자를 보유한다. 그리고 boolean 자료형의 변수는 두 개의 논리적 값인 `true` 또는 `false` 중 하나를 보유한다.

컴퓨터의 메모리에 저장된 모든 데이터 값은 0과 1의 문자열인 이진수로 표시되어야 한다. 하나의 0 또는 1을 **비트(bit)** 라고 한다. 8비트의 나열을 **바이트(byte)** 라고 한다. 메모리는 보통 바이트 단위로 측정된다. 당연히 바이트 데이터 자료형은 메모리의 단일 바이트를 가리킨다. byte 자료형의 변수는 -128과 127 사이의 정수 중 하나를 나타낼 수 있는 8비트의 나열을 보유한다. (이 범위에는 256개의 정수가 있다; 8비트는 256 — 2의 8승 — 개의 다른 값들을 표현할 수 있다.) 다른 정수 자료형에 대해서는,

- short은 2바이트(16비트)에 해당한다. short 자료형의 변수는 -32768 ~ 32767 범위의 값을 갖는다.
- int는 4바이트(32비트)에 해당한다. int 자료형의 변수는 -2147483648 ~ 2147483647 범위의 값을 갖는다.
- long는 8바이트(64비트)에 해당한다. long 자료형의 변수는 -922337203685475808 ~ 922337203685475807 범위의 값을 갖는다.

이 숫자들을 기억할 필요는 없지만, 이들은 다룰 수 있는 정수들의 크기를 대강 알려준다. 일반적으로는, 정수 데이터를 나타내려면 int 데이터 자료형을 고수해야 하며, 이는 대부분의 목적에 잘 부합한다.

float 데이터 자료형은 실수를 인코딩하는 표준 방법을 사용하여 4바이트의 메모리로 표현된다. float의 최대값은 대략 10의 38승 정도의 값이다. float는 약 7개의 유의미한 자릿수를 가질 수 있다. (따라서 32.3989231134와 32.3989234399 둘 다 float 자료형의 변수에 저장되기 위해서는 약 32.398923으로 반올림해야 한다.) double은 8바이트를 차지하며, 대략 10의 308승까지의 범위에 있으며, 약 15개의 유의미한 자릿수를 가지고 있다. 일반적으로는 실제의 값에 대하여 double 자료형을 고수해야 한다.

char 자료형의 변수는 메모리에서 2바이트를 차지한다. char 변수의 값은 A, *, x 또는 공백 문자와 같은 단일 문자다. 이 값은 탭(tab)이나 캐리지 리턴(carriage return)과 같은 특수 문자 또는 다른 언어에서 온 많은 유니코드 문자 중 하나일 수도 있다. 문자는 실제로 16비트 정수 코드 번호로 저장되기 때문에, char 자료형의 값들은 정수 값들과 밀접한 관련이 있다. 사실, 우리는 자바의 chars가 실제로 특정한 상황에서 정수처럼 사용될 수 있다는 것을 살펴볼 것이다.

원시 자료형의 값은 특정되고 한정된 비트 수만을 사용하여 표현된다는 점을 기억해야 한다. 따라서, int는 임의의 정수일 수 없다; 이는 특정의 한정된 범위 내에서만의 정수일 수 있다. 마찬가지로 float와 double 변수는 특정 값만 취할 수 있다. 그것들은 수학적 의미에서 진정한 실수가 아니다. 예를 들어, 수학 상수 π은 그것을 정확히 나타내기 위해서는 무한히 많은 소수 자릿수가 필요하기 때문에, float 또는 double 자료형의 값으로 근사치를 구할 수 있을 뿐이다. 그 점에 있어서, 1/3과 같은 많은 단순한 숫자들도 float와 double에 의해서만 근사치를 낼 수 있다.

<hr>

## 3. 리터럴
데이터 값은 비트들의 연속으로 컴퓨터에 저장된다. 컴퓨터의 메모리에서, 이 페이지에 쓰여진 값과 같은 것은 아무것도 보이지 않는다. 당신이 쓰는 프로그램에 상수 값을 포함시키는 방법이 필요하다. 프로그램에서 상수 값은 리터럴(literal)로 나타낸다. 리터럴은 값을 나타내기 위해 프로그램에 입력할 수 있는 것이다. 이는 상수 값에 대한 이름의 일종이다.

예를 들어 프로그램에서 char 자료형의 값을 입력하려면, 'A', '*' 또는 'x'와 같은 단일 인용 부호로 해당 문자를 둘러싸야 한다. 문자와 인용 부호는 자료형 char의 리터럴을 구성한다. 따옴표가 없다면 A는 식별자일 것이고 *는 곱셈 연산자가 될 것이다. **따옴표는 값의 일부가 아니며** 변수에 저장되지 않는다; 따옴표는 프로그램에서 특정한 문자 상수의 이름을 지정하는 데 사용되는 관례일 뿐이다. char 자료형 변수 `ch`에 문자 A를 저장하고 싶다면 할당문으로 이를 할 수 있다.

`ch = 'A';`

어떤 특수 문자는 백슬래시 \를 "탈출 문자(escape character)"로 사용하는 특수한 리터럴을 가지고 있다. 특히 탭은 '\t'로, 캐리지 리턴은 '\r'로, 라인피드(linefeed)는 '\n'으로, 단일 인용문자는 '\''로, 백슬래시 자체는 '\'로 표현된다. '\t'의 따옴표 사이에 두 문자를 입력하더라도 이 리터럴로 표시되는 값은 단일 탭 문자라는 점에 유의하라.

숫자 리터럴은 당신이 예상하는 것보다 조금 더 복잡하다. 물론 317과 17.42와 같은 명백한 리터럴도 있다. 그러나 자바 프로그램에서 숫자를 표현할 수 있는 다른 가능성도 있다. 우선 실수는 1.3e12 또는 12.3737e-108과 같은 지수의(exponential) 형태로 나타낼 수 있다. "e12"와 "e-108"은 10의 승수를 나타내므로 1.3e12는 1.3에 10의 12승을 곱한 것을 의미하고 12.3737e-108은 12.3737에 10의 -108승을 곱한 것을 의미한다. 이 형식은 매우 큰, 그리고 매우 작은 숫자를 표현하는 데 사용될 수 있다. 소수점 또는 지수점을 포함하는 모든 숫자 리터럴은 double 자료형의 리터럴이다. float 자료형의 리터럴을 만들려면 숫자 끝에 'F'나 'f'를 추가해야 한다. 예를 들어 "1.2F"는 float 자료형의 값으로 간주되는 1.2를 의미한다. (간혹, float 자료형의 변수에 double 자료형의 값을 할당할 수 없다고 하는 자바의 규칙 때문에, 만약 x가 float 자료형의 변수이고 "x = 1.2"와 같은 것을 하려고 하면 우스꽝스러워 보이는 오류 메시지에 직면할 수도 있다는 점에서 이를 알 필요가 있다. "x = 1.2F;"라고 해야 한다. 이것이 실수에 대해서 double 자료형을 고수하라 조언하는 이유 중 하나이다.)

정수 리터럴의 경우에도 약간의 복잡함이 있다. 177777과 -32와 같은 일반적인 정수는 크기에 따라 byte, short 또는 int 자료형의 리터럴이다. 접미사로 "L"을 추가하면 long 자료형의 리터럴을 만들 수 있다. 예를 들자면: 17L 또는 728476874368L. 또 다른 복잡함은, 자바는 이진법, 8진법(밑이 8), 16진법(밑이 16) 리터럴을 허용한다. 기수(number base)를 자세히 다루고 싶지는 않지만, 다른 사람의 프로그램에서 우연히 만날 경우를 대비해서 몇 가지를 알아둘 가치는 있다: 8진수는 0에서 7까지의 숫자만 사용한다. 자바에서 0으로 시작하는 숫자 리터럴은 8진수로 해석된다. 예를 들어, 8진수 리터럴 045는 45가 아니라 37을 나타낸다. 8진법은 거의 사용되지 않지만 0으로 시작하는 경우 어떤 일이 일어나는지 주의할 필요가 있다. 16진수는 16자리 숫자, 통상적인 숫자 0~9와 A, B, C, D, E, F를 사용한다. 대문자와 소문자는 이 관계에서 서로 교환하여 사용할 수 있다. 그 글자들은 10에서 15까지의 숫자를 나타낸다. 자바에서 16진수 리터럴은 0x45 또는 0xFF7A에서와 같이 0x 또는 0X로 시작한다. 마지막으로 2진수 리터럴은 0b 또는 0B로 시작하고 숫자 0과 1만 포함한다; 예를 들자면: 0b10110.

마지막으로 숫자 리터럴에는 자릿수 그룹을 구분하는 데 사용할 수 있는 밑줄 문자("_")가 포함될 수 있다. 예를 들어, 20억에 대한 정수 상수는 2_000_000_000으로 표기될 수 있는데, 이는 2000000000보다 해독하기가 훨씬 쉽다. 각 그룹에 몇 자리까지 들어가야 하는지에 대한 규칙은 없다. 밑줄은 긴 이진수에서 특히 유용할 수 있다; 예컨대 0b1010_1100_1011.

16진수 숫자는 임의의 유니코드 문자를 나타내기 위해 문자 리터럴에서도 사용될 수 있다는 점을 지적하고자 한다. 유니코드 리터럴은 \u와 4개의 16진수로 구성된다. 예를 들어 문자 리터럴 '\u00E9'은 양음 악센트가 달린 유니코드 문자 "e"를 나타낸다.

boolean 자료형의 경우 정확히 두 리터럴이 있다: `true`와 `false`. 이 리터럴들은 인용 부호 없이 여기에 쓴 것과 똑같이 타이핑을 하지만, 이들은 변수가 아니라 값을 나타낸다. 부울 값은 조건식의 값으로 가장 자주 나타난다. 예를 들어,

`rate > 0.05`

이것은 변수 `rate`의 값이 0.05보다 크면 `true`로 평가하고, `rate` 값이 0.05보다 작거나 같으면 `false`로 평가하는 부울 값 표현식(boolean-valued expression)이다. 제3장에서 살펴보겠지만, 부울 값 표현식은 제어 구조에서 광범위하게 사용된다. 물론 부울 값도 boolean 자료형의 변수에 할당할 수 있다. 예를 들어, `test`가 boolean 자료형의 변수인 경우, 다음 두 할당문은 모두 허용된다:

```java
test = true;
test = rate > 0.05;
```

<hr>

## 4. 문자열 및 문자열 리터럴
자바에는 원시 자료형 외에 다른 자료형이 있지만, 다른 모든 자료형은 "원시적인" 데이터 값이라기보다 객체를 나타낸다. 대부분의 경우 우리는 당분간 객체에 대해 관련되지 않을 것이다. 그러나, 사전적으로 정의된 매우 중요한 객체 자료형이 하나 있다: 자료형 String. (String 은 자료형이지만 원시 자료형은 아니다; 사실상 클래스의 이름이며, 우리는 다음 절에서 문자열의 그러한 측면으로 돌아갈 것이다.)

String 자료형의 값은 문자들의 나열(sequence)이다. 이미 문자 리터럴을 본 적이 있을 것이다: "Hello World!". 쌍따옴표는 리터럴의 일부분이다; 쌍따옴표는 프로그램에서 입력되어야 한다. 그러나, 이들은 실제로 따옴표 사이의 문자만으로 구성된 String 값의 일부는 아니다. 문자열은 임의의 수의 문자들을, 심지어 0개라도 포함할 수 있다. 문자가 없는 문자열은 **빈 문자열(empty string)** 이라고 하며, 리터럴 ""으로 표현되는데, 이 한 쌍의 쌍따옴표 사이에 아무 것도 있지 않다. 단따옴표(single quotes)와 쌍따옴표(double quotes)의 차이점을 기억하라! 단따옴표는 char 리터럴에 사용되고 쌍따옴표는 String 리터럴에 사용된다! String "A"와 char 'A' 사이에는 큰 차이점이 있다.

문자열 리터럴 내에서 백슬래시 표기법을 사용하여 특수 문자를 나타낼 수 있다. 이런 맥락에서 쌍따옴표는 그 자체가 특별한 문자다. 예를 들어, 다음 문자열 **값**을 표시하고

`I said, "Are you listening!"`

그 끝에 줄바꿈(linefeed)을 사용하려면 다음과 같이 문자열 **리터럴**을 입력해야 할 것이다:

`"I said, \"Are you listening!\"\n"`

\t, \r, \ 및 \u00E9와 같은 유니코드 나열을 사용하여 문자열 리터럴의 다른 특수 문자를 나타낼 수도 있다.

<hr>

## 5. 프로그램의 변수
변수는 처음에 **선언된(declared)** 경우에만 프로그램에서 사용할 수 있다. **변수 선언문(variable declaration statement)** 은 하나 또는 그 이상의 변수를 선언하고 이름을 지정하는 데 사용된다. 컴퓨터가 변수 선언을 실행할 때 변수에 대한 메모리를 따로 설정하고 변수의 이름을 해당 메모리와 연결한다. 간단한 변수 선언은 다음과 같은 형식을 취한다:

{타입 이름 변수 이름 or 변수 이름들;}

{변수 이름;}는 단일의 변수 이름 또는 쉼표(comma)로 구분된 변수 이름 목록일 수 있다. (변수 선언문은 사실 이것보다 다소 복잡할 수 있다는 것을 나중에 알게 될 것이다.) 좋은 프로그래밍 스타일은 변수가 어떤 식으로든 밀접하게 연관되지 않는 한 선언문에 한 변수만 선언하는 것이다. 예를 들면:

```java
int numberOfStudents;
String name;
double x, y;        
boolean isFinished;
char firstInitial, middleInitial, lastInitial;
```

프로그램의 목적을 설명하기 위해 각 변수 선언과 함께 주석을 포함하거나, 인간 독자에게 유용할 수 있는 다른 정보를 제공하는 것도 좋은 방법이다. 예를 들면:

```java
double principal;    // 투자된 돈의 총액
double interestRate; // 십진법으로 된 이율, 퍼센트가 아님
```

이 장에서는 프로그램의 `main()` 서브루틴 내부에 선언된 변수만 사용할 것이다. 서브루틴 내부에 선언된 변수를 서브루틴에 대한 **지역 변수(local variable)** 라고 한다. 그것들은 서브루틴이 가동되는 동안에만 존재하며, 외부에서는 완전히 접근할 수 없다. 변수 선언은 각 변수가 어떤 식으로든 사용되기 전에 선언되는 한 서브루틴 내부 어디에서나 발생할 수 있다. 어떤 사람들은 서브루틴의 시작에 모든 변수를 선언하기를 좋아한다. 다른 이들은 변수가 필요할 때까지 기다리기를 좋아한다. 필자의 취향: 서브루틴의 시작 부분에 중요한 변수를 선언하고, 각 변수의 목적을 설명하기 위해 주석을 사용한다. "유틸리티 변수"의 선언은 이들이 서브루틴에서 처음 사용된 지점에서 볼 때 서브루틴의 전체 논리에 비추어 중요하지 않는 곳에서 이루어져야 한다. 다음은 몇 가지 변수 및 할당문을 사용하는 간단한 프로그램이다:

```java
/**
* This class implements a simple program that
* will compute the amount of interest that is
* earned on $17,000 invested at an interest
* rate of 0.027 for one year.  The interest and
* the value of the investment after one year are
* printed to standard output.
  */

public class Interest {

public static void main(String[] args) {

       /* Declare the variables. */

       double principal;     // The value of the investment.
       double rate;          // The annual interest rate.
       double interest;      // Interest earned in one year.

       /* Do the computations. */

       principal = 17000;
       rate = 0.027;
       interest = principal * rate;   // Compute the interest.

       principal = principal + interest;
             // Compute value of investment after one year, with interest.
             // (Note: The new value replaces the old value of principal.)

       /* Output the results. */

       System.out.print("The interest earned is $");
       System.out.println(interest);
       System.out.print("The value of the investment after one year is $");
       System.out.println(principal);

} // end of main()

} // end of class Interest
```

이 프로그램은 프로그램 사용자에게 정보를 표시하기 위해 여러 서브루틴 호출문을 사용한다. 두 개의 다른 서브루틴이 사용된다: `System.out.print` 및 `System.out.println`. 이들 간의 차이는 `System.out.println`이 표시하는 정보가 종료된 후 줄바꿈을 추가하는 반면 `System.out.print`는 그렇지 않다는 것이다. 따라서 서브루틴 호출 "`System.out.println(interest)`"에 의해 표시되는 interest 값은 이전의 `System.out.print` 문장에 의해 표시되는 문자열과 같은 줄을 따른다. `System.out.print` 또는 `System.out.println`으로 표시되는 값은 서브루틴 이름 뒤 괄호 안에 제공된다는 점에 유의하라. 이 값을 서브루틴에 대한 **매개변수(parameter)** 라고 한다. 매개변수는 서브루틴에 그 임무를 수행하는 데 필요한 정보를 제공한다. 서브루틴 호출문에서, 모든 매개변수들은 서브루틴 이름 뒤 괄호 안에 나열된다. 모든 서브루틴에 매개변수가 있는 것은 아니다. 서브루틴 호출문에 매개변수가 없는 경우, 서브루틴 이름 뒤에 반드시 비어있는 쌍괄호가 따라야 한다.

이 교재의 모든 샘플 프로그램은 온라인 버전에서 별도의 소스 코드 파일로 다음 주소(http://math.hws.edu/javanotes/source)에서 제공된다. 그것들은 또한 웹 사이트의 다운로드 가능한 아카이브 안의 `source`라는 이름의 폴더에 포함되어 있다. 예를 들어, `Interest` 프로그램의 소스 코드는 `source` 폴더 내 `chapter2` 이름의 하위 폴더에 있는 Interest.java 파일에서 찾을 수 있다.

