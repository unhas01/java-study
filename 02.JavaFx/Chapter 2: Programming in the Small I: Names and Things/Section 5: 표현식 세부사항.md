# Section 5: 표현식 세부서항

이 절에서는 표현식(expression)을 자세히 살펴본다. 표현식이 값을 나타내거나 계산하는 프로그램 코드의 일부라는 것을 떠올려라. 표현식은 리터럴, 변수, 함수 호출, 또는 +, >와 같은 연산자들로 결합된 몇몇이 될 수 있다. 표현식의 값은 변수에 할당하거나 서브루틴 호출에서 매개변수로 사용하거나, 다른 값과 결합하여 더 복잡한 표현식으로 사용할 수 있다. (어떤 경우에는, 그렇게 하길 원한다면, 그 값이 심지어 무시될 수도 있다; 이는 생각보다 더 일반적이다.) 표현식은 프로그래밍의 필수적인 부분이다. 지금까지 이 책은 비공식적으로 표현식만을 다루었다. 이 절에서는 다소 완결된 이야기를 들려준다(사용 빈도가 낮은 연산자 중 일부를 제외하고).

표현식의 기본 구성 요소는 리터럴(674, 3.14, true, 'X'와 같은), 변수 및 함수 호출(function call)이다. 함수가 값을 반환하는 서브루틴이라는 것을 상기하라. TextIO 클래스의 입력 루틴과 Math 클래스의 수학 함수와 같은 함수의 몇 가지 예제를 이미 보았을 것이다.

Math 클래스에는 수학 표현식에 유용한 두 개의 수학 상수도 포함되어 있다: `Math.PI`는 π(원 둘레에 대한 지름의 비율)를, `Math.E`는 e(자연 로그의 밑)를 나타낸다. 이러한 "상수들"은 실제로는 Math 의 double 자료형인 멤버 변수다. 이들은 수학 상수에 대한 근사치일 뿐이며, 정확히 명시하려면 무한한 수의 숫자가 필요하다. 표준 클래스 Integer 에는 int 데이터 자료형과 관련된 상수가 두 개 포함되어 있다: `Integer.MAX_VALUE`는 가능한 가장 큰 int인 2147483647이고, `Integer.MIN_VALUE`는 가장 작은 int인 -2147483648이다. 마찬가지로 Double 클래스에는 double 자료형과 관련된 상수가 포함되어 있다. `Double.MAX_VALUE`는 double 자료형의 가장 큰 값이며, `Double.MIN_VALUE`는 가장 작은 양수의(positive) 값이다. 이 또한 무한한 값을 나타내는 상수들인 `Double.POSITIVE_INFINITY` 및 `Double.NEGATIVE_INFINITY`, 그리고 정의되지 않은 값을 나타내는 특별한 값인 `Double.NaN`을 가진다. 예를 들어, `Math.sqrt(-1)`의 값은 `Double.NaN`이다.

리터럴, 변수, 함수 호출은 간단한 표현식이다. **연산자(operator)** 를 사용하여 더 단순한 표현식을 조합함으로써 더 복잡한 표현식을 만들 수 있다. 연산자에는 두 개의 숫자를 더하기 위한 +, 두 값을 비교하기 위한 > 등이 포함된다. 표현식에 여러 연산자가 등장하면, 계산을 위해 연산자를 그룹화하는 방법을 결정하는 **우선순위(precedence)** 문제가 있다. 예를 들어 "A + B * C"라는 표현식에서 B * C를 먼저 계산한 다음 그 결과가 A에 더해진다. 곱셈(*)이 덧셈(+)보다 **우선순위가 높다**는 것이다. 기본적인 우선순위가 마음에 들지 않으면 괄호를 사용하여 원하는 그룹화를 명시적으로 지정할 수 있다. 예를 들어 A를 B에 먼저 더한 다음 결과를 C로 곱하려면 "(A + B) * C"를 사용할 수 있다.

이 절의 나머지 부분에는 자바에 있는 연산자에 대한 세부사항이 나와 있다. 자바의 연산자 수는 꽤나 많다. 여기에서 전부를 다루진 않겠지만 중요한 대부분은 있다.

## 1. 산술 연산자
산술 연산자에는 덧셈, 뺄셈, 곱셈, 나눗셈 등이 있다. +, -, * 및 /로 표시된다. 이러한 연산은 byte, short, int, long, float, 또는 double의 모든 숫자 자료형의 값에 사용할 수 있다. (또한 이런 맥락에서 정수로 취급되는 char 자료형 값과 함께 사용될 수 있다; char는 산술 연산자와 함께 사용될 때 유니코드 코드 번호로 변환된다.) 컴퓨터가 실제로 이러한 연산 중 하나를 계산할 때, 컴퓨터가 결합하는 두 값은 동일한 자료형이어야 한다. 프로그램이 다른 자료형의 두 값을 결합하도록 컴퓨터에게 지시하면 컴퓨터는 값 중 하나를 한 자료형에서 다른 자료형으로 변환할 것이다. 예를 들어 37.4 + 10을 계산하기 위해 컴퓨터는 정수 10을 실수 10.0으로 변환한 다음 37.4 + 10.0을 계산한다. 이것을 **자료형 변환(type conversion)** 이라고 한다. 보통은 컴퓨터가 자동으로 하기 때문에 표현식의 자료형 변환에 대해 걱정할 필요가 없다.

두 개의 숫자 값이 결합될 때(필요하다면 그 중 하나에 대해 자료형 변환을 수행한 후에), 그 답은 같은 자료형이 된다. 두 개의 int를 곱하면 int를 얻는다; 두 개의 double을 곱하면 double을 얻는다. 이것은 예상할 수 있는 것이지만, 나눗셈 연산자 /를 사용할 때는 매우 조심해야 한다. 정수를 두 개 나누면 답은 항상 정수가 된다; 만약 그 몫이 분수 부분을 가지면, 그것은 버려진다. 예를 들어 7/2의 값은 3.5가 아니라 3이다. N이 정수인 변수인 경우, N/100은 정수이고, 1/N은 1보다 큰 N이라면 0과 같다! 이 사실은 프로그래밍 오류의 공통적인 소스이다. 피연산자 중 하나를 실수로 만들어 컴퓨터가 실수를 답으로 계산하도록 강제할 수 있다: 예를 들어 컴퓨터가 1.0/N을 계산할 때, 먼저 1.0의 자료형에 맞추기 위해 N을 실수로 변환하기 때문에 답으로 실수를 얻는다.

자바에도 한 숫자를 다른 숫자로 나눌 때 나머지를 계산하는 연산자가 있다. 이 연산자는 %로 표시된다. A와 B가 정수일 경우, A % B는 A를 B로 나눌 때 나머지를 나타낸다(단, 음의 피연산자에 있어서, %는 일반적인 수학적 "대수(modulus)" 연산자와 완전히 같지 않다. A 또는 B 중 하나가 음수라면, A % B의 값이 음수일 것이기 때문이다). 예를 들어 7 % 2는 1이고, 34577 % 100은 77, 50 % 8은 2이다. %의 일반적인 용도는 주어진 정수가 짝수인지 홀수인지를 시험하는 것이다: N은 N % 2가 0인 경우에는 짝수, N % 2가 1인 경우에는 홀수다. 보다 일반적으로는, N % M이 0인지 확인함으로써 정수 N이 정수 M으로 나누어 떨어지는지 여부를 확인할 수 있다.

% 연산자는 또한 실수에도 작동한다. 일반적으로 A % B는 A에서 가능한 한 많은 B의 복제들(copies)을 제거한 후 남은 것이다. 예를 들어, 7.52 % 0.5는 0.02이다.

마지막으로, 숫자의 음수를 취하는 **단항 뺄샘(unary minus)** 연산자가 필요할 수 있다. 예를 들어 -X의 값은 (-1) * X와 동일하다. 완전성을 위해 자바에는 실제로는 아무것도 하지 않지만, +X와 같이 단항 덧셈 연산자도 있다.

그런데, + 연산자는 어떤 자료형의 값을 String 으로 연결하는데도 사용할 수 있다는 것을 상기하라. +를 사용하여 문자열을 다른 자료형의 값과 결합할 경우 모든 자료형을 String 으로 자동 변환될 수 있으므로, 이 또한 자료형 변환의 또 다른 예가 된다.

## 2. 증가 및 감소
변수에 1을 더하는 것은 프로그래밍에서 극히 일반적인 작업이라는 것을 알게 될 것이다. 변수에서 1을 빼는 것도 꽤 흔한 일이다. 다음과 같은 할당문을 사용하여 변수에 1을 추가하는 작업을 수행할 수 있다:

```java
counter  =  counter + 1;
goalsScored  =  goalsScored + 1;
```

할당문 `x = x + 1`의 효과는 변수 `x`의 이전 값을 취하여 그 값에 1을 더하는 결과를 계산하고, 해당 결과를 `x`의 새 값으로 저장하는 것이다. x를 (또는,x를 선호한다면 이것을) 써도 같은 연산을 할 수 있다. 이것은 실제로 x의 값을 변경하여 "`x = x + 1`"을 쓰는 것과 같은 효과를 갖는다. 위의 두 문장은 다음과 같이 쓸 수 있다:

```java
counter++;
goalsScored++;
```

마찬가지로, x에서 1을 뺴려면 `x--`(또는 `--x`)를 쓰면 된다. 즉, `x--`는 `x = x - 1`과 동일한 계산을 수행한다. 변수에 1을 더하는 것을 그 변수를 **증가**시킨다(incrementing)라 하며, 1을 빼는 것을 **감소**시킨다(decrementing)라 한다. 연산자 와 --은 각각 증가 연산자와 감소 연산자라고 불린다. 이러한 연산자는 숫자 자료형에 속하는 변수와 char 자료형 변수라면 어느 것이든지 사용될 수 있다. (`ch`가 'A'인 경우 `ch`는 그 값을 'B'로 변경한다.)

일반적으로 연산자 또는 --는 "`x;" 또는 "x--;"와 같은 문장에서 사용된다. 이러한 문장은x의 값을 변경하기 위한 명령이다. 다만x,x,x--또는--x`를 표현식으로 사용하거나 더 큰 표현식의 일부로 사용하는 것도 허용된다. 즉, 다음과 같이 쓸 수도 있다:

```java
y = x++;
y = ++x;
TextIO.putln(--x);
z = (++x) * (y--);
```

`"y = x;" 문장은x의 값에 1을 추가하고, 거기에 더하여,y에 어떤 값을 할당하는 효과가 있다.y에 할당된 값은x의 **이전** 값, 즉 1이 더해지기 전의 값으로 정의된다. 따라서x의 값이 6이면 "y = x;"`라는 문장이 x의 값을 7로 바꾸지만, `y`에 할당된 값은 `x`의 **이전** 값이기 때문에 `y`의 값을 6으로 바꾼다. 반면에 `x의 값은x의 새로운 값, 즉 1이 추가된 후의 값으로 정의된다. 따라서x가 6이면 "y = x;"`라는 문장은 `x`와 `y`의 값을 모두 7로 변경한다. 감소 연산자인 --도 비슷한 방식으로 작동한다.

특히 `x = x;라는 문장이 **x의 값을 변경하지 않는다**는 점에 유의하라!x에 할당되고 있는 값이x의 이전 값, 즉 문장이 실행되기 전에 가졌던 값이기 때문이다. 최종 결과는x가 증가했지만 즉시 이전 값으로 다시 변경된다는 것이다!` `x`는 `x + 1`과 **같지 않다**는 것도 기억해야 한다. `x++`는 `x`의 값을 변경하지만 `x + 1`은 변경하지 않는다.

이것은 혼란스러울 수 있고, 나는 학생의 프로그램에서 이 혼란에서 생긴 많은 버그를 보아왔다. 필자의 조언: 혼란스러워 하지 마라. 표현식이 아닌 독립실행형(stand-alone) 문장으로만 ++와 --를 사용하라. 필자는 이 노트의 거의 모든 예제에서 이 조언을 따를 것이다.

<hr>

## 3. 관계 연산자
자바에는 `true`이거나 `false`일 수 있는 조건을 표현하는 데 사용될 부울 변수와 부울 값 표현식이 있다. 부울 값 표현식을 만드는 한 가지 방법은 **관계 연산자(relational operator)** 를 사용하여 두 값을 비교하는 것이다. 관계 연산자는 두 값이 동일한지 여부, 한 값이 다른 값보다 큰지 여부 등을 시험하기 위해 사용된다. 자바의 관계 연산자는 다음과 같다: ==, !=, <, >, <=, 그리고 >=. 이러한 연산자의 의미는 다음과 같다.

```java
A == B       // A와 B가 "동일"한가?
A != B       // A와 B가 "동일하지 않은"가?
A < B        // A가 B보다 "작은"가?
A > B        // A가 B보다 "큰"가?
A <= B       // A가 B보다 "작거나 같은"가?
A >= B       // A가 B보다 "크거나 같은"가?
```

이러한 연산자는 숫자 자료형의 값들을 비교하는 데 사용할 수 있다. 그들은 또한 char 자료형의 값을 비교하는 데 사용될 수 있다. 문자의 경우, < 및 >는 문자의 숫자 유니코드 값에 따라 정의된다. (이것은 항상 원하는 것이 아닐 수도 있다. 모든 대문자가 소문자보다 먼저 오기 때문에 알파벳 순서와 같지 않다.)

부울 표현식을 사용할 때는 컴퓨터에 관한 한 부울 값에 대해 특별한 것이 없다는 것을 기억해야 한다. 다음 장에서는 루프와 분기 문장에서 이들을 사용하는 방법을 알게 될 것이다. 그러나 숫자 변수에 숫자 값을 할당할 수 있는 것처럼 부울 값 표현식도 부울 변수에 할당할 수 있다. 그리고 함수는 부울 값을 반환할 수 있다.

한편 연산자 ==와 !=도 부울 값을 비교하는 데 사용할 수 있다. 이것은 때때로 유용하다. 예를 들어, 다음이 무얼 하는지 이해할 수 있을까:

```java
boolean sameSign;
sameSign = ((x > 0) == (y > 0));
```

관계 연산자 <, >, <=, >=를 가지고 **할 수 없는** 한 가지 일은 String 자료형의 값을 비교하는 데 이들을 이용하는 것이다. == 및 !=를 문자열을 비교하는 데 사용하는 것은 허용되지만, 객체가 동작하는 방식의 특수성 때문에 원하는 결과를 제공받지 못할 수도 있다. (== 연산자는 두 개 객체가 동일한 값을 포함하는지 여부보다, 동일한 메모리 위치에 저장되어 있는지 여부를 검사한다. 경우에 따라서는, 일부 객체에 대하여 이러한 검사를 정말로 수행하고 싶을 때도 있을 것이나 — 문자열에 대하여는 거의 그렇지 않다. 이것에 대해서는 이후의 장에서 다시 다루겠다.) 그 대신, 제2장 제3절 제3관에서 설명한 `equals()` 및 `compareTo()`와 같은 서브루틴을 사용하여 문자열을 비교해야 한다.

== 및 !=가 기대했던 것처럼 항상 작동하지 않는 또 다른 장소는, double 자료형의 정의되지 않은 값을 나타내는 상수인 `Double.NaN`이다. `x == Double.NaN`의 값은 모든 x에 대하여 false로 정의되고, `x != Double.NaN`은 이런 모든 경우에 대하여 true로 정의된다. 이러한 값은 심지어 `x`가 `Double.NaN`일 때에도 유지된다! 실제 값 x가 정의되지 않은 값 `Double.NaN`인지를 검사하려면, 부울 값 함수인 `Double.isNaN(x)`을 사용하라.

<hr>

## 4. 부울 연산자
영어에서 복잡한 조건들은 "and", "or" 그리고 "not"이라는 단어를 사용하여 형성될 수 있다. 예를 들어, "If there is a test **and** you did **not** study for it... (시험이 **있고** 이를 공부하지 **않았다면**...)". "and", "or", 그리고 "not"은 **부울 연산자(boolean operator)** 로, 영어뿐만 아니라 자바에도 존재한다.

자바에서 부울 연산자 "and"는 &&로 표현된다. && 연산자는 두 부울 값을 결합하는 데 사용된다. 그 결과 또한 부울 값이다. 결합된 두 값이 **모두** 참이면 결과는 `true`이고, 결합된 값 중 **하나가** 거짓이면 결과는 `false`이다. 예를 들어 "`(x == 0) && (y == 0)`"은 `x`가 0이고 `y`가 0인 경우에만 `true`이다.

부울 연산자 "or"는 ||로 표현된다. (그것은 수직선 문자 두 개로 되어 있다.) "A || B"라는 표현식은 A가 참이거나 B가 참이거나 둘 다 참일 경우 `true`이다. "A || B"는 A와 B가 모두 거짓일 경우에만 `false`이다.

연산자 && 및 ||는 부울 연산자의 **단락된(short-circuited)** 버전이라고 한다. 이것은 && 또는 ||의 두 번째 피연산자가 반드시 평가되지는 않음을 의미한다. 다음 판단식을 살펴보자:

```java
(x != 0) && (y/x > 1)
```

`x`의 값이 실제로 0이라고 가정하자. 이 경우 나눗셈 `y/x`는 수학적으로 정의되지 않는다. 그러나, 컴퓨터는 절대로 나눗셈을 수행하지 않을 것이다. 왜냐하면 컴퓨터가 `(x != 0)`을 평가할 때 그 결과가 false임을 알게 되고, 따라서 `(x != 0) && 무언가)`는 거짓이어야 한다는 것을 알기 때문이다. 그러므로 두 번째 피연산자를 굳이 평가하지 않는다. 평가가 단락되어 0으로 나누는 일이 회피된다. (이것은 전문적인 문제로 보일 수도 있고, 실제로 그렇다. 하지만 이는 때때로, 프로그래밍 삶을 조금 더 쉽게 만들어 줄 것이다.)

부울 연산자 "not"는 단항 연산자다. 자바에서, 그것은 !로 표시되고 그것의 단일 피연산자 앞에 쓰여진다. 예를 들어, `test`가 부울 변수인 경우,

```java
test = ! test;
```

이는 `true`에서 `false`로 변경하거나, `false`에서 `true`로 변경하여 `test`의 값을 반전(reverse)시킬 것이다.

## 5. 조건부 연산자
어느 훌륭한 프로그래밍 언어도, 꼭 필요한 것은 아니지만 그것을 사용할 때 개운함을 느끼게 해주는 아주 실용적이면서 작은 특징들을 가지고 있다. 자바에는 조건부 연산자가 있다. 이는 셋으로 이루어진(ternary) 연산자 — 즉 3개의 피연산자를 가진다 — 이며 반드시 함께 사용되야 하는 두 개의 조각, ?와 :가 들어간다. 다음의 형식을 취한다:

{boolean-expression} ? {expression1} : {expression2}

컴퓨터는 {boolean-expression} 값을 시험한다. 값이 true이면 {expression1}을 평가한다; 그렇지 않으면 {expression2}를 평가한다. 예를 들면:

```java
next = (N % 2 == 0) ? (N/2) : (3*N+1);
```

N이 짝수일 경우 (즉, N % 2 == 0이 `true`일 경우) N/2 값을 `next`에 할당하고, N이 홀수일 경우 그 값(3*N+1)을 `next`에 할당한다. (이 예시에서 괄호는 필요하지 않지만, 식을 정말로 읽기 쉽게 만든다.)

<hr>

## 6. 할당 연산자 및 자료형 변환

변수에 표현식의 값을 할당하기 위해 기호 "="를 사용하는 할당 문에 이미 익숙할 것이다. 사실, =는 할당(assignment) 자체가 표현식으로써 사용될 수 있거나 보다 복잡한 표현식의 일부로 사용될 수 있다는 점에서 정말로 연산자이다. A = B와 같은 할당의 값은 A에 할당되는 값과 동일하다. 따라서 A에 B의 값을 할당하고 그 값이 0인지 여부를 동시에 검사하려면, 다음과 같이 할 수 있다:

```java
if ( (A=B) == 0 )...
```

통상적으로, 말해왔지만, **이런 짓은 하지 마라!**

일반적으로 할당문 오른쪽의 표현식 자료형은 왼쪽의 변수 자료형과 같아야 한다. 그러나 경우에 따라서는 컴퓨터가 표현식에 의해 계산된 값을 변수의 자료형과 일치하도록 자동으로 변환한다. 숫자 자료형 목록을 생각해보자: byte, short, int, long, float, double. 이 목록의 초기에 나타나는 자료형의 값은 나중에 나타하는 값으로 자동적으로 변환될 수 있다. 예를 들면:

```java
int A;
double X;
short B;
A = 17;
X = A;    // OK; A는 double로 변환됨
B = A;    // 허용되지 않음; int에서 short로의 자동 변환은 없음
```

값의 의미론을 변경하지 않고 변환을 할 수 있을 때에만 자동 변환이 이루어져야 한다는 개념이다. 모든 int는 동일한 숫자 값을 가진 double로 변환될 수 있다. 하지만, short의 허용된 범위를 벗어난 int 값도 있다. 예를 들어, short 자료형의 가장 큰 값이 32767이므로, 그저 int 값 100000을 short로 표현할 방법이 없다.

경우에 따라서는, 자동으로 수행되지 않는 변환을 강제하길 바랄 수 있다. 이를 위해, 당신은 자료형 변환(type cast)이라고 하는 것을 사용할 수 있다. **자료형 변환**은 변환할 값 앞에 자료형 이름을 괄호 안에 넣어 표시한다. 예를 들어,

```java
int A;
short B;
A = 17;
B = (short)A;  // OK; A는 short 자료형의 값으로
//자료형 변환이 명시적으로 이루어졌다
```

어떤 숫자 자료형에서 다른 어떤 숫자 자료형으로 자료형 변환을 할 수 있다. 하지만, 숫자의 숫자 값은 자료형 변환에 의해 변경될 수 있다는 점에 유의하라. 예를 들어, `(short)100000`은 -31072이다. (-31072는 4바이트 int 값 100000를 취한 다음 short을 얻기 위해 그 중 2바이트를 던져 버려서 얻어진 것이다 — 그 2바이트에 있었던 실제 정보를 잃어버리게 되었다.)

실수를 정수로 자료형 변환하면, 분수 부분은 폐기된다. 예를 들어 `(int)7.9453`은 7이다. 자료형 변환의 다른 예로서, 1에서 6 사이의 랜덤한 정수를 얻는 문제를 생각해보자. `Math.random()` 함수는 0.0에서 0.9999... 사이의 실수를 제공하며, 따라서 `6 * Math.random()`은 0.0에서 5.999... 사이의 실수를 제공한다. 자료형 변환 연산자인 `(int)`를 사용하여 이를 정수로 변환할 수 있다: `(int)(6 * Math.random())` 따라서 `(int)(6 * Math.random())`은 정수 0, 1, 2, 3, 4, 5 중 하나이다. 1에서 6 사이의 숫자를 얻으려면 1을 더하면 된다: "`(int)(6 * Math.random()) + 1`". (`6 * Math.random()` 주위의 괄호는 우선순위 규칙 때문에 필요하며, 괄호가 없으면 자료형 변환 연산자는 6에만 적용된다.)

자료형 char는 거의가 정수형이다. char 값을 int 변수에 할당하고, char 변수에 0에서 65535 범위의 정수 상수를 할당할 수 있다. 또한 char와 숫자 자료형 사이에서 명백히 자료형 변환을 사용할 수 있다. 예를 들어, `(char)97`은 'a', `(int)'+'`는 43, `(char)('A' + 2)`는 'C'이다.

<hr>

String 과 다른 자료형 간의 변환은 자료형만을 변환하는 방식으로는 이루어질 수 없다. 어떤 자료형의 값을 문자열로 변환하는 한 가지 방법은 빈 문자열로 연결(concatenate)하는 것이다. 예를 들어, `"" + 42`는 문자열 "42"이다. 그러나 더 좋은 방법은 String 클래스의 정적 멤버 함수인 `String.valueOf(x)` 함수를 사용하는 것이다. `String.valueOf(x)`는 문자열로 변환된 x의 값을 반환한다. 예를 들어 String.valueOf(42)는 문자열 "42"이고, `ch`가 char 변수인 경우 `String.valueOf(ch)`는 `ch`의 값인 단일 문자를 가진 길이가 1인 문자열이다.

특정 문자열을 다른 자료형의 값으로 변환하는 것도 가능하다. 예를 들어 문자열 "`10`"은 int 값 10으로, 문자열 "`17.42e-2`"는 double 값 0.1742로 변환해야 한다. 자바에서는 이러한 변환을 내장 함수에 의해 처리한다.

표준 클래스 Integer 에는 String 에서 int로 변환하기 위한 정적 멤버 함수가 포함되어 있다. 특히 str이 자료형 String 의 어떤 표현식이라면 `Integer.parseInt(str)`는 `str`의 값을 int 자료형의 값으로 변환하려고 시도하는 함수 호출이다. 예를 들어 `Integer.parseInt("10")`의 값은 int 값 10이다. `Integer.parseInt`에 대한 매개변수가 허용되는 int 값에 해당하지 않으면 오류가 발생한다.

마찬가지로 표준 클래스 Double 은 `Double.parseDouble` 함수를 포함한다. str이 String 인 경우 `Double.parseDouble(str)`이라는 함수가 `str`을 double 자료형의 값으로 변환하려고 시도한다. `str`이 허용되는 double 값에 해당되지 않을 경우 오류가 발생한다.

<hr>

할당문으로 돌아가서, 자바에는 할당 연산자에 대한 몇 가지 변형(variation)이 있는데, 이는 타이핑을 절약하기 위해 존재한다. 예를 들어 "A +=B"는 "A = A + B"와 동일한 것으로 정의된다. 많은 자바의 연산자들이 유사한 할당 운영자들을 만들어냈다. 예를 들면 다음과 같다:

```java
x -= y;     // 동일함:   x = x - y;
x *= y;     // 동일함:   x = x * y;
x /= y;     // 동일함:   x = x / y;
x %= y;     // 동일함:   x = x % y;
```

복합 할당 연산자 +=는 문자열에도 작동한다. + 연산자를 피연산자 중 하나로써 문자열과 함께 사용할 경우 연결 상태를 나타내는 것을 떠올려라. `str += x`는 `str = str + x`와 같기 때문에 +=를 왼쪽의 문자열과 함께 사용하면 오른쪽의 값을 해당 문자열에 붙이는 것이다. 예를 들어 `str`에 "tire" 값이 있으면 `str += 'd';` 문장은 `str`의 값을 "tired"로 변경한다.

<hr>

## 7. 우선순위 규칙
한 표현식에 여러 연산자를 사용하면서, 평가 순서를 명시적으로 표시하는 괄호를 사용하지 않으면, 평가 순서를 결정하는 우선순위 규칙(precedence rules)에 대해 걱정해야 한다. (조언: 프로그램에서 자기 자신이나 독자를 혼동시키지 마라; 괄호를 자유롭게 사용하라.)

다음은 이 절에서 논의된 연산자들의 목록으로, 최고 우선순위(최초 평가)에서 최저 우선순위(최후 평가)까지 순서대로 나열한 것이다:

```java
단항 연산자:                    ++, --, !, 단항 -, 단항 +, 자료형 변환(type-cast)
곱셈과 나눗셈:                  *,  /,  %
덧셈과 뺄셈:                    +,  -
관계 연산자:                    <,  >,  <=,  >=
등식 및 부등식:                 ==,  !=
부울 and:                       &&
부울 or:                        ||
조건 연산자:                    ?:
할당 연산자:                    =,  +=,  -=,  *=,  /=,  %=
```

같은 행의 연산자는 같은 우선순위를 가진다. 괄호가 없는 상태에서 같은 우선순위의 연산자들이 함께 나열되면, 단항 연산자와 할당 연산자는 오른쪽에서 왼쪽으로 평가하고, 나머지 연산자들은 왼쪽에서 오른쪽으로 평가된다. 예를 들어, `A * B / C`는 (A * B) / C를 의미하고, `A = B = C`는 A = ( B = C)를 의미한다. (표현식으로써 B = C의 값이 B에 할당된 값과 동일하다는 점에서, 표현식 `A = B = C`이 어떻게 유용할 수 있는지 알겠는가?)


