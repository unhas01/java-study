# I/O 스트림, Readers 및 Writers

전 세계와 상호작용할 수 이쓴 능력이 없다면 프로그램은 쓸모가 없다. 프로그램과 나머지 세계와의 입력/출력 또는 I/O라고 한다. 역사적으로 프로그래밍 언어 설계에서 가장 어려운 부분 중 하나는 입력 및 출력을 위한 좋은 기능을 마련하는 것이었다. 컴퓨터는 다양한 유형의 입력 및 출력 장치에 연결될 수 있다. 프로그래밍 언어가 각 유형의 장치를 특별한 경우로 처리해야 한다면 복잡성이 엄청날 것이다. 프로그래밍 역사상 가장 큰 성과 중 하나는 I/O 장치를 표현하기 위한 좋은 추상화를 제시한 것이다. Java에서는 주요 I/O 추상화를 I/O 스트림이라고 한다. "파일" 및 "채널"과 같은 다른 I/O 추상화도 존재하지만 이 섹션에서는 스트림만 살펴 본다. 모든 스트림의 입력 소스 또는 출력이 전송될 수 있는 대상을 나타낸다.

## 1. 문자 및 바이트 스트림

입력/출력을 처리할 때 데이터에는 기계 형식 데이터와 사람이 읽을 수 있는 텍스트라는 두 가지 광범위한 범주가 있다는 점을 명심해야 한다. 컴퓨터 형식의 데이터는 데이터가 컴퓨터 내부에서 표현되는 것과 같은 방식, 즉 0과 1의 문자열로 이진 형식으로 표현된다. 사람이 읽을 수 있는 데이터는 문자 형식이다. 3.141592와 같은 숫자를 읽는 것은 일련의 문자를 읽고 이를 숫자를 해석하는 것이다. 동일한 숫자는 컴퓨터에서 인식할 수 없는 비트 문자열로 표시된다. 

데이터의 표현의 두 가지 광범위한 범주를 처리하기 위해 Java에는 기계 형식 데이터용 바이트 스트림과 사람이 읽을 수 있는 데이터용 문자 스트림이라는 두 가지 광범위한 스트림 범주가 있다. 각 유형의 스트림을 나타내는 사전 정의된 클래스가 여러개 있다.

데이터를 바이트 스트림으로 출력하는 객체는 추상 클래스 OutputStream의 하위 클래스 중 하나에 속한다. 바이트 스트림에서 데이터를 읽는 객체는 추상 클래스 InputStream의 하위 클래스에 속한다. OutputStream에 숫자를 쓰면 결과 데이터를 직접 읽을 수 없다. 그러나 데이터는 InputStream을 사용하여 컴퓨터로 다시 읽을 수 있다. 데이터 쓰기 및 읽기는 변환이 필요하지 않기 때문에 매우 효율적이다. 컴퓨터 내부의 데이터를 나타내는 데 사용되는 바이트는 단순히 스트림으로 복사되거나 스트림에서 복사된다.

사람이 읽을 수 있는 문자 데이터를 읽고 쓰기 위한 기본 클래스는 Reader 및 Writer 추상 클래스이다. 모든 문자 스트림 클래스는 이들 중 하나의 하위 클래스이다. Writer 스트림에 숫자를 기록하며면 컴퓨터는 이를 해당 숫자를 나타내는 사람이 읽을 수 있는 문자 시퀀스로 변환해야 한다. Reader 스트림에서 숫자 변수로 숫자를 읽는 것은 문자 시퀀스에서 해당 비트 문자열로의 변환도 포함한다. (작업 중인 데이터가 텍스트 편집기의 단어와 같이 원래 문자로 구성되어 있더라고 일부 번역이 있을 수 있다. 문자는 컴퓨터에 16비트 유니코드 값으로 저장된다. 영어 알파벳, 문자 데이터는 일반적으로 문자당 8비트만 사용하는 ASCII 코드의 파일에 저장된다. Reader 및 Writer 클래스는 이 변환을 처리하고 비서양 알파벳 및 알파벳이 아닌 문자를 처리할 수도 있다.)

바이트 스트림은 기계 간 직접적인 통신에 유용할 수 있으며, 특히 대규모 데이터베이스와 같이 대용량 데이터를 효율적으로 저장해야 하는 경우 파일에 데이터를 저장하는 데 유용할 수 있다. 그러나 . 그 의미가 자명하지 않다는 의미에서 이진 데이터는 취약하다. 일련의 0과 1이 연속되는 경우, 이를 해석하기 전에 그것이 표현하려는 정보가 무엇인지, 해당 정보가 어떻게 인코딩되는지 알아야 한다. 물론 문자 데이터의 경우에도 어느 정도 마찬가지이다. 문자도 다른 종류의 데이터와 마찬가지로 컴퓨터에서 저장하거나 처리하려면 이진수로 코딩해야 하기 때문이다. 그러나 문자 데이터의 이진 인코딩은 표준화되어 잘 이해되고 있으며 문자 형식으로 표현된 데이터는 인간 독자에게 의미를 부여할 수 있다. 현재의 추세는 문자 데이터의 사용이 증가하는 것으로 보이며, 이는 문자 데이터의 의미를 가능한 한 자명하게 만드는 방식으로 표현된다. 섹션 11.5에서 이를 수행하는 한 가지 방법을 살펴본다.

Java의 원래 버전에는 문자 스트림이 없었고 ASCII로 인코딩된 문자 데이터의 경우 바이트 스트림은 문자 스트림과 대체로 상호 교환 가능하다는 점에 유의해야 한다. 실제로 표준 입력 및 표준 출력 스트림인 `System.in` 및 `System.out`은 문자 스트림이 아닌 바이트 스트림이다. 그러나 문자 데이터로 작업할 때는 표준 ASCII 문자 세트로 작업할 때라고 InputStream 및 OutputStream 보다는 Reader 및 Writer를 선호해야 한다.

이 섹션에서 논의되는 표준 I/O 스트림 클래스는 여러 지원 클래스와 함게 `java.io` 패키지에 정의되어 있다. 프로그램에서 클래스를 사용하려면 이 패키지에서 클래스를 가져와야 한다. 이는 개별 클래스를 가져오거나 소스 파일 시작 부분에 `import java.io.*;` 지시문을 넣는 것을 의미한다. I/O 스트림은 파일 작업과 네트워크를 통한 통신에 사용된다. 동시에 실행되는 두 스레드 간의 통신에도 사용할 수 있으며, 컴퓨터 메모리에 저장된 데이터를 읽고 쓰기 위한 스트림 클래스가 있다.

(참고: Java API는 `java.nio` 패키지와 해당 하위 패키지에서 I/O에 대한 추가 자원을 제공하려면 이 교과서에서는 다루지 않다. 일반적으로 `java.nio`는 프로그래머에게 고급 I/O 기술에 대한 효율적인 엑세스를 제공한다.)


스트림 추상화의 장점은 화면에 정보를 인쇄하는 것만큼 파일에 데이터를 쓰거나 네트워크를 통해 데이터를 보내는 것이 쉽다.

---

기본 I/O 클래스 Reader, Writer, InputStream, OutputStream은 매우 원시적인 I/O 작업만 제공한다. 예를 들어 InputStream 클래스는 추상 인스턴스 메서드를 선언한다.

```java
public int read() throws IOException;
```

입력 스트림에서 0~255 범위의 숫자로 1바이트의 데이터를 읽는 데 사용된다. 입력 스트림의 끝에 도달하면 `read()` 메서드는 대신 -1 값을 반환한다. 입력 시도 중에 오류가 발생하면 IOException 유형의 예외가 발생한다. IOException은 checked exception 이므로, `try` 문 내부나 `throws IOException` 절로 선언된 서브 루틴 내부를 제외하고는 `read()` 메서드를 사용할 수 없음을 의미한다. 

또한 InputStream 클래스는 여러 바이트의 데이터를 한 단계에서 `byte` 배열로 읽는 메서드를 정의한다. 이는 개별 바이트를 읽는 것보다 훨씬 더 효율적일 수 있다. 그러나 InputStream은 스트림에서 int 또는 double과 같은 다른 유형의 데이터를 읽는 데 편리한 방법을 제공하지 않는다. InputStream 유형 자체의 객체를 거의 사용하지 않기 때문에 이는 문제가 되지 않는다. 대신, 당신은 InputStream의 다소 원시적인 기능에 보다 편리한 입력 방법을 추가하는 InputStream의 서브 클래스를 사용할 것 이다. 마찬가지로 OutputStream 클래스는 1바이트의 데이터를 출력 스트림에 쓰기 위한 기본 출력 방법을 정의한다. 

```java
public void write(int b) throws IOException
```

매개 변수는 byte 대신 int 유형이지만 매개변수 값은 기록되기 전에 byte 유형으로 변환된다. 이는 `b`의 하위 8비트를 제외한 모든 비트를 효과적으로 삭제한다. 다시 말하지만, 실제로는 거의 항상 OutputStream의 일부 하위 클래스에 정의된 상위 수준 출력 작업을 사용하게 된다.

Reader 및 Writer 클래스는 유사한 하위 수준 `read`, `write` 메서드를 제공한다. 바이트 스트림 클래스에서와 마찬가지로 Writer의 `writer(c)` 메서드 매개 변수와 Reader의 `read()` 메서드의 반환 값은 int 유형이지만 이러한 문자 지향 클래스에서는 I/O 작업 읽기 및 바이트 대신 문자를 쓴다. 입력 스트림의 끝에 도달하면 `read()`의 반환 값은 -1이다. 그렇지 않으면 반환 값은 char 형식으로 형 변환되어야 한다. 읽은 문자를 얻으려면, 실제로는 아래 설명과 같이 일반적으로 Reader 및 Writer 하위 클래스에서 제공하는 더 높은 수준의 I/O 작업을 사용한다.

## 2. PrintWriter

Java I/O 패키지의 멋진 점 중 하나는 해당 기능을 제공하는 다른 스트림 객체에 "래핑"하여 스트림에 기능을 추가할 수 있다는 것이다. 래퍼 객체도 스트림이므로 읽거나 쓸 수 있다. 하지만 기본 스트림에 사용할 수 있는 것보다 더 멋진 작업을 사용하면 그렇게 할 수 있다. 

예를 들어, PrintWriter는 모든 Java 기본 데이터 유형에 대해 사람이 읽을 수 있는 문자 표현을 출력하기 위한 편리한 메서드를 제공하는 Writer의 하위 클래스이다. Writer 클래스 또는 그 하위 클래스에 속하는 객체가 있고 PrintWriter 메서드를 사용하여 해당 Writer에 데이터를 출력하려는 경우 해야 할 일은 Writer를 PrintWriter 객체에 래핑하는 것 뿐이다. Writer를 생성자에 대한 입력으로 사용하여 새 PrintWriter 객체를 생성하면 된다. 예를 들어 `charSink`가 Writer 유형인 경우 다음과 같이 말할 수 있다.

```java
PrintWriter printableCharSink = new PrintWriter(charSink);
```

실제로 생성자에 대한 매개변수는 OutputStream 또는 File일 수도 있으며 해당 출력 대상에 쓸 수 있는 PrintWriter를 빌드한다. PrintWriter의 고급 출력 방법을 사용하여 PrintWriter `printableCharSink`에 데이터를 출력하면 해당 데이터는 `charSink`에 직접 작성된 데이터와 정확히 동일한 위치로 이동한다. 동일한 출력 대상에 더 나은 인터페이스를 제공했다. 예를 들어 PrintWriter 메서드를 사용하여 파일이나 네트워크 연결을 통해 데이터를 보낼 수 있다.


- `out.print(x)` : 문자열 형식으로 표현된 `x` 값을 출력 스트림에 인쇄한다.
- `out.println()` : 출력 스트림에 줄 끝을 출력한다.
- `out.println(x)` : `x`값과 줄 끝을 출력한다.
- `out.printf(formatString, x1, x2, ...)` : `x1`, `x2`의 형식화된 출력을 출력 스트림으로 수행한다.
- `out.flush()` : 위 메서드로 작성된 문자가 작성된 문자가 실제로 출력 대상으로 전송되는지 확인한다.

이러한 메서드 중 어느 것도 IOException을 발생시키지 않는다. 대신 다음 메서드가 포함된다.

```java
public boolean checkError()
```

스트림에 쓰는 동안 오류가 발생하면 `true`를 반환한다. PrintWriter 클래스는 모든 IOException을 내부적으로 포착하고, 발생하는 경우 내부 오류 플래그 값을 설정한다. `checkError()` 메서드를 사용하며 오류 플래그를 확인할 수 있다. 이를 통해 예외 포착에 대한 걱정 없이 PrintWriter 메서드를 사용할 수 있다. 반면에 완전히 견고한 프로그램을 작성하려면 PrintWriter를 사용할 떄마다 `checkError()`를 호출하여 가능한 오류를 테스트해야 한다.

## 3. Data Streams

PrintWriter를 사용하여 데이터를 스트림으로 출력하면 데이터는 사람이 읽을 수 있는 형식으로 데이터를 나타내는 문자 시퀀스를 변환한다. 데이터를 바이트 중심, 기계 형식으로 출력한다고 가정해 본다. `java.io` 패키지에는 내부 이진수 형식으로 스트림에 데이터 값을 쓰는 데 사용할 수 있는 `byte` 스트림 클래스인 DataOutputStream이 포함되어 있다. DataOutputStream은 PrintWriter가 Writer와 연결되는 OutputStream과 동일한 관계를 유지하다. 즉, OutputStream에는 바이트를 출력하는 메서드만 있는 반면 DataOutputStream에는 메서드가 있다. double 유형의 값을 출력하는 경우 `writeDouble(double x)`, int 유형은 `writeInt(int x)`등이다. 또한 더 높은 수준의 출력 방법을 사용할 수 있도록 모든 OutputStream을 DataOutputStream으로 래핑할 수 있다. 

```java
DataOutputStream dataSink = new DataOutputStream(byteSink);
```

`byteSink`에 DataOutputStream을 래핑한다.

DataOutputStream에 작성하면 생성된 것과 같은 기계 판독 가능 데이터의 입력을 위해 `java.io`는 DataInputStream 클래스를 제공한다. DataInputStream 객체에 모든 InputStream을 래핑하여 바이트 스트림에서 다양한 유형의 데이터를 읽는 기능을 제공할 수 있다. 이진 데이터를 읽기 위한 DataInputStream의 메서드인 `readDouble()`, `readInt()` 등이라고 한다. DataOutputStream으로 작성된 데이터는 DataInputStream으로 읽을 수 있는 형식임을 보장한다. 이는 데이터 스트림이 한 유형의 컴퓨터에서 생성되어 다른 유형의 컴퓨터에서 읽는 경우에도 마찬가지이다. 바이너리 데이터의 플랫폼 간 호환성은 Java 플랫폼 독립성의 주요 측면이다. 

어떤 상황에서는 InputStream에서 문자 데이터를 읽거나 OutputStream에 문자 데이터를 써야할 수 도 있다. 모든 데이터와 마찬가지로 문자도 궁극적으로 이진수로 표시되므로 이는 문제가 되지 않다. 단, 문자 데이터의 경우에는 InputStream, OutputStream 대신 Reader, Writer를 사용하는 것이 편리하다. 이를 가능하게 하려면 바이트 스트림을 문자 스트림으로 래핑할 수 있다. `byteSource`가 InputStream 유형의 변수이고 `byteSink`가 OutputStream 유혀인 경우 사용은 다음과 같다.

```java
Reader charSource = new InputStreamReader( byteSource );
Writer charSink   = new OutputStreamWriter( byteSink );
```

바이트 스트림에서 문자 데이터를 읽고 쓰는 데 사용할 수 있는 문자 스트림을 생성한다. 특히, 기록적인 이유로 입력 스트림 유형인 표준 입력 스트림 `System.in`을 Reader에 래핑하여 표준 입력에서 문자 데이터를 더 쉽게 읽을 수 있다.

```java
Reader charIn = new InputStreamReader(System.in);
```

또 다른 어플리케이션으로서, 네트워크 연결과 관련된 입력 및 출력 스트림은 문자 스트림이 아닌 바이트 스틀미이지만 바이트 스트림을 문자 스트림으로 래핑하여 네트워크를 통해 문자 데이터를 쉽게 보내고 받을 수 있다. 섹션 11.4에서 네트워크 I/O를 살펴본다.

문자를 이진 데이터로 인코딩하는 방법에는 여러 가지가 있다. 특정 인코딩을 문자 세트 또는 문자 세트라고 한다. 문자 세트에는 "UTF-16", "UTF-8" 및 "ISO-8859-1"과 같은 표준화된 이름이 있다. UTF-16에서 문자는 16비트 유티코드 값으로 인코딩된다. 이는 Java에서 내부적으로 사용되는 문자 집합이다. UTF-8은 일반적인 ASCII 문자에 8비트를 사용하고 다른 문자에 더 킨 코드를 사용하여 유니코드 문자를 인코딩하는 방법이다. "Latin-1"이라고 알려진 ISO-8859-1은 ASCII 문자 뿐만 아니라 여러 유럽 언어에서 사용되는 특정 악센트 문자를 포함하는 8비트 인코딩이다. Reader와 Writer가 다른 문자 세트를 지정하지 않은 한 실행 중이 컴퓨터의 기본 문자 세트를 사용하자. 

```java
Writer charSink = new OutputStreamWriter( byteSink, "ISO-8859-1" );
```

확실히 다양한 문자 집합 인코딩이 존재함으로써 텍스트 처리가 더욱 복잡해졌다. 이는 영어 사용자에게는 불행한 일이지만 비서구 문자 집합을 사용하는 사람들에게는 필수적이다. 일반적으로 이에 대해 걱정할 필요가 없지만 기본이 아닌 방식으로 인코딩된 텍스트 데이터를 실행하는 경우를 대비해 다양한 문자 집합이 존재한다는 점을 알아 두는 것이 좋다.

## 4. 텍스트 읽기

많은 I/O는 사람이 읽을 수 있는 문자 형태로 수행된다. 이러한 관점에서 볼 떄 Java가 PrintWriter의 문자 출력 기능와 합리적으로 대칭적인 방식으로 문자 데이터를 읽을 수 있는 표준 문자 입력 클래스를 제공하지 않는다는 것은 놀라운 일이다. 섹션 2.4.6에서 간략하게 소개되고 아래에서 더 자세히 설명되는 Scanner 클래스는 매우 유사하지만 Scanner는 I/O 스트림 클래스의 하위 클래스가 아니므로 I/O에 딱 들어맞지 않는다. 표준 클래스 BufferedReader에 의해 쉽게 처리되는 하나의 기본 사례가 있다.

```java
public String readLine() throws IOException
```

입력 소스에서 한 줄의 텍스트를 읽는다. 스트림 끝에 도달한 경우 반환 값은 `null` 아다. 텍스트 줄을 읽으면 입력 스트림에서 줄 끝 표시를 읽지만 반환되는 문자열의 일부는 아니다. 서로 다른 입력 스트림은 서로 다른 문자를 줄 끝 표시로 사용하지만 `readLine` 메서드는 모든 일반적인 경우를 처리할 수 있다. (전통적으로 Linux 및 MacOS를 포함한 Unix 컴퓨터 는 줄 끝을 표시하기 위해  줄 바꿈 문자 `'\n'` 을 사용한다. 클래식 Macintosh는 캐리지 리턴 문자 `'\r'` 을 사용 하고 Windows는 두 문자 시퀀스를 사용한다. `'\r\n'`. 일반적으로 최신 컴퓨터는 이러한 모든 가능성을 올바르게 처리할 수 있다.)

BufferedReader는 또한 스트림 API와 함께 사용할 수 있는 Stream<String> 유형의 값을 반환하는 인스턴스 메서드 `lines()`를 정의한다. `reader`의 모든 라인을 처리하는 편리한 방법은 라인 스트림에 `forEachOrdered()` 연산자를 사용하는 것이다.: `reader.lines().forEachOrdered(action)` 여기서 `action`은 일반적으로 다음과 같이 제공되는 문자열 소비자이다.

라인별 처리는 매우 일반적이다. 전체 텍스트 줄을 쉽게 읽을 수 있도록 모든 Reader는 BufferedReader로 래핑할 수 있다. `reader`가 Reader 유형인 경우 다음을 사용하여 `reader`에 대해 BufferedReader 래퍼를 생성할 수 있다.

```java
BufferedReader in = new BufferedReader(reader);
```

이는 위에서 언급한 InputStream 클래스와 결합하여 InputStream에서 텍스트 줄을 읽을 수 있다.

```java
BufferedReader in;  // BufferedReader for reading from standard input.
in = new BufferedReader( new InputStreamReader( System.in ) );
try {
    String line = in.readLine();
    while ( line != null ) {
        processOneLineOfInput( line );
        line = in.readLine();
   }
}
catch (IOException e) {
}
```

이 코드 세그먼트는 스트림 끝에 도달할 때까지 표준 입력에서 행을 읽고 처리한다. (대화형 입력의 경우에도 스트림 끝이 가능한다. 예를 들어 적어도 일부 컴퓨터에서는 `Control-D`를 입력하면 표준 입력 스트림에서 스트림 끝이 생성된다.) `try..catch` 문이 필요하다. `readLine` 메소드는 필수 예외 처리가 필요한 IOException 유형의 예외를 발생시킬 수 있기 때문이다. `try..catch` 에 대한 대안은 `throws IOException` 코드를 포함하는 메소드를 선언하는 것이다. 또한 BufferedReader, InputStreamReader 및 IOException은 `java.io` 패키지에서 가져와야 한다.

BufferedReader 의 주요 목적은 단순히 텍스트 줄을 더 쉽게 읽는 것이 아니다. 일부 I/O 장치는 데이터를 개별 바이트나 문자 대신 큰 덩어리로 읽거나 쓸 때 가장 효율적으로 작동한다. BufferedReader는 데이터 덩어리를 읽고 이를 내부 메모리에 저장한다. 내부 메모리를 **버퍼(buffer)** 라고 한다. BufferedReader에서 읽을 때 가능하면 버퍼에서 데이터를 가져오고 버퍼가 비워지면 더 많은 데이터를 얻기 위해 입력 소스로만 돌아간다. BufferedWriter 클래스 도 있고, 바이트 스트림을 위한 버퍼링된 스트림 클래스도 있다.

---

이 책의 이전 부분에서는 사용자와 파일 모두의 입력을 위해 비표준 클래스 TextIO를 사용했다. TextIO 의 장점은 기본 유형의 데이터 값을 매우 쉽게 읽을 수 있다는 것이다. 단점은 TextIO가 한 번에 하나의 입력 소스에서만 읽을 수 있고 Java의 내장 입력/출력 클래스와 동일한 패턴을 따르지 않는다는 점이다. ( TextIO 에서 사용하는 입력 스타일이 마음에 드시면 보다 객체 지향적인 방식으로 유사한 입력 스타일을 구현하는 [TextReader.java](https://math.hws.edu/javanotes/source/chapter11/TextReader.java)를 살펴보자. TextReader는 이 교과서의 이전 버전에서 사용되었지만 사용되지 않았다.)

## 5. Scanner 클래스

Java는 출시 이후 기본 입력에 대한 기본 지원이 부족하거나 최소한 Java가 제공하는 지원을 위해 상당히 진보된 기술에 의존한다는 점으로 유명해졌다. Scanner 클래스는 문자 입력 소스에서 기본 데이터 유형을 더 쉽게 읽을 수 있도록 도입되었다. 문제가 완전히 해결되지는 않지만 큰 개선이 된다. Scanner 클래스는 `java.util` 패키지에 있다. 섹션 2.4.6에서 소개되었지만 그 이후로 이 교과서에서는 많이 사용되지 않았다. 그러나 이제부터 대부분의 예제에서는 TextIO대신 Scanner를 사용하게 된다.

입력 루틴은 Scanner 클래스에 인스턴스 메서드로 정의되어 있으므로 해당 클래스를 사용하려면 Scanner 객체를 생성해야 한다. 생성자는 Scanner가 읽을 문자의 소스를 지정한다. 스캐너는 입력 소스에 대한 래퍼 역할을 한다. 소스는 무엇보다도 Reader, InputStream, String 또는 File일 수 있다. 문자열이 입력 소스로 사용되는 경우 스캐너는 스트림에서 동일한 문자 시퀀스를 처리하는 것과 동일한 방식으로 문자열의 문자를 처음부터 끝까지 읽는다. 예를 들어 다음을 사용할 수 있다.

```java
Scanner standardInputScanner = new Scanner( System.in );
```

`charSource`가 Reader 유형인 경우 다음을 사용하여 생성하라 수 있다.

```java
Scanner scanner = new Scanner( charSource );
```

입력을 처리할 때 스캐너는 일반적으로 토큰을 사용하여 작동한다. 토큰은 현재 목적에 따라 더 작은 의미있는 조각으로 나눌 수 없는 의미 있는 문자열이다. 예를 들어 토큰은 double 유형의 값을 나타내는 개별 단어 또는 문자열일 수 있다. 스캐너의 경우 토큰은 "구분 기호(delimiters)"로 구분되어야 한다. 기본적으로 구분 기호는 공백, 탭, 줄 끝 표시와 같은 공백 문자이다. 일반적으로 처리에서 공백 문자는 단순히 토큰을 분리하는 역할을 하며 스캐너에 의해 삭제된다. 스캐너에는 다양한 유형의 토큰을 읽는 인스턴스 메서드가 있다. 

- `scanner.next()` : 입력 소스에서 다음 토큰을 읽고 String으로 반환
- `scanner.nextInt()`, `scanner.nextDouble()` : 입력 소스에서 다음 토큰을 읽고 int, double로 변환
- `scanner.nextLint()` : 입력 소스에서 다음 줄 끝까지 전체 줄을 읽고 String 유형 값으로 반환


이러한 메서드는 모두 예외를 생성할 수 있다. 입력 끝을 지나서 읽으려고 하면 NoSuchElementException 유형의 예외가 발생한다. `scanner.getInt()`와 같은 메서드는 입력의 다음 토큰이 요청된 유형의 값을 나타내지 않는 경우 InputMismatchException 유형의 예외가 발생한다. 생성될 수 있는 예외에는 필수 예외 처리가 필요하지 않다.

스캐너 클래스에는 매우 뛰어난 미리보기 기능이 있다.

- `scanner.hasNext()` : 입력 소스에 토큰이 하나 이상 있는 경우 true 반환
- `scanner.hasNextInt()`, `scanner.hasNextDouble()` : 입력 소스에 토큰이 하나 이상이 있고 해당 유형인 경우 true 반환
- `scanner.hasNextLine()` : 입력 소스에 라인이 하나 이상 더 있는 경우 true 반환


구분 기호로만 토큰을 정의해야 한다는 주장으로 인해 스캐너의 유용성이 어느 정도 제한되기는 하지만 스캐너는 사용하기 쉽고 많은 애플리케이션에 적합하다. BufferedReader, TextIO, Scanner 등 사용 가능한 입력 클래스가 너무 많아서 어떤 클래스를 사용할지 결정하는 데 어려움을 겪을 수 있다! 일반적으로 TextIO 스타일 입력을 선호하는 특별한 이유가 없는 한 스캐너를 사용하는 것이 좋다. BufferedReader는 입력 소스에서 전체 텍스트 줄을 읽는 것뿐일 때 간단한 대안으로 사용할 수 있다.

(Scanner 에서 사용하는 구분 기호를 변경할 수 있지만 구문은 "정규 표현식"이라는 것을 사용ㅎㄴ다. 불행하게도 정규 표현식의 구문은 다소 복잡하여 이 책에서는 다루지 않는다. 그러나 예를 들어 토큰이 영어 알파벳 문자로만 구성된 단어라고 가정한다. 이 경우 구분 기호는 문자가 아닌 모든 문자를 포함해야 한다. Scanner, `scnr` 에서 이러한 종류 의 구분 기호를 사용하려면 다음과 같이 말할 수 있다. : `scnr.useDelimiter("[^a-zA-Z]+")`. 그 후 `scnr.next()`에서 반환된 토큰은 완전히 문자로 구성된다. 문자열 `"[^a-zA-Z]+"` 정규식이다. 정규식은 현업 프로그래머에게 중요한 도구이다.)

## 6. 직렬화된 객체 I/O

PrintWriter, Scanner, DataInputStream 및 DataOutputStream 클래스를 사용 하면 모든 Java 기본 데이터 유형을 쉽게 입력하고 출력할 수 있다. 하지만 객체를 읽고 쓰려고 하면 어떻게 되나?? 전통적으로 객체를 기본 유형에 속하는 일련의 데이터 값으로 인코딩한 후 바이트나 문자로 출력할 수 있는 방법을 찾아야 한다. 이것을 객체 직렬화라고 한다. 입력 시 직렬화된 데이터를 읽고 어떻게든 원본 객체의 복사본을 재구성해야 한다. 복잡한 객체의 경우 이는 모두 중요한 일이 될 수 있다. 그러나 ObjectInputStream 및 ObjectOutputStream 클래스를 사용하면 Java가 많은 작업을 수행하도록 할 수 있다. 이는 직렬화된 객체를 읽고 쓰는 데 사용할 수 있는 InputStream 및 OutputStream 의 하위 클래스이다.

ObjectInputStream 및 ObjectOutputStream은 임의의 InputStream 및 OutputStream을 래핑할 수 있는 래퍼 클래스이다. 이를 통해 모든 바이트 스트림에서 객체 입력 및 출력을 수행할 수 있다. 객체 I/O에 대한 메서드는 ObjectInputStream 의 `readObject()` 및 ObjectOutputStream의 `writeObject(Object obj)` 입니다. 이 두 가지 방법 모두 IOExceptions를 발생시킬 수 있다. `readObject()`는 일반적으로 읽은 객체의 실제 유형으로 유형 변환되어야 하는 Object 유형의 값을 반환한다.

ObjectOutputStream에는 원시 유형 값을 스트림에 출력하기 위한 `writeInt()`, `writeDouble()` 등의 메소드도 있으며, ObjectInputStream 에는 원시 유형 값을 읽기 위한 해당 메소드가 있다. 이러한 기본 유형 값은 데이터의 객체와 함께 배치될 수 있다. 파일에서 기본 유형은 내부 바이너리 형식으로 표시된다.

객체 스트림은 바이트 스트림이다. 객체는 기계가 읽을 수 있는 이진 형식으로 표시된다. 이는 효율성에는 좋지만 이진 데이터에서 흔히 볼 수 있는 취약성으로 인해 어려움을 겪는다. 그들은 Java 객체의 바이너리 형식이 Java에 매우 특정하여 다른 프로그래밍 언어로 작성된 프로그램에서 객체 스트림의 데이터를 쉽게 사용할 수 없다는 추가적인 문제를 겪고 있다. 이러한 이유로 객체 스트림은 주로 객체의 단기 저장과 네트워크 연결을 통해 하나의 Java 프로그램에서 다른 프로그램으로 객체를 전송하는 데 적합하다. 장기 저장 및 비Java 프로그램과의 통신을 위해서는 일반적으로 객체 직렬화에 대한 다른 접근 방식이 더 좋다. (문자 기반 접근 방식은 섹션 11.5를 참조하자. 하위 섹션 12.5.1을 참조하세요.)

ObjectInputStream 및 ObjectOutputStream은 `Serialized` 라는 인터페이스를 구현하는 객체에서만 작동한다. 또한 객체의 모든 인스턴스 변수는 직렬화 가능해야 한다. 그러나 직렬화 가능 인터페이스는 어떤 메소드도 선언하지 않기 때문에 객체를 직렬화 가능하게 만드는 데 관련된 작업은 거의 없다. 이는 객체가 쓰기 가능하고 읽기 가능하다는 것을 컴파일러에 알리는 표시로만 존재한다. 클래스 정의에 `" implements Serializer "` 라는 단어만 추가하면 된다. Java의 표준 클래스 중 다수는 이미 직렬화 가능하도록 선언되어 있다.

ObjectOutputStreams 사용에 대한 한 가지 경고 : 이러한 스트림은 동일한 객체를 두 번 이상 작성하지 않도록 최적화 되었다. 객체가 두 번째로 발견되면 첫 번째 발생에 대한 참조만 기록된다. 안타깝게도 그 사이에 개체가 수정된 경우 새 데이터가 기록되지 않는다. 즉, 수정된 값이 스트림에 올바르게 기록되지 않는다. 이 때문에 ObjectOutputStreams는 주로 생성된 후에 변경할 수 없는 "불변" 개체와 함께 사용하기 위한 것이다. ( 문자열이 이에 대한 예입니다.) 그러나 변경 가능한 객체를 ObjectOutputStream 에 작성해야 하는 경우, 동일한 객체를 두 번 이상 작성할 가능성이 있는 경우 객체를 스트림에 쓰기 전에 스트림의 `reset()` 메서드를 호출하여 객체의 전체적이고 올바른 버전이 기록되도록 할 수 있다.

