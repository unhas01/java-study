# Section 3: 매개변수

서브루틴이 블랙박스라면 매개변수(parameter)는 외부 세계의 정보를 박스로 전달하기 위한 메커니즘(mechanism)을 제공하는 무언가이다. 매개변수는 서브루틴의 인터페이스 일부분이다. 이들은 서브루틴을 특정한 상황에 맞추기 위해 서브루틴을 사용자화(customize)할 수 있게 만든다.

비유하자면, 온도 조절기(thermostat) — 즉 집을 일정한 온도로 유지하는 것이 임무인 블랙박스를 생각해보라. 온도 조절기에는 원하는 온도를 설정하는 데 사용되는 이른바 다이얼(dial), 즉 매개변수가 있다. 온도 조절기는 항상 같은 작업을 수행한다: 일정한 온도의 유지. 하지만, 이것이 수행하는 정확한 작업 — 즉, 이것이 유지하는 **어떠한** 온도 — 은 다이얼의 설정에 의해 사용자화된다.

<hr>

## 1. 매개변수 사용
한 예로써, 제3장 제2절 제2관에서 논의하였던 "3N+1" 문제로 돌아가보자. (3N+1 순서는 "N이 홀수라면 3을 곱하고 1을 더한다; N이 짝수라면 2로 나눈다; N이 1과 같아질 때까지 이를 계속한다."는 규칙에 의해 계산된다는 점을 떠올려라. 예를 들면, N=3에서 시작하면 다음 순서를 얻는다: 3, 10, 5, 16, 8, 4, 2, 1.) 이러한 순서를 출력하기 위한 서브루틴을 작성하고 싶다 가정하자. 서브루틴은 항상 동일한 작업을 수행한다: 3N+1 순서의 출력. 그러나 정확한 순서는 N의 시작 값에 의해 달라진다. 따라서 N의 시작 값은 서브루틴에 대한 매개변수가 될 것이다. 해당 서브루틴은 다음과 같이 작성될 수 있다:

```java
/**
* This subroutine prints a 3N+1 sequence to standard output, using
* startingValue as the initial value of N.  It also prints the number
* of terms in the sequence. The value of the parameter, startingValue,
* must  be a positive integer.
*/
static void print3NSequence(int startingValue) {

    int N;      // 순서의 항목 중 하나.
    int count;  // 항목의 갯수.

    N = startingValue;  // 첫 번째 항목은
    // 매개변수로써 서브루틴을
    // 통과하는 어떠한 값임.

    count = 1; // 지금까지 하나의 항목, 즉 시작 값만 있음.

    System.out.println("3N+1 순서로 " + N + " 값으로 시작");
    System.out.println();
    System.out.println(N);  // 순서의 초기 항목을 출력

    while (N > 1) {
        if (N % 2 == 1)     // N이 홀수인가?
            N = 3 * N + 1;
        else
            N = N / 2;
        count++;   // 이 항목의 수를 셈
        System.out.println(N);  // 해당 항목을 출력
    }

    System.out.println();
    System.out.println("이 순서에는 " + count + " 개의 항목이 있습니다.");

}  // print3NSequence 종료
```

이 서브루틴의 매개변수 목록인 "`(int startingValue)`"는 서브루틴에 int 자료형인 하나의 매개변수가 있음을 명시한다. 서브루틴의 본체 안에서는 변수 이름과 같은 방법으로 매개변수 이름을 사용할 수 있다. 그러나 서브루틴 정의에서 매개변수에 값을 제공하는 일은 없다는 점에 유의하라! 매개변수는 서브루틴 밖에서 초기 값을 얻는다. 서브루틴을 호출할 때 서브루틴 호출문에서 매개변수에 대한 값을 반드시 제공해야 한다. 이 값은 서브루틴 본체가 실행되기 전에 `startingValue`에 할당된다. 예를 들어 서브루틴 호출문 "`print3NSequence(17);`"을 사용하여 서브루틴을 호출할 수 있다. 컴퓨터가 이 문장을 실행하면 컴퓨터는 먼저 값 17을 `startingValue`에 할당하고 서브루틴 안의 문장을 실행한다. 이는 17부터 시작하는 3N+1 순서를 출력한다. `K`가 int 자료형의 변수라면 해당 서브루틴은 "`print3NSequence(K);`"라 하여 호출될 수도 있다. 컴퓨터가 이 서브루틴 호출문을 실행하면 변수 `K`의 값을 취하여 그 값을 `startingValue`에 할당한 다음, 서브루틴 본체를 실행한다.

`print3NSequence`를 포함하는 클래스는 `print3NSequence`를 호출하는 `main()` 루틴(또는 다른 서브루틴)을 포함할 수 있다. 예를 들어, 다음은 사용자가 지정한 다양한 시작 값에 대한 3N+1 순서를 출력하는 `main()` 프로그램이다:

```java
public static void main(String[] args) {
    System.out.println("이 프로그램은 당신이 지정한 시작 값에 대한");
    System.out.println("3N+1 순서를 출력할 것입니다.");
    System.out.println();
    int K;  // 사용자의 입력; K < 0일 때 루프 종료.
    do {
        System.out.println("시작 값을 입력하세요.");
        System.out.print("프로그램을 종료하려면, 0을 입력: ");
        K = TextIO.getInt();  // 사용자로부터 시작 값을 얻음.
        if (K > 0)   // K가 0보다 클 때에만 순서를 출력.
            print3NSequence(K);
    } while (K > 0);   // K > 0일 때에만 계속.
} // main() 종료
```

이 프로그램을 사용하기에 앞서, `main` 및 `print3NSequence`의 정의들 모두 클래스 정의 안에 반드시 포함되어야 한다는 점을 기억하라.

<hr>

## 2. 형식적 및 실질적 매개변수
"매개변수(parameter)"라는 용어는 서로 다르지만 관련된 두 가지 개념을 가리키기 위해 사용된다는 점에 유의하라. 위의 예에서 `startingValue`와 같이 서브루틴의 정의에서 사용되는 매개변수가 있다. 그리고 "`print3NSequence(K);`"라는 문장의 `K`와 같이 서브루틴 호출문에 사용되는 매개변수도 있다. 서브루틴 정의에서 매개변수를 **형식적 매개변수(formal parameter)** 또는 **더미 매개변수(dummy parameter)** 라고 한다. 서브루틴이 호출될 때 서브루틴으로 전달되는 매개변수를 **실질적 매개변수(actual parameter)** 또는 **인수(argument)** 라고 한다. 서브루틴이 호출되면 서브루틴 호출문의 실질적 매개변수가 평가되고 서브루틴 정의에 있는 형식적 매개변수에 해당 값을 할당한다. 그런 다음 서브루틴의 본체가 실행된다.

형식적 매개변수는 반드시 **이름(name)**, 즉 단순 식별자여야 한다. 형식적 매개변수는 변수와 매우 유사하며, 변수와 마찬가지로 int, boolean, String 또는 double[]와 같은 지정된 자료형을 가진다. 실질적 매개변수는 값(value)이므로 올바른 자료형의 값을 계산하는 어떤 표현식으로도 지정될 수 있다. 실질적 매개변수의 자료형은 할당문으로 형식적 매개변수에 할당할 수 있는 허용되는 자료형이어야 한다. 예를 들어, 형식적 매개변수가 double 자료형인 경우, int는 double로 할당될 수 있으므로 실질적 매개변수로 int를 전달하는 것은 허용된다. 서브루틴을 호출할 때, 서브루틴 정의에 있는 각각의 형식적 매개변수에 대응하는 실질적 매개변수를 제공해야 한다. 예를 들어, 다음과 같은 서브루틴을 생각해보자:

```java
static void doTask(int N, double x, boolean test) {
    // 작업을 수행할 문장들이 여기에 이어짐
}
```

이 서브루틴은 다음 문장으로 호출될 수 있다:

```java
doTask(17, Math.sqrt(z+1), z >= 10);
```

컴퓨터가 해당 문장을 실행할 때, 이는 본질적으로 블록문과 같은 효과를 가진다:

```java
{
    int N;       // 형식적 매개변수에 관한 메모리 위치를 할당.
    double x;
    boolean test;
    N = 17;              // 첫 번째 형식적 매개변수 N에 17을 할당.
    x = Math.sqrt(z+1);  // Math.sqrt(z+1)을 계산하고, 이를
                        // 두 번째 형식적 매개변수 x에 할당.
    test = (z >= 10);    // "z >= 10"을 평가하고 그 결과인
                        // true/false 값을 세 번째 형식적
                        // 매개변수 test에 할당.
                        // 작업을 수행할 문장들이 여기에 이어짐
}
```

(이와 "`doTask(17,Math.sqrt(z+1),z>=10);`" 사이에는 몇 가지 기술적인 차이점들 — 타이핑되는 횟수를 제외하더라도 — 이 있다. 변수의 범위 및 여러 변수나 매개변수가 동일한 이름을 가질 때 일어나는 일에 관한 문제들 때문이다.)

프로그래밍을 시작하는 학생들은 종종 매개변수가 놀라울 정도로 혼란스럽다고 생각한다. 이미 존재하는 서브루틴을 호출하는 것은 문제가 되지 않는다 — 매개변수로 서브루틴에 정보를 제공한다는 개념은 충분히 명확하다. 서브루틴 정의를 작성하는 것은 또 다른 문제다. 일반적인 초보자의 실수는 서브루틴의 시작에 있는 형식적 매개변수에 값을 할당하거나, 사용자에게 값을 입력하도록 요구하는 것이다. **이는 근본적인 오해를 나타낸다.** 컴퓨터가 서브루틴의 문장을 실행하기 시작할 때쯤이면, 형식적 매개변수들은 **이미** 초기 값을 할당받았다는 점이다! 컴퓨터는 서브루틴 안에서 코드를 실행하기 전에 자동적으로 값을 형식적 매개변수에 할당한다. 해당 값은 서브루틴 호출문에 있는 실질적 매개변수에서 나온다. 서브루틴은 독립적이지 않다는 점을 기억하라. 이는 몇몇의 다른 루틴에 의해 호출되며, 매개변수에 대한 적절한 값을 제공하는 것은 서브루틴 호출문의 책임이다.

<hr>

## 3. 오버로딩
서브루틴을 허용되는 방식으로 호출하려면 서브루틴의 이름을 알아야 하고, 형식적 매개변수가 몇 개인지 알아야 하며, 각 매개변수의 자료형을 알아야 한다. 이러한 정보를 서브루틴의 시그니처(signature1)이라고 한다. 위의 예에서 사용된 서브루틴 `doTask`의 시그니처는 다음과 같이 표현될 수 있다: `doTask(int,double,boolean)`. 시그니처에 매개변수의 이름이 포함되지 **않는다**는 점에 유의하라: 사실, 그저 서브루틴을 **사용**하길 바란다면 형식적 매개변수의 이름이 무엇인지는 알 필요가 없으므로, 해당 이름들은 인터페이스의 부분이 아닌 것이다.

자바는 시그니처가 다르다면, 같은 클래스의 서로 다른 서브루틴 두 개가 동일한 이름을 가지는 것을 허용한다는 점에서 다소 이례적이다. 이렇게 되면 서브루틴의 명칭이 여러 가지 다른 의미를 가지기 때문에 서브루틴이 **오버로드되었다(overloaded)** 고 한다. 컴퓨터는 서브루틴을 혼동하지 않는다. 이는 서브루틴 호출문에서 제공하는 실질적 매개변수의 수와 자료형을 통해 어떤 것을 호출할 것인지를 알 수 있다. 이미 System.out 에 오버로딩이 사용되는 것을 보았을 것이다. 예를 들어, 이 객체는 `println`이라는 이름의 다른 많은 메서드들을 포함한다. 이러한 메서드들은 모두 다음과 같이 서로 다른 시그니처를 가진다:

```java
println(int)                   println(double)
println(char)                  println(boolean)
println()
```

컴퓨터는 당신이 제공하는 실질적 매개변수의 자료형을 기반으로 당신이 사용하길 원하는 서브루틴이 무엇인지를 알고 있다. `System.out.println(17)`은 서브루틴을 시그니처 `println(int)`으로 호출하는 반면, `System.out.println('A')`은 시그니처 `println(char)`으로 서브루틴을 호출한다. 물론 이 다른 모든 서브루틴들은 의미론적으로 연관되어 있으며, 그렇기에 이들 모두에게 동일한 이름을 사용하는 것은 허용되는 프로그래밍 스타일이다. 그러나 컴퓨터에 관한 한, int를 출력하는 것은 char를 출력하는 것과는 매우 다르며, 이는 boolean을 출력하는 것과 또 다르고, 그런 식이다 — 그렇기에 이러한 연산들은 각각 다른 서브루틴을 필요로 한다.

그건 그렇고, 시그니처에는 서브루틴의 반환 자료형이 포함되지 않는다는 점에 유의하라. 시그니처는 같지만 반환 자료형이 다른, 동일한 클래스 안의 서브루틴 두 개를 가지는 것은 허용되지 않는다. 예를 들어, 다음과 같이 정의된 두 개의 서브루틴을 포함하는 클래스는 구문 오류가 될 수 있다:

```java
int    getln() { ... }
double getln() { ... }
```

이것이 바로 TextIO 클래스에서, 다른 자료형을 읽기 위한 서브루틴들이 전부 `getln()`으로 명명되지 않은 까닭이다. 주어진 클래스에서, 매개변수 없이 `getln`이라는 이름을 가진 하나의 루틴만이 있을 수 있다. 따라서, TextIO 안의 입력 루틴들은 `getlnInt()`와 `getlnDouble()`과 같이 다른 이름을 가짐으로써 구별된다.

## 4. 서브루틴 예제
할당된 작업을 수행하기 위한 작은 서브루틴을 작성하는 몇 가지 예제를 살펴보자. 물론 이는 서브루틴을 이용한 프로그래밍의 한 측면일 뿐이다. 서브루틴에서 수행하는 작업은 언제나 더 큰 프로그램의 하위 작업(subtask)이다. 이러한 프로그램들을 설계하는 — 이들을 하위 작업으로 어떻게 나누는지를 결정하는 — 기술(art)이 서브루틴을 사용하는 프로그래밍의 다른 측면이다. 제4장 제7절의 프로그램 설계 문제에서 이를 다시 다룰 것이다.

첫 번째 예제로, 주어진 양의 정수의 모든 약수들을 계산하고 출력하는 서브루틴을 작성해보자. 해당 정수는 서브루틴에 대한 매개변수가 될 것이다. 서브루틴의 구문은 다음과 같음을 기억하라:

```java
{modifiers} {return-type} {subroutine-name} ({parameter-list}) {
      {statements}
}
```

서브루틴을 작성한다는 것은 항상 이러한 형식을 채우는 것을 의미한다. 이 경우, 문제의 문장은 우리에게 int 자료형인 하나의 매개변수가 있다는 것을 알려주고, 이는 서브루틴 본체에 있는 문장들이 무엇을 해야 하는지를 알려준다. 지금은 정적 서브루틴만을 다루고 있기 때문에, `static`을 제한자로 사용해야 할 것이다. 액세스 제한자(`public` 또는 `private`)를 추가할 수도 있겠지만, 필자는 어떠한 지시도 없는 경우에는 이를 생략할 것이다. 값을 반환하라는 말은 없었기 때문에 반환 자료형은 `void`가 된다. 이름이 지정되어 있지 않기 때문에 형식적 매개변수와 서브루틴 자체에 대한 이름을 만들어야 한다. 필자는 매개변수로 N을 사용하고 서브루틴 이름으로 `printDivisors`를 사용할 것이다. 서브루틴은 다음과 같이 보일 것이다:

```java
static void printDivisors ( int N ) {
    statements
}
```

그리고 남은 할 일은 루틴의 본체를 구성하는 문장들을 작성하는 것뿐이다. 이는 어렵지 않다. 단지 `N`이 이미 값을 가지고 있다고 가정하여 본체를 작성해야 한다는 점을 기억하라! 해당 알고리즘은: "1부터 `N`까지의 범위에서 가능한 각각의 약수 D에 대하여, 만약 D가 N을 균등하게 나누면 D를 출력한다." 이를 자바로 작성하면 다음과 같다:

```java
/**
* N의 모든 약수를 출력한다.
* N이 양의 정수라고 가정한다.
*/
static void printDivisors( int N ) {
    int D;   // N의 가능한 약수들 중 하나.
    System.out.println("양의 정수 " + N + " 의 약수들은:");
    for ( D = 1; D <= N; D++ ) {
        if ( N % D == 0 )  // D가 N을 균등하게 나누는가?
            System.out.println(D);
    }
}
```

필자는 서브루틴 정의 앞에 서브루틴의 계약(contract) — 즉 서브루틴이 무엇을 하는지와 어떤 가정을 하는지를 나타내는 주석을 추가했다. 계약에는 `N`이 양의 정수라는 가정이 포함되어 있다. 이 가정이 충족되는지 확인하는 것은 서브루틴의 호출자(caller)에게 달려 있다.

두 번째 짧은 예제로, 다음 문제를 생각해보자: `printRow`라는 이름의 `private` 서브루틴을 작성하라. 이는 char 자료형의 매개변수 `ch`와 int 자료형의 매개변수 N을 가져야 한다. 서브루틴은 문자 `ch`의 N개 복사본들이 포함된 한 줄의 텍스트를 출력해야 한다.

여기서 서브루틴의 이름과 두 매개변수의 이름이 주어지고 서브루틴이 `private`라는 말을 듣게 되므로, 서브루틴 정의의 첫 번째 행에 대해서는 선택의 여지가 별로 없다. 이 경우의 일은 꽤나 단순하기에, 서브루틴의 본체는 작성하기 쉽다. 완전한 서브루틴은 다음과 같이 제시될 것이다:

```java
/**
* 문자 ch의 N개 복사본들을 가지는 한 줄의 출력을 작성한다.
* 만약 N <= 0이라면, 빈 줄이 출력이 된다.
*/
private static void printRow( char ch, int N ) {
    int i;  // 사본들의 수를 세는 루프 제어 변수.
    for ( i = 1; i <= N; i++ ) {
        System.out.print( ch );
    }
    System.out.println();
}
```

이 경우, `N`에 관하여 계약은 어떠한 가정도 하지 않지만, `N <= 0`이라는 예기치 않은 경우를 포함하여 모든 경우에 있어 어떤 일이 일어날지를 분명히 한다는 점에 유의하라.

마지막으로, 한 서브루틴이 다른 서브루틴에 어떻게 구축될 수 있는지를 보여주는 예를 들어본다. String 을 매개변수로 사용하는 서브루틴을 작성하자. 이는 문자열의 각 문자에 대하여, 해당 문자의 25개 복사본을 포함하는 한 줄을 출력해야 한다. 이는 출력을 생성하기 위해 `printRow()` 서브루틴을 사용해야 한다.

다시금, 서브루틴의 이름과 매개변수의 이름을 선택하게 된다. 필자는 서브루틴 `printRowsFromString`과 매개변수 `str`을 호출할 것이다. 알고리즘은 꽤나 명확하다: 문자열 `str`의 각 위치 `i`에 대하여, `printRow(str.charAt(i),25)`를 호출하여 출력될 한 줄을 인쇄한다. 그리하여, 다음을 얻게 된다:

```java
/**
* str의 각 문자에 대하여, 해당 문자의
* 25개 복사본들을 포함하는 출력될 한 줄을 작성한다.
*/
private static void printRowsFromString( String str ) {
    int i;  // 복사본들의 수를 세는 루프 제어 변수.
    for ( i = 0; i < str.length(); i++ ) {
        printRow( str.charAt(i), 25 );
    }
}
```

그런 다음 `main()` 루틴 안에 `printRowsFromString`을 다음과 같이 사용할 수 있다:

```java
public static void main(String[] args) {
    String inputLine;  // 사용자가 입력한 텍스트 줄.
    System.out.print("텍스트 줄을 입력하세요: ");
    inputLine = TextIO.getln();
    System.out.println();
    printRowsFromString( inputLine );
}
```

물론 `main()`, `printRowsFromString()`, `printRow()`라는 세 가지 루틴은 동일한 클래스 안에서 함께 모여야 할 것이다. 해당 프로그램은 다소 쓸모는 없지만, 서브루틴의 사용을 정말로 시연한다. 한 번 살펴보려면 RowsOfChars.java 파일에서 해당 프로그램을 찾을 수 있다.

## 5. 배열 매개변수
매개변수의 자료형은 배열 자료형일 수도 있다. 이는 값들의 전체적인 배열이 단일 매개변수로써 서브루틴으로 전달될 수 있다는 것을 의미한다. 예를 들어, 서브루틴이 정수 배열 안의 모든 값을 쉼표(comma)로 구분하고 한 쌍의 대괄호로 묶어서 인쇄하는 것을 바란다고 하자. 인쇄할 배열을 지정하려면 서브루틴에 int[] 자료형의 매개변수가 있어야 한다:

```java
static void printValuesInList( int[] list ) {
    System.out.print('[');
    int i;
    for ( i = 0; i < list.length; i++ ) {
        if ( i > 0 )
            System.out.print(','); // list[0] 앞에는 쉽표가 없음
        System.out.print(list[i]);
    }
    System.out.println(']');
}
```

이 서브루틴을 사용하려면, 진짜인 배열이 필요하다. 서브루틴에 대한 인수로써 전달되는 배열을 생성하는, 매우 현실적이지는 않지만 허용되는 코드 조각이 여기에 있다:

```java
int[] numbers;
numbers = new int[3];
numbers[0] = 42;
numbers[1] = 17;
numbers[2] = 256;
printValuesInList( numbers );
```

마지막 문장에 의해 생성된 출력은 `[42,17,256]`이 될 것이다.

## 6. 명령줄 인수
프로그램의 `main` 루틴은 String[] 자료형의 매개변수를 가진다. `main` 루틴이 호출될 때, 매개변수의 값으로 몇몇 실제의 String 배열이 `main()`으로 반드시 전달되어야 한다. 시스템은 `main()`을 호출할 때 실제의 매개변수를 제공하고, 그 값은 프로그램 외부에서 나온다. 배열의 해당 문자열은 어디에서 왔으며, 이들은 무엇을 의미하는가? 배열의 문자열은 프로그램을 실행하는 데 사용된 명령에서 나온 **명령줄 인수(command-line argument)** 이다. 명령줄 인터페이스를 사용할 때 사용자는 명령을 입력하여 시스템에서 프로그램을 실행하도록 지시한다. 사용자는 프로그램 이름 이외의 추가적인 입력을 이 명령에 포함시킬 수 있다. 이 추가 입력이 명령줄 인수가 된다. 시스템은 명령줄 인수를 가져와 문자열의 배열에 넣은 다음, 해당 배열을 `main()`으로 전달한다.

예를 들어 프로그램 이름이 `myProg`인 경우 사용자는 "`java myProg`"를 입력하여 프로그램을 실행할 수 있다. 이 경우에는 명령줄 인수가 없다. 그러나 사용자가 다음 명령을 입력하는 경우에:

```java
java myProg one two three
```

그러면 명령줄 인수는 문자열 "one", "two", 그리고 "three"이다. 시스템은 이러한 문자열을 String 배열에 넣고 해당 배열을 매개변수로 `main()` 루틴에 전달한다. 예를 들어, 사용자가 입력한 명령줄 인수를 간단히 출력하는 짧은 프로그램이 여기에 있다:

```java
public class CLDemo {

    public static void main(String[] args) {
        System.out.println("당신은 " + args.length
            + " 개의 명령줄 인수를 입력하였습니다.");
        if (args.length > 0) {
            System.out.println("이들은:");
            int i;
            for ( i = 0; i < args.length; i++ )
                System.out.println("   " + args[i]);
        }
    } // main() 종료

} // 클래스 CLDemo 종료
```

해당 매개변수 `args`는 길이 0의 배열일 수도 있다는 점에 유의하라. 이는 바로 프로그램을 실행할 때 사용자가 어떤 명령줄 인수도 포함시키지 않았음을 의미한다.

실제로 명령줄 인수는 파일들의 이름을 프로그램에 전달하기 위해 종종 사용된다. 예를 들어, 텍스트 파일의 복사본을 만드는 다음 프로그램을 생각해보자. TextIO 를 사용하여 원본 파일에서 복사본으로 한 번에 한 줄씩 복사함으로써 이것이 이루어진다. `TextIO.eof()` 함수는 파일 끝에 도달한 경우 `true`인 부울 값 함수다.

```java
input textio.TextIO;

/**
*  두 개의 명령줄 인수가 요구되며, 이들은 반드시 파일 이름들이어야 한다.
*  첫 번째는 반드시 존재하는 파일의 이름이어야 한다.
*  두 번째는 프로그램에 의해 생성되는 파일의 이름이다.
*  첫 번째 파일의 내용이 두 번째로 복사된다.
*  경고: 프로그램이 실행될 때 두 번째 파일이 이미 존재한다면, 기존 내용이 삭제될 것이다!
*  이 프로그램은 평문(plain) 텍스트 파일에만 작동한다.
*/
public class CopyTextFile {

    public static void main( String[] args ) {
        if (args.length < 2 ) {
            System.out.println("두 개의 명령줄 인수가 요구됩니다!");
            System.exit(1);
        }
        TextIO.readFile( args[0] );   // 원본 파일을 열어서 읽는다.
        TextIO.writeFile( args[1] );  // 쓰기 위해 복사본 파일을 연다.
        int lineCount;  // 복사될 행들의 갯수
        lineCount = 0;
        while ( TextIO.eof() == false ) {
            // 원본 파일에서 한 줄을 읽어 복사본에 이를 쓴다.
            String line;
            line = TextIO.getln();
            TextIO.putln(line);
            lineCount++;
        }
        System.out.printf( "%d 개의 줄이 %s 에서 %s로 복사됨.%n",
        lineCount, args[0], args[1] );
    }

}
```
요즘에는 대부분의 프로그램이 GUI 환경에서 실행되기 때문에, 명령줄 인수가 예전만큼 중요하지는 않다. 그러나 이들은 적어도 배열 매개변수를 어떻게 사용할 수 있는지에 대한 좋은 예시를 제공한다.

<hr>

## 7. 예외 던지기
필자는 서브루틴의 "계약"에 대해 언급해왔다. 서브루틴의 호출자가 서브루틴의 매개변수에 대하여 허용되는 값을 제공한다면 서브루틴이 무엇을 할 것인지를 계약이 알려주는 것이다. 그러나 의문은 떠오르는데, 호출자가 잘못된 매개변수 값을 제공하여 계약을 위반한 경우에 서브루틴은 무엇을 해야 하는가?

이미 몇몇 서브루틴이 잘못된 매개변수 값에 대하여 예외를 던짐으로써 이에 반응하는 것을 보았을 것이다. (제3장 제7절 참조.) 예를 들어 내장 서브루틴 `Double.parseDouble`의 계약에는 여러 개의 double 자료형의 문자열로 매개변수가 표현되어야 한다고 되어 있다; 만약 참이라면 해당 서브루틴은 문자열을 동등한 숫자 값으로 변환한다. 호출자가 유효하지 않은 문자열을 실제의 매개변수로 전달하여 계약을 위반할 경우, 서브루틴은 NumberFormatException 자료형의 예외를 던져 응답한다.

많은 서브루틴들이 잘못된 매개변수 값에 대한 대응으로 llegalArgumentException 을 던진다. 당신 자신의 서브루틴에서도 이와 같이 하고 싶을 것이다. 이를 **던지기 문장(throw statement)** 으로 할 수 있다. 예외는 객체이며, 예외를 던지려면 예외 객체를 반드시 만들어야 한다. 제5장까지는 공식적으로 이에 대한 방법을 배우지 않겠지만, 현재로서는 IllegalArgumentException 을 던지는 `throw` 문에 관한 다음과 같은 구문을 사용할 수 있다:

```java
throw new IllegalArgumentException({error-message});
```

여기서 {error-message}는 탐지된 오류를 설명하는 문자열이다. (이 문장에서 "new"라는 단어는 객체를 만드는 것이다.) 서브루틴에서 이 문장을 사용하려면 매개변수의 값이 허용되는지를 확인해야 한다. 만약 그렇지 않다면, 예외를 둘 것이다. 예를 들어, 이 절의 시작에 있는 서브루틴 `print3NSequence`을 생각해보자. `print3NSequence`의 매개변수는 양의 정수여야 한다. 서브루틴 정의를 수정하여 이 조건이 위반될 때 예외를 던지도록 할 수 있다:

```java
static void print3NSequence(int startingValue) {

    if (startingValue <= 0)  // 계약이 위반되었다!
        throw new IllegalArgumentException( "시작 값은 반드시 양수여야 합니다." );
    .
    .  // (서브루틴의 나머지는 이전과 동일하다.)
    .
```

시작 값이 잘못된 경우 컴퓨터는 `throw` 문을 실행한다. 이렇게 하면 서브루틴 본체의 나머지 부분을 실행하지 않고 해당 서브루틴을 즉시 중단시키게 된다. 게다가 제3장 제7절에서 논의한 바와 같이, 이 예외가 `try..catch` 문에 의해 "포착"되어 프로그램의 다른 곳에서 처리되지 않는 한, 프로그램 전체는 멈출 것이다. 이를 작동시키려면 서브루틴 호출이 문장의 "try" 부분에 있어야 할 것이다.

<hr>

## 8. 전역 및 지역 변수
이제 서브루틴 내부에서 사용할 수 있는 세 가지 다른 종류의 변수들에 대해 언급함으로써 매개변수에 관한 이 절을 마치고자 한다: 서브루틴 안에서 선언되는 지역 변수(local variable), 형식적 매개변수 이름(formal parameter name), 그리고 서브루틴 밖에서 선언되는 정적 멤버 변수(static member variable).

지역 변수는 외부 세계와 연관성이 없다; 이들은 순전히 서브루틴이 하는 내부 작업의 일부분이다.

매개변수는 호출될 때 서브루틴에 값을 "떨어뜨리는(drop)" 데 사용되지만, 서브루틴이 실행되기 시작하면 매개변수는 지역 변수처럼 작동을 한다. 서브루틴 내부에서 이루어진 매개변수에 대한 변경은 프로그램의 나머지 부분에는 영향을 미치지 않는다(적어도 매개변수의 자료형이 원시 자료형 중 하나일 경우에는 그러하며 — 나중에 보게 될 것처럼 배열와 객체의 경우에는 더욱 복잡하다).

서브루틴이 서브루틴 외부에서 정의된 변수를 사용할 때에는 상황이 달라진다. 이 변수는 서브루틴과 독립적으로 존재하며 프로그램의 다른 부분에서도 이에 접근할 수 있다. 이러한 변수는 서브루틴 내부에 정의된 지역 변수와 대비하여 서브루틴에 대하여 **전역적(global)** 이라고 한다. 전역 변수는 이것이 정의된 전체 클래스에서 사용할 수 있으며, `private`가 아닌 경우라면 다른 클래스에서도 사용할 수 있다. 전역 변수에 대한 변경은 해당 변경이 이루어지는 서브루틴의 외부로 확장되는 효과를 가질 수 있다. 이것이 어떻게 작동하는지는 이전 절의 마지막 예에서 보았는데, 여기서 전역 변수 `gamesPlayed` 및 `gamesWon`의 값들은 서브루틴 안에서 계산되고 `main()` 루틴 안에서 사용되었다.

서브루틴에서 전역 변수를 사용하는 것이 항상 나쁜 일은 아니지만, 전역 변수는 서브루틴 인터페이스의 일부로 간주되어야 한다는 점을 깨달아야 한다. 서브루틴은 전역 변수를 사용하여 프로그램의 나머지 부분과 소통한다. 이는 매개변수를 통해 이루어지는 소통보다 가시성이 떨어지는 일종의 은밀한(sneaky) 백도어(back-door) 소통으로, 블랙박스의 인터페이스는 직선적이고 이해하기 쉬워야 한다는 규칙을 위반할 위험이 있다. 따라서 서브루틴에서 전역 변수를 사용하기 전에, 이것이 반드시 필요한지를 고려해야 한다.

필자는 서브루틴 안에서 전역 변수를 사용하는 것에 대해 절대적으로 반대라고 충고하지는 않는다. 적어도 한 가지 좋은 이유가 있다: 만약 클래스 전체를 블랙박스의 일종으로 생각한다면, 그 상자 안의 서브루틴들이 서로 의사소통하는 일이 약간은 은밀하게 되도록 내버려두는 것이 매우 합리적일 수도 있다. 만약 이로써 클래스 전체를 외부에서 볼 때 보다 단순하게 한다면 말이다.


