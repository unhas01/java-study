# Section 5: 람다 표현식

실행 중인 프로그램에서 서브루틴은 컴퓨터의 메모리 어딘가에 저장된 이진수들(명령어들을 표현하는)의 한 묶음일 뿐이다. 0과 1의 긴 문자열로 간주되는 서브루틴은 예를 들어 정수, 문자열 또는 배열과 같은 데이터 값들과 크게 다르지 않아 보이며, 이들 또한 메모리에 있는 0과 1의 문자열로 표현된다. 서브루틴과 데이터가 매우 다르다고 생각하는 것에 익숙하지만, 컴퓨터 내부에서 서브루틴은 단지 다른 종류의 데이터일 뿐이다. 몇몇 프로그래밍 언어는 서브루틴을 데이터 값의 일종으로 다룰 수 있게 한다. 자바 8에서, 이런 능력은 **람다 표현식(lambda expression)** 이라는 형태로 자바에 추가되었다.

람다 표현식은 자바 프로그램에서 점점 더 흔해지고 있다. 특히 JavaFX GUI 툴킷을 다룰 때 이들은 유용하며, 제6장에서 GUI 프로그래밍을 다루기 전에 이들을 아는 것은 유용할 것이다. 하지만, 제5장이 끝날 때까지는 이들과 다시 마주하진 않을 것이므로, 원한다면 일단 이 부분을 건너뛸 수 있다.

<hr>

## 1. 1급 함수
람다(Lambda)는 수학자 알론조 처치(Alonzo Church)가 계산 가능한 함수들을 연구하면서 사용한 그리스 알파벳 문자다. 그의 람다 표기법은 함수에 이름을 붙이지 않고도 함수를 정의할 수 있게 한다. 예를 들어, 표기법 x2는 숫자를 제곱하는 함수를 나타내는 완벽하게 훌륭한 방법이라고 생각할 수 있지만, 사실 이는 x 를 제곱한 결과를 나타내는 표현식으로, x 가 무엇을 나타내는가에 대한 문제를 열어두고 있다. x 를 함수의 더미 매개변수로 정의할 수 있다:

```java
static double square( double x ) {
    return x*x;
}
```

하지만 이렇게 하려면 함수에 square 라는 이름을 붙여야만 했고, 해당 함수는 프로그램의 영구적인 부분이 되어 버린다 — 해당 함수를 그저 한 번만 사용하기를 원한다면 이는 과잉(overkill)이다. 알론조 처치는 "x2에 의해 주어진 x 의 함수"를 나타내기 위해 lambda(x).x2라는 표기법을 도입했다("lambda"라는 단어 대신 그리스 문자를 사용한 것은 제외하고). 이 표기법은 42가 int 자료형의 값을 나타내는 정수 리터럴인 것과 같은 방식으로 자료형 "function"의 값을 나타내는 함수 리터럴의 일종이다.

함수 리터럴을 갖는 것은 함수를 그저 또 다른 종류의 데이터 값으로 생각하는 출발점이다. 일단 그렇게 생각하면, 변수에 함수를 할당하거나, 서브루틴에 매개변수로 함수를 전달하거나, 서브루틴 값으로 함수를 반환하거나, 또는 심지어 함수의 배열까지 만드는 등, 다른 값들로 할 수 있는 일을 함수로도 할 수 있어야 한다. 이러한 모든 것을 함수로 할 수 있게 하는 프로그래밍 언어는 "1급(first-class) 함수"나 "1급 객체로서의 함수"를 가지고 있다고 한다.

사실, 자바의 람다 표현식으로 이러한 모든 것을 할 수 있다. 자바의 표기법은 알론조 처치가 사용하던 표기법과 다르며, "람다 표현식"이라는 이름에도 불구하고 람다라는 단어조차 사용하지 않는다. 자바에서 위와 같은 제곱 함수에 대한 람다 표현식은 다음과 같이 작성할 수 있다:

```java
x -> x*x
```

연산자 `->`가 이를 람다 표현식으로 만든다. 함수에 대한 더미 매개변수는 연산자의 왼쪽에 있고, 함수의 값을 계산하는 표현식은 오른쪽에 있다. 이와 같은 표현식이 실제의 매개변수로 서브루틴에 전달되거나, 변수에 할당되거나, 함수에 의해 반환되는 것을 보았을 것이다.

그러면 현재 자바에서 함수들은 1급인가? 필자는 꽤나 확신할 수가 없다. 다른 언어에서는 할 수 있지만 자바에서는 할 수 없는 몇몇 멋진 일들이 있다. 예를 들어, 자바에서는 sqr 이라는 이름의 변수에 위의 표현식을 할당할 수 있지만, sqr 을 마치 실제 함수처럼 사용할 수는 없다. 예를 들어, sqr(42)이라고 할 수 없다. 문제는 정말로, 자바는 엄격한 형태의(strongly typed) 언어라는 것이다; sqr 이라는 변수를 가지기 위해서는 해당 변수를 선언하고 자료형을 주어야 한다. 그러나 값이 함수인 것에는 어떤 종류의 자료형이 적합할까? 자바의 답은 **함수적 인터페이스(functional interface)** 라고 불리는 것으로, 다음에 이룰 다룰 것이다.

하지만 우선, 한 가지를 덧붙이자면: 자바의 람다 표현식은 함수뿐만 아니라 실제로 임의의 서브루틴을 나타낼 수도 있다. 그럼에도 불구하고 "서브루틴(subroutine)"이나 "메서드(method)"가 아닌 "함수(function)"란 용어가 통상적으로 이들과 연관된다.

<hr>

## 2. 함수적 인터페이스
서브루틴의 허용되는 사용 방법을 알기 위해서는 서브루틴의 이름, 필요한 매개변수의 수, 그 자료형, 서브루틴의 반환 자료형을 알아야 한다. 함수적 인터페이스는 하나의 서브루틴에 대한 이러한 정보를 명시한다. 함수적 인터페이스는 클래스와 유사하며 클래스처럼 .java 파일로 정의될 수 있다. 그러나, 그 내용은 그저 단일 서브루틴을 위한 명세(specification)에 불과하다. 예를 들면 다음과 같다:

```java
public interface FunctionR2R {
    double valueAt( double x );
}
```

이 코드는 FunctionR2R.java 라는 이름의 파일 안에 있을 것이다. 이는 double 자료형의 한 매개변수와 반환 자료형 double을 가진, valueAt 이란 이름의 함수를 명시한다. (매개변수의 **이름**인 x 는 실제로는 명세의 일부가 아니며, 이것이 저기에 있어야 한다는 점은 다소 성가시다.) 여기 또 다른 예가 있다:

```java
public interface ArrayProcessor {
    void process( String[] array, int count );
}
```

자바에는 많은 표준 함수적 인터페이스가 있다. 가장 중요한 것 중 하나는 Runnable 이란 이름의 매우 단순한 것으로 자바에는 이미 다음과 같이 정의되어 있다:

```java
public interface Runnable {
    public void run();
}
```

필자는 이 절의 예제에서 이러한 세 가지 함수적 인터페이스를 사용할 것이다.

자바의 "인터페이스(interface)"는 함수적 인터페이스보다 훨씬 더 복잡할 수 있다. 제5장 제7절에서 이들에 대해 더 배울 것이다. 그러나 람다 표현식과 관련이 있는 것은 오직 함수적 인터페이스뿐이다: 함수적 인터페이스는 람다 표현식으로 표현될 수 있는 서브루틴에 대한 템플릿(template)을 제공한다. 함수적 인터페이스의 이름은, String 과 double이 자료형인 것과 같이 **자료형(type)** 이다. 즉, 변수와 매개변수를 선언하고 함수의 반환 자료형을 지정하는 데 이를 사용할 수 있다. 자료형이 함수적 인터페이스인 경우, 해당 자료형의 값은 람다 표현식으로 지정될 수 있다.

<hr>

## 3. 람다 표현식
람다 표현식은 익명의, 즉 이름이 없는 서브루틴을 나타낸다. 그러나 이는 형식적 매개변수 목록과 정의를 정말로 가지고 있다. 전체 구문은 다음과 같다:

```java
( parameter-list ) -> { statements }
```

일반적인 서브루틴과 마찬가지로 {parameter-list}는 비어 있거나, 쉼표(comma)로 구분된 매개변수 선언의 목록이 될 수 있으며, 여기서 각각의 선언은 매개변수 이름이 뒤따르는 자료형으로 구성된다. 그러나 구문은 종종 단순화될 수 있다. 무엇보다도, 문맥에서 추론할 수 있는 한 매개변수 자료형이 생략될 수 있다. 예를 들어, 람다 표현식이 FunctionR2R 자료형인 것으로 알려진 경우, 매개변수 자료형은 double이어야 하므로 람다 표현식에 매개변수 자료형을 지정할 필요가 없다. 다음으로, 매개변수가 정확히 하나 존재하고 그 자료형이 명시되지 않은 경우, 매개변수 목록 주변의 괄호를 생략할 수 있다. `->`의 오른쪽에서, 중괄호 { 및 } 사이에 있는 유일한 것이 단일 서브루틴 호출문이라면, 중괄호는 생략될 수 있다. 그리고 오른쪽이 `{ return expression; }`의 형식을 가진다면, {expression}을 제외한 모든 것을 생략할 수 있다.

예를 들어, 람다 표현식이 double 값의 제곱을 계산하는 함수를 나타낸다고 가정하자. 그러한 함수의 자료형은 위에서 제시된 FunctionR2R 인터페이스일 수 있다. sqr 이 FunctionR2R 자료형의 변수인 경우 함수의 값은 람다 표현식이 될 수 있으며, 이는 다음의 형식 중 어느 하나로 작성될 수 있다:

```java
sqr = (double x) -> { return x*x; };
sqr = (x) -> { return x*x; };
sqr = x -> { return x*x; };
sqr = x -> x*x;
sqr = (double fred) -> fred*fred;
sqr = (z) -> z*z;
```

마지막 두 개의 문장은 람다 표현식의 매개변수 이름이 더미 매개변수라는 것을 강조하기 위한 것이다; 이들의 이름은 관련성이 없다. 이런 문장들 안에 있는 여섯 람다 표현식은 모두 정확히 같은 함수를 정의한다. 컴파일러는 `sqr`이 FunctionR2R 자료형이라는 것을 알고 있고, FunctionR2R 에는 double 자료형의 매개변수가 필요하므로 매개변수 double 자료형이 생략될 수 있다는 점에 유의하라. 람다 표현식은 컴파일러가 그 자료형을 추론할 수 있는 상황에서만 사용될 수 있으며, 매개변수 자료형은 이를 생략하면 람다 표현식의 형식이 모호해지는 경우에만 포함되어야 한다.

현재, 여기서 정의한 변수 sqr 은 자바에서 정말로는 함수가 아니다. 이는 FunctionR2R 자료형의 값으로, 인터페이스 FunctionR2R 의 정의에서 명시된 valueAt 이란 이름의 함수를 **포함하고 있음**을 의미한다. 해당 함수의 전체 이름은 sqr.valueAt 이고, 해당 함수를 호출하기 위해서는 이 이름을 사용해야 한다. 예를 들면: `sqr.valueAt(42)` 또는 `sqr.valueAt(x) + sqr.valueAt(y)`.

람다 표현식에 두 개의 매개변수가 있는 경우, 괄호는 선택적이지 않다. 다음은 ArrayProcessor 인터페이스 사용의 예로서, 다중행 정의(multiline definition)로 된 람다 표현식 또한 보여준다:

```java
ArrayProcessor concat;
concat = (A,n) -> { // (A,n) 주변의 괄호는 필수적임!
    String str;
    str = "";
    for (int i = 0; i < n; i++)
        str += A[i];
    System.out.println(str);
};  // 해당 세미콜론은 할당문의 끝을 표시한다;
// 이는 람다 표현식의 일부가 아니다.

String[] nums;
nums = new String[4];
nums[0] = "One";
nums[1] = "Two";
nums[2] = "Three";
nums[3] = "Four";
for (int i = 1; i < nums.length; i++) {
    concat.process( nums, i );
}
```

이는 다음을 출력할 것이다:

```java
One
OneTwo
OneTwoThree
OneTwoThreeFour
```

람다 표현식이 실제의 매개변수로 사용되는 경우는 더욱 흥미로운데, 이는 실제로도 가장 많이 활용되는 것이다. 예를 들어 다음의 함수가 정의되어 있다고 가정하자:

```java
/**
*  함수 f에 관하여, f(start) + f(start+1) + ... + f(end)를 계산한다.
*  마지막의 값은 시작 값보다 반드시 크거나 같아야(>=) 한다.
*/
static double sum( FunctionR2R f, int start, int end ) {
    double total = 0;
    for (int n = start; n <= end; n++) {
        total = total + f.valueAt( n );
    }
    return total;
}
```

f 는 FunctionR2R 자료형의 값이기 때문에, n 에서의 f 값은 실제로 f.valueAt(n) 으로 작성된다는 점에 유의하라. 함수 sum 이 호출되면 첫 번째 매개변수를 람다 표현식으로 지정할 수 있다. 예를 들면:

```java
System.out.print("1부터 100까지의 n에 대하여 n의 제곱의 합은 ");
System.out.println( sum( x -> x*x, 1, 100 ) );
System.out.print("1부터 10까지의 n에 대하여 2의 n승의 합은 ");
System.out.println( sum( num -> Math.pow(2,num), 1, 10 ) );
```

다른 예로, 주어진 작업을 여러 번 수행하는 서브루틴이 있다고 가정하자. 해당 작업은 Runnable 자료형의 값으로 지정될 수 있다:

```java
static void doSeveralTimes( Runnable task, int repCount ) {
    for (int i = 0; i < repCount; i++) {
    task.run();  // 작업을 수행한다!
    }
}
```

그러면 다음을 호출하여 "Hello World"를 열 번 말할 수도 있을 것이다:

```java
doSeveralTimes( () -> System.out.println("Hello World"), 10 );
```

Runnable 자료형의 람다 표현식에 관하여, 매개변수 목록이 비어있는 한 쌍의 괄호로 주어진다는 점에 유의하라. 구문이 다소 복잡해진 예는 다음과 같다:

```java
doSeveralTimes( () -> {
    // 1부터 5와 25 사이의 어떤 무작위 숫자까지 그 갯수를 센다
    int count = 5 + (int)(21*Math.random());
    for (int i = 1; i <= count; i++) {
        System.out.print(i + " ");
    }
    System.out.println();
}, 100);
```

이는 첫 번째 매개변수가 여러 행으로 확장되는 람다 표현식이 들어있는 단일 서브루틴 호출문이다. 두 번째 매개변수는 100이며, 마지막 줄의 세미콜론은 서브루틴 호출문을 종료한다.

변수에 람다 표현식을 할당하거나 표현식을 실제의 매개변수로 사용하는 예제들을 살펴보았다. 람다 표현식이 함수의 반환 값인 예는 다음과 같다:

```java
static FunctionR2R makePowerFunction( int n ) {
    return x -> Math.pow(x,n);
}
```

그렇다면 makePowerFunction(2) 는 해당 매개변수의 제곱을 계산하는 FunctionR2R 을 반환하고, makePowerFunction(10) 은 해당 매개변수의 10승을 계산하는 FunctionR2R 을 반환한다. 이러한 예는 또한 람다 표현식이 해당 매개변수 외에도 다른 변수들, 이 경우의 n 과 같은 것을 사용할 수 있음을 설명한다(비록 그것이 실행될 수 있는 시기에 관한 일부 제약이 있긴 하지만 말이다).

<hr>

## 4. 메서드 참조
람다 표현식이 FunctionR2R 자료형의 값으로 제곱근 함수를 나타낸다고 가정하자. `x -> math.sqrt(x)`처럼 이를 작성할 수 있다. 그러나 이러한 람다 표현식은 이미 존재하는 Math.sqrt 함수에 대한 단순한 포장이다. 람다 표현식을 쓰는 대신, 해당 함수는 **메서드 참조(method reference)** 로 작성될 수 있는데, 이는 `Math::sqrt` 형식을 취한다. (자바에서는, "메서드"는 "서브루틴"의 다른 말임을 떠올려라.) 이 메서드 참조는 람다 표현식에 대한 줄임말(shorthand)일 뿐이며, 위에서 정의한 sum 함수에서와 같이 람다 표현식이 사용될 수 있는 모든 곳에서 사용될 수 있다:

```java
System.out.print("1부터 100까지의 n에 대하여 n의 제곱근의 합은 ");
System.out.println( sum( Math::sqrt, 1, 100 ) );
```

여기서 새로운 표기법인 `::`을 도입하는 대신 단순히 Math.sqrt 라는 이름을 사용하면 좋겠지만, Math.sqrt 표기법은 이미 Math 클래스 안의 sqrt 라는 **변수**를 의미하는 것으로 정의되어 있다.

보다 일반적으로는, 기존의 정적 메서드를 단순히 호출하는 람다 표현식은 다음 형식의 메서드 참조로 작성할 수도 있다:

```java
{classname}::{method-name}
```
게다가, 이 표기법은 클래스보다는 객체에 있는 메서드로까지 확장된다. 예를 들어 str 이 String 이면 `str.length()` 메서드를 str 이 포함한다. 메서드 참조 str::length는 SupplyInt 자료형인 람다 표현식으로 사용될 수도 있을 것이며, 여기서 SupplyInt 는 다음의 함수적 인터페이스이다:

```java
public interface SupplyInt {
    int get( );
}
```
