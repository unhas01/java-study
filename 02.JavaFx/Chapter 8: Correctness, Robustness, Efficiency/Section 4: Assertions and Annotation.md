# Assertions & Annotations

이 섹션에서는 Java의 두 가지 기능인 Assertions과 Annoataion을 간략하게 설명한다. 

## 1. Assertions

전제 조건은 프로그램의 특정 지점에서 프로그램 실행이 해당 지점에서 올바르게 계속되기 위해 참이어야 하는 조건이다. 전제 조건이 충족되지 않을 가능성이 있는 경우 `if`문을 삽입하여 테스트하는 것이 좋다. 그러나 전제조건이 성립하지 않으면 어떻게 해야 하는가라는 질문이 생긴다. 한 가지 옵션은 예외를 발생시키는 것이다. 예외가 발견되어 프로그램의 다른 곳에서 처리되지 않은 한 프로그램이 종료된다.

물론 많은 경우에 프로그래머는 전제 조건이 성립하는지 테스트하기 위해 `if`문을 사용하는 대신 전제 조건이 성립함을 보장하는 방식으로 프로그램을 작성하려고 한다. 이 경우 테스트는 필요하지 않으며 `if`문을 피할 수 있다. 문제는 프로그래머가 완벽하지 않다는 것이다. 프로그래머의 의도에도 불구하고 프로그램에는 전제 조건을 망치는 버그가 포함될 수 있다. 따라서 적어도 프로그램 개발의 디버깅 단계에서는 결국 전제 조건을 확인하나ㅡㄴ 것이 좋다.

마찬가지로 사후 조건은 프로그램의 특정 지점 이전에 실행된 코드의 결과로 참이 되는 조건이다. 코드가 올바르게 작성되었다고 가정하면 사후 조건이 참으로 보장되지만 여기서 원하는 사후 조건이 실제고 true인지 다시 테스트하는 것은 사후 조건을 망칠 수 있는 버그를 확인하는 방법이다. 이는 디버깅 중에 바람직할 수 있는 것이다.

루프 불변과 클래스 불변에도 동일한 내용이 적용된다. 이는 프로그램의 특정 지점에서 true여야 하는 사항이다. 해당 시점에서 사실이 아니라면 프로그램에 버그가 있다는 의미이다.

프로그래밍 언어 C와 C++에는 항상 Assertion이라는 것을 프로그램에 추가하는 기능이있다. 이러한 주장은 `assert(condition)` 형식을 취하며, 여기서 조건은 boolean 표현이다. 이 조건은 프로그램의 해당 지점에서 유지되어야 하는 전제 조건 또는 사후 조건을 나탄내다. 컴퓨터는 프로그램 실행 중에 어설션을 발견하면 조건을 평가한다. 이 조건은 프로그램의 해당 지점에서 유지되어야 하는 전제 조건 또는 사후 조건을 나타낸다. 컴퓨터는 프로그램 실행 중에 어설션을 발견하면 조건을 평가한다. 조건이 거짓이면 프로그램이 종료된다. 그렇지 않으면 프로그램이 정상적으로 계속된다. 이를 통해 조건이 참이라는 프로그래머의 믿음을 테스트할 수 있다. 그것이 사실이 아니라면 이는 어설션 앞에 나온 프로그램 부분에 버그가 포함되어 있음을 나타낸다. C, C++의 어설션에 대한 한 가지 좋은 점은 컴파일 타임에 어설션을 "해제"할 수 있다는 것이다. 즉, 프로그램이 한 가지 방식으로 컴파일 되면 어설션은 컴파일된 코드에 포함된다. 프로그램이 다른 방식으로 컴파일되면 어설션은 포함되지 않는다. 디버깅하는 동안 첫 번째 형식의 컴파일이 사용되고 어설션이 켜진다. 릴리스 버전은 컴퓨터가 모든 어설션을 평가할 필요가 없기 때문에 더 효율적이다.

초기 버전의 Java에는 어설션이 없었지만 C, C++의 어설션 기능과 유사한 어설션 기능이 버전 1.4부터 Java에서 사용 가능했다. C/C++ 버전과 마찬가지로 Java 어설션은 디버깅 중에 활성화되고 일반 실행 중에는 비활성화될 수 있다. 그러나 Java에서는 컴파일 타임이 아닌 런타임에 어설션이 켜지고 꺼진다. Java 소스 코드의 어설션은 항상 컴파일된 클래스 파일에 포함된다. 프로그래밍 일반적인 방식으로 실행되면 이러한 어설션은 무시된다. 이 경우 어설션 조건은 평가되지 않으므로 프로그램에 어설션이 있어도 성능 저하가 거의 또는 전혀 없다. 프로그램이 디버깅될 때 아래에 설명된 대로 어설션이 활성화된 상태로 실행될 수 있으며 그런 다음 어설션은 버그를 찾고 식별하는 데 큰 도움이 될 수 있다.

---

Java의 어설션 문은 다음 두 가지 형식을 취한다.

```java
assert condition;
assert condition : error-message;
```

여기서 condition은 boolean 값 표현식이고 오류 메시지는 문자열 또는 String 유형의 표현식이다. `assert`라는 단어는 Java의 예약어이므로 식별자로 사용할 수 없다. 어설션문은 해당 문이 합법적인 Java의 어느 곳에서나 사용할 수 있다.

어설션이 비활성화된 상태에서 프로그램이 실행되면 어설션문은 빈 문과 동일하며 아무런 효과가 없다. 어설션이 활성화되고 프로그램에서 어설션 문이 발견되면 어설션의 조건이 평가된다. 값이 `true`이면 프로그램이 정상적으로 진행된다. 조건값이 `false`이면 `java.lang.AssertionError` 유형의 예외가 발생하고 프로그램이 중단된다. `Assertion` 문에 error-message가 포함된 경우 `AssertionError`의 메시지가 된다.

따라서 다음과 비슷하다.
```java
if (condition == false)
    throw new AssertionError(error-message);
```

단, if 문은 프로그램이 실행될 때마다 실행되고, `assert`문은 프로그램이 어설션이 활성화된 상태로 실행될 때만 실행된다. 

문제는 예외 대신 어설션을 언제 사용해야 하느냐는 것이다. 일반적인 규칙은 프로그램이 올바르게 작성된 경우 확실히 참이어야 하는 조건을 테스트하기 위해 어설션을 사용하는 것이다. 어설션은 프로그램을 테스트하여 프로그램이 올바른지 확인하고 잘못된 프로그램에서 오류를 찾는 데 유용하다. 테스트 및 디버깅 후 프로그램이 일반적인 방식으로 사용될 때 프로그램의 어설션은 무시된다. 그러나 나중에 문제가 발생하면 오류를 찾는 데 도움이 되는 어설션이 프로그램에 여전이 남아 있다. 누군가 당신에게 이런저런 일을 할 때 당신의 프로그램이 동작하지 않는다고 하면 당신은 어설션을 활상화한 상태에서 프로그램을 실행하고, 이런 저런 일을 하고, 프로그램의 어설션 문이 도움이 되길 바란다.

예를 들어 섹션 8.3.3에서 `root()`를 생각해 보자. 프로그램이 항상 유효한 인수를 사용하여 이 메서드를 호출할 것이라고 생각하면 예외 대신 어설션을 사용하여 메서드를 작성하는 것이 합리적이다.

```java
/**
 * 이차 방정식의 두 근 중 더 큰 값을 반환합니다.
 * A*x*x + B*x + C = 0.  
 * 전제 조건: A != 0 및 B*B - 4*A*C >= 0.
 */
static public double root( double A, double B, double C )  {
    assert A != 0 : "Leading coefficient of quadratic equation cannot be zero.";
    double disc = B*B - 4*A*C;
    assert disc >= 0 : "Discriminant of quadratic equation cannot be negative.";
    return  (-B + Math.sqrt(disc)) / (2*A);
}
```

프로그램이 일반적인 방법으로 실행될 때는 어설션이 확인되지 않는다. 메서드가 잘못된 인수로 호출되지 않는다는 믿음이 맞다면 어설션의 조건을 확인할 필요가 없다. 여러분의 믿음이 올바르지 않다면 테스트나 디버깅 중에 어설션이 활성화된 상태로 프로그램을 실행할 때 문제가 나타나야 한다.

`root()` 메서드가 다른 사람이 사용할 것으로 예상되는 소프트웨어 라이브러리의 일부인 경우 상황은 덜 명확하다. Oracle의 Java 문서에는 public 메서드의 계약을 확인하는 데 어설션을 사용해서는 안 된다고 조언한다. 메서드 호출자가 불법 매개 변수를 전달하여 계약을 위반하는 경우 예외가 발생해야 한다. 이는 어설션의 활성화 여부에 관계없이 계약을 실행한다. (그러나, Java 프로그래머들이 예외적으로 방법의 계약이 시행되기를 기대하는 것은 사실이지만, 어떤 경우에는 어설션 대신 사용하는 것에 대한 합리적인 주장들이 있다.) 어설션이 당신을 위한 것이라 말할 수 있다. 코드를 디버깅하는 데 도움이 되는 반면, 코드를 사용하는 사람들에게는 코드를 오용하고 있음을 경고하기 위한 예외가 있다.

반면에 사후 조건이나 불변성을 확인하기 위해 단언문을 사용하는 것은 결코 나쁠 것이 없다. 이는 버그가 없는 모든 프로그램에는 반드시 적용되는 조건이므로 어설션은 프로그램이 정상적으로 실행될 때 효율성을 저하시키지 않고 디버깅하는 동안 조건을 확인하는 자연스러운 방법이다. 사후 조건이나 불변이 `false`면 버그가 있는 것이며 이는 프로그래밍의 테스트 및 디버깅 단계에서 발견해야 하는 것이다.

---

효과를 얻으려면 프로그램이 실행될 때 어설션을 활성화해야 한다. 이를 수행하는 방법은 사용 중인 프로그래밍 환경에 따라 다르다. 일반적인 명령줄 환경에서 프로그램을 실행하는 데 사용되는 `java` 명령어에 `-enableassertions` 옵션을 추가하여 활성화한다. 

```console
$ java -enableassertions RootFinder
```

어설션이 활성화된 상태로 실행된다. 축약해서 사용할 수도 있다.

```console
$ java -ea RootFinder
```

실제로 프로그램의 일부에서만 어설션을 활성화하는 것이 가능하다. `-ea: class-name` 형식의 옵션은 지정된 클래스의 어설션만 활성화한다. `-ea`와 `:` 사이에는 공백이 없다. 패키지와 해당 하위 패키지의 모든 어설션을 활성화하려면 `-ea: package-name ...` 형식의 옵션을 사용할 수 있다. "default package"에서 활성화 하려면 `-ea:...` 하면 된다.

```console
$ java  -ea:paintutils...  -ea:drawing...  MegaPaint
```

Eclipse IDE을 사용하는 경우 실행 구성(run configuration)을 생성하여 `-ea` 옵션을 지정할 수 있다.

## 2. Annotations

"어노테이션"이라는 용어는 일반적으로 텍스트를 이해하거나 감상하는 데 도움을 주기 위해 본문에 추가되거나 본문과 함께 작성된 메모를 의미한다. 어노테이션은 책은 여백에 스스로 작성하는 메모일 수 있다. 어떤 사건의 역사적 맥락을 설명하기 위해 편집자가 오래된 소설에 추가한 각주일 수도 있다. 어노테이션은 메타 데이터 또는 메타 텍스트이다. 즉, 본문 자체의 일부가 아닌 본문에 대해 작성된 텍스트이다.

프로그램에 대한 어노테이션은 실제로 일종의 주석이다. 컴파일러는 이를 무시하므로 프로그램의 의미에 아무런 영향을 미치지 않는다. 그들은 인간 독자에게 그 의미를 설명하기 위해 존재한다. 물론 다른 컴퓨터 프로그램이 주석을 처리하는 것도 가능하다. API 문서를 생성하기 위헤 이를 사용하는 프로그램에 의해 처리되는 Javadoc 주석의 경우에 이것이 수행된다. 그러나 주석은 프로그램에 추가할 수 있는 메타데이터의 한 가지 유형일 뿐이다.

Java 5.0에서는 Java 프로그램에 대한 새로운 종류의 메타데이터를 더 쉽게 생성할 수 있도록 Java 언어에 어노테이션이라는 새로운 기능이 추가 되었다. 이로 인해 프로그래머는 프로그램에 어노테이션을 추가하는 새로운 방법을 고안하고 해당 어노테이션을 읽고 사용할 수 있는 프로그램을 작성할 수 있게 되었다.

Java 어노테이션은 어노테이션이 달린 프로그램에 직접적인 영향을 미치지 않는다. 그러나 그들은 많은 잠재적인 용도를 가지고 있다. 일부 어노테이션은 프로그래머의 의도를 보다 명확하게 만드는 데 사용된다. 이러한 어노테이션은 코드가 프로그래머의 의도와 일치하는지 확인하기 위해 컴파일러에서 검사할 수 있다. 예를 들어 `@Override` 메서드 정의에 어노테이션을 다는 데 사용할 수 있는 표준 어노테이션이다. 이는 해당 메서드가 일부 슈퍼 클래스에 정의된 것과 동일한 시그니처로 메서드를 대채한다는 의미이다. 컴파일러는 슈퍼클래스 메서드가 실제로 존재하는지 확인할 수 있다. 그렇지 않은 경우 프로그래머에게 알릴 수 있다. 이러한 방식으로 사용되는 어노테이션은 프로그래머가 나중에 버그로 찾아 헤맬 필요 없이 잠재적인 오류에 대해 미리 경고받을 수 있기 때문에 올바른 프로그램을 작성하는 데 도움이 된다. 

`@Override` 어노테이션을 사용하여 메서드 정의에 어노테이션을 추가하려면 간단히 정의앞에 배치하면 된다. 구문상 어노테이션은 `public`, `final`과 같은 내장 modifier와 거의 동일한 방식으로 사용된다.

```java
@Override
public void WindowClosed(WindowEvent evt) {
    ...
}
```

슈퍼 클래스에 `WindowClosed(WindowEvent)` 메서드가 없으면 컴파일러 오류가 발생할 수 있다. 실제로 이 예제는 메서드를 재정의하랴고 할 때 찾이 어려운 버그를 기반으로 한다. 그 당시 `@Override` 주석이 존재했다면 컴파일러는 코드를 거부하고 버그를 추적하는 수고를 던다.

(어노테이션은 상당히 고급 기능이므로 `@Override`와 같은 일부 표기법은 Eclipse에서 생성된 코드에 나타날 수 있다.)

두 가지 다른 표준 어노테이션이 있다. 하나는 `@Deprecated`로, 더 이상 사용되지 않는 클래스, 메서드 및 변수를 표시하는 데 사용할 수 있다. (더 이상 사용되지 않는 항목은 더 이상 사용되지 않는 것으로 간주되지만 이전 코드에 대한 이전 버전과의 호환성을 위해 여전히 Java 언어의 일부이다.) 이 어노테이션을 사용하면 더 이상 사용되지 않는 항목이 사용될 때 컴파일러가 경고를 생성할 수 있다.

다른 표준 어노테이션 `@SurpressWarnings`은 클래스나 메서드가 컴파일될 때 일반적으로 생성되는 경고 메시지를 끄기 위해 컴파일러에서 사용할 수 있다. `@SurpressWarnings`는 매개변수가 있는 주석의 예이다. 매개 변수는 억제할 경고 클래스를 알려준다. 

```java
@SurpressWarnings("deprecation")
```

그러면 클래스나 메서드가 컴파일될 때 더 이상 사용되지 않는 항목 사용에 대한 경고가 표시되지 않는다. 억제할 수 있는 다른 유형의 경고도 있다. 불행하게도 경고 목록과 해당 이름은 표준화되어 있지 않으며 컴파일러마다 다르다.

그런데 어노테이션 매개 변수 구문(특히, 여러 매개 변수를 허용하는 어노테이션의 경우)은 메서드 매개 변수 구문과 동일하지 않다. 여기서는 다루지 않는다.

프로그래머는 코드에 사용할 새 어노테이션을 정의할 수 이씨다. 이러한 어노테이션은 표준 컴파일러와 프로그래밍 도구에서 무시되지만 어노테이션을 이해하고 소스 코드에 어노테이션이 있는지 확인할 수 있는 프로그램을 작성하는 것은 가능하다. 런타임시 유지되고 실행 중인 프로그램의 일부가 될 주석을 생성하는 것도 가능하다. 이 경우 프로그램은 실행 중인 실제 컴파일 코드에서 어노테이션을 확인하고 어노테이션의 존재 여부나 해당 매개 변수 값에 따라 조치를 취할 수 있다.

어노테이션은 프로그래머가 올바른 프로그램을 작성하는 데 도움이 될 수 있다. Java 문서의 예를 사용하려면 "상용구(boilerplate)" 코드, 즉 매우 표준화된 형식을 갖고 기계적으로 생성할 수 있는 코드를 생성하는 데 도움을 줄 수 있다. 상용구 코드는 다른 코드를 기반으로 생성되는 경우가 많다. 이를 수동으로 수행하는 것은 지루하고 오류가 발생하기 쉬운 프로세스이다. 간단한 예로 프로그램 상태의 특정 측면을 파일에 저장하고 나중에 복원하는 코드를 들 수 있다. 모든 관련 상태 변수의 값을 읽고 쓰는 코드는 매우 반복적이다. 프로그래머는 해당 코드를 직접 작성하는 대신 어노테이션을 사용하여 저장할 상태의 일부인 변수를 표시할 수 있다. 그런 다음 프로그램을 사용하여 어노테이션을 확인하고 저장 및 복원 코드를 생성할 수 있다.















