# 정확성(Correctness)과 견고성(Robustness) 소개

프로그램은 수행하도록 설계된 작업을 수행하면 올바른 것이다. 불법적인(illegal) 입력과 예상치 못한 상황을 합리적인 방식으로 처리할 수 있다면 **견고(robust)** 하다. 예를 들어, 사용자로부터 일부 숫자를 읽은 다음 동일한 숫자를 정렬된 순서로 print 하도록 설계된 프로그램을 생각해 보자. 어떤 입력 숫자 세트에 대해서도 작동한다면 프로그램은 올바른 것이다. 예를 들어 오류 메시지를 print 하고 잘못된 입력을 무시하는 등 숫자가 아닌 입력도 처리할 수 있다면 강력하다. 견고하지 않은 프로그램은 동일한 상황에서 충돌하거ㅏ 무의미한 출력을 제공할 수 있다.

모든 프로그램은 정확해야 한다. (올바르게 정렬되지 않은 정렬 프로그램은 쓸모가 없다.) 모든 프로그램이 완전히 견고해야 하는 것은 아니다. 누가 사용할 것인지, 어떻게 사용할 것인지에 따라 다르다. 예를 들어, 자신이 직접 사용하기 위해 작성하는 작은 유틸리티 프로그램은 특별히 강력할 필요는 없다.

정확성에 대한 문제는 실제로 보이는 것보다 더 미묘(subtle)하다. 프로그래머는 프로그램이 수행해야 하는 작업에 대한 사양에 따라 작업한다. 프로그램이 사양을 충족하면 프로그래머의 작업은 올바른 것이다. 하지만 그렇다고 해서 프로그램 자체가 옳다는 뜻인가? 사양이 부정확하거나 불완전하면 어떻게 되나? 올바른 프로그램은 완전하고 정확한 사양을 올바르게 구현한 것이어야 한다. 문제는 사양이 프로그램을 작성하는 사람들의 의도와 욕구를 올바르게 표현하는지 여부이다. 이는 컴퓨터 과학의 영역 밖에 있는 질문이다.

## 1. 공포스러운 이야기

대부분의 컴퓨터 사용자는 프로그램이 작동하지 않거나 충돌하는 개인적인 경험을 가지고 있다. 대부분의 경우 이러한 문제는 단지 귀찮은 일이지만 개인용 컴퓨터에서도 작업 손실이나 돈 손실과 같은 더 심각한 결과가 발생할 수 있다. 컴퓨터에 더 중요한 작업이 주어지면 오류의 결과는 비례적으로 더 심각해질 수 있다. 

약 23년 전, 수백만 달러 규모의 화성 탐사 임무 두 개가 실패했다는 소식이 뉴스에 등장했다. 두 가지 실패 모두 소프트웨어 문제로 인한 것일 수 있지만 두 경우 모두 잘못된 프로그램으로 인한 문제는 아니다. 1999년 9월, 화성 기후 궤도선이 화성 대기에서 불타버린 것은 영국식 측정 단위(피트, 파운드)로 표현된 데이터가 미터법 단위(센티미터, 그램)를 사용하도록 설계된 프로그램에 입력 되었기 때문이다. 몇 달 후 화성 착륙선은 소프트웨어가 착륙 엔진을 너무 빨리 꺼서 충돌했을 가능성이 높다.이 프로그램은 우주선이 착륙할 때 충격을 감지하고 엔진을 끄도록 되어 있었다. 랜딩 기어의 배치로 인해 프로그램이 활성화될 만큼 우주선이 충격을 받아 우주선이 여전히 지상 높이에 있을 때 엔진이 꺼지는 것으로 확인되었다. 그러면 동력이 공급되지 않은 우주선은 화성 표면으로 떨어졌을 것이다. 보다 견고한 시스템이면 엔진을 끄기 전에 고도를 확인했을 것이다.

부정확하거나 잘못 작성된 소프트웨어로 인해 발생하는 문제에 대한 극적인 이야기도 많이 있다. Tom Forester와 Perry Morrison이 쓴 Computer Ethics 책에 언급된 몇 가지 사건을 살펴본다. 
- 1985년과 1986년에는 잘못 프로그래밍된 컴퓨터 방사선 기계로 방사선 치료를 받던 중 과도한 방사선으로 인해 1명이 사망하고 여러명이 부상을 입었다. 또 다른 경우에는 1992년 부터 10년 동안 거의 1,000명의 암 환자가 프로그래밍 오류로 인해 처방된 것보다 30% 적은 방사선량을 받았다. 
- 1985년 뉴옥 은행의 컴퓨터가 프로그램 오류로 인해 진행 중인 보안 거래 기록을 파기하기 시작했다. 프로그램을 수정하는 데 24시간도 걸리지 않았지만, 그 무렵 은행은 문제를 해결하기 위해 빌려야 했던 자금에 대해 하룻밤 이자를 지불해야 하는 금액으로 $5,000,000가 부족했다.
- F-16 전투기의 관성 유도 시스템 프로그래밍은 시뮬레이션에서 문제가 발견되지 않았다면 적도를 횡단할 때 비행기를 뒤집어 놓았을 것이다. 마리너 18호 우주 탐사선은 프로그램 한 줄의 오류로 인해 분실되었다. Gemini V 우주 캡슐은 프로그래머가 지구의 자전을 고려하는 것을 잊어버렸기 때문에 예정된 착륙 목표를 100마일이나 놓쳤다.
- 1990년에 새로 로드된 컴퓨터 프로그램에 버그가 포함된 것으로 밝혀지면서 AT&T의 장거리 전화 서비스가 미국 전역에서 중단되었다.

물론 최근에는 더 많은 문제가 발생했다. 예를 들어, 역사상 최대 규모의 정전 중 하나 였던 2003년 북동부 정전 상는 컴퓨터 소프트웨어 오류로 인해 발생했다. 2006년 Airbus A380은 소프트웨어 비호환 문제로 인해 지연 되었으며 아마도 수십억 달러의 비용이 들었다. 2007년에는 소프트웨어 문제로 인해 LA 국제 공항에서 수천 대의 비행기가 이륙하지 못했다. 2010년 5월 6일, 자동 거래 프로그램 결함으로 인해 다우 존스 산업평균지수가 1000포인트 하락했다.

이는 몇 가지 예이다. 소프트웨어 문제는 너무 흔하다. 프로그래머로서 우리는 이것이 왜 사실인지, 이에 대해 무엇을 할 수 있는지 이해해야 한다.


## 2. Java를 구출

Java 개발자에 따르면 문제의 일부는 프로그래밍 언어 자체에서 비롯될 수 있다. Java는 특정 유형의 오류에 대해 어느 정도 보호 기능을 제공하도록 설계되었다. 언어 기능이 오류를 방지하는 데 어떻게 도움이 되는가?

일부 프로그래밍 언어에는 변수 선언이 필요하지 않다. 이러한 언어에서는 프로그램에서 변수 이름을 사용하면 해당 변수가 자동으로 생성된다. 모든 변수를 명시적으로 선언하는 것보다 이 방법이 편리하다고 생각할 수도 있지만 불행한 결과가 있다. 의도하지 않은 철자 오류로 인해 생성할 의도가 없었던 추가 변수가 발생할 수 있다. 한 유명한 이야기에 따르면 이러한 유형의 오류는 또 다른 우주선 분실의 원이이 되었다고 한다. `FORTRAN` 프로그래밍 언어에서 `"DO 20 I = 1,5"`명령은 계산 루프의 첫 번째 명령문이다. 이제 `FORTRAN`에서는 공백이 중요하지 않으므로 `DO20I=1,5"`와 같다. 반면에 쉼표 대신 마침표가 있는 `"DO20I=1.5"`는 변수 `DO20I`에 `1.5`를 할당하는 할당 명령문이다. 아마도 이 유형의 명령문에서 실수로 쉼표를 마침표로 대체하면 로켓이 폭발하게 될 것이다. `FORTRAN`에서는 변수 선언이 필요하지 않기 때문에 컴파일러는 `DO20I=1.5`문을 받아들인다. `DO20I`라는 새 변수를 생성하기만 하면 된다. 변수 선언이 필요한 경우 컴파일러는 변수가 선언되지 않았다고 불평했을 것이다.

오늘날 대부분 프로그래밍 언어에는 변수 선언이 필요하지만 일반적인 프로그래밍 언어에는 문제를 일으킬 수 있는 다른 기능이 있다. Java에서는 이러한 기능 중 일부를 제거했다. 어떤 사람들은 이로 인해 Java가 덜 효율적이고 덜 견고해진다고 불평한다. 이러한 비판에는 어느 정도 정당한 부분이 있지만 대부분의 상황에서 보안과 견고성의 증가는 아마도 그만한 가치가 있을 것이다. 일부 유형의 오류에 대해 최선의 방어는 오류가 불가능한 프로그래밍 언어를 설계하는 것이다. 오류를 완전히 제거할 수 없는 경우 오류가 발생하면 자동으로 감지되도록 언어를 설계할 수 있다. 이렇게 하면 최소한 오류로 인해 추가 피해가 발생하는 것을 방지할 수 있으며 프로그래머에게 수정해야 할 버그가 있음을 알릴 수 있다.

배열은 0부터 지정된 최대 인덱스까지 번호가 매겨진 특정 수의 위치로 생성된ㄴ다. 지정된 범위를 벗어난 배열 위치를 사용하려고 하면 오류가 발생한다. Java에서는 이러한 시도가 시스템에 의해 자동으로 감지된다. C와 C++ 같은 일부 다른 언어에서는 인덱스가 합법적인 범위 내에 있는지 확인하는 것은 프로그래머의 몫이다. 배열 A에 0, 1, 2 세 개의 위치가 있다고 가정한다. 그런 다음 3, 4등은 배열 끝을 넘어서는 메모리 위치를 참조한다. Java에서 A[3]에 데이터를 저장하려는 시도가 감지 되고 프로그램은 종료된다. C 또는 C++에서는 컴퓨터가 계속해서 배열의 일부가 아닌 메모리에 데이터를 저장한다. 해당 메모리 위치가 어떤 용도로 사용되고 있는지 알 수 없으므로 결과를 예측할 수 없다. 그 결과는 프로그램이 종료되는 것보다 훨씬 더 심각할 수 있다.

포인터는 프로그래밍 오류의 악명 높은 소스이다. Java에서 객체 유형의 변수는 객체에 대한 포인터 또는 특수 값 `null`을 보유한다. 실제 객체에 대한 포인터인 것처럼 `null`값을 사용하려는 시도는 시스템에 의해 감지된다. 다른 언어에서도 이러한 널 포인터 오류를 피하는 것은 프로그래머의 몫이다. 오래 전 나의 첫 매킨토시 컴퓨터에서 `null` 포인터는 실제로 메모리 위치를 가리키도록 포인터를 설정할 수 있다. 이 작업이 잘못 수행되면 포인터를 사용하면 예측할 수 없는 결과가 발생할 수 있다.

Java에서 발생할 수 없는 또 다른 유형의 오류는 메모리 누수이다. Java에서는 더 이상 객체를 참조하는 포인터가 없으면 해당 객체는 "가비지 수집"되어 해당 객체가 차지한 메모리를 재사용할 수 있다. 다른 언어에서는 사용되지 않은 메모리를 시스템에 반환하는 것이 프로그래머의 책임이다. 프로그래머가 이 작업을 수행하지 못하면 사용하지 않은 메모리가 쌓여 프로그램과 데이터에 사용할 메모리가 줄어들 수 있다. 구형 Window 컴퓨터의 많은 일반 프로그램에는 메모리 누수가 너무 많아 며칠 사용 후 컴퓨터에 메모리가 부족하여 다시 시작해야 한다는 이야기가 있다.

많은 프로그램에서 **버퍼 오버플로우 오류(buffer overflow errors)** 가 발생하는 것으로 나타났다. 버퍼 오버플로 오류는 많은 네트워크 보안 문제의 원인이 되기 때문에 종종 뉴스에 나온다. 한 컴퓨터가 네트워크를 통해 다른 컴퓨터로 부터 데이터를 받으면 해당 데이터는 버퍼에 저장된다. 버퍼는 수신할 것으로 예상되는 데이터를 보관하기 위해 프로그램에서 할당된 메모리 세그먼트일 뿐이다. 버퍼에 들어갈 수 있는 것보다 더 많은 데이터가 수신되면 버퍼 오플로우가 발생한다. 문제는 그러면 어떻게 되는가? 프로그램이나 네트워킹 소프트웨어에서 오류가 감지되면 발생한 유일한 일은 네트워크 데이트 전송 실패이다. 실제 문제는 소프트웨어가 버퍼 오플플로우를 제대로 감지하지 못할 때 발생한다. 이 경우 소프트웨어는 버퍼가 채워진 후에도 계속해서 메모리에 데이터를 저장한다. 추가 데이터는 프로그램이 버퍼의 일부로 할당하지 않은 메모리의 일부로 들어간다. 그 메모리는 다른 용도로 사용되고 있을 수도 있고 중요한 데이터를 포함하고 있을 수도 있고 프로그램 자체의 일부가 포함될 수도 있다. 여기서 실제 보안 문제가 발생한다. 버퍼 오버플로우로 인해 프로그램의 일부가 네트워크를 통해 수신된 추가 데이터로 대체된다고 가정해 본다. 컴퓨터가 교체된 프로그램의 일부를 실행하게 되면 실제로는 다른 컴퓨터로부터 받은 데이터를 실행하게 된다. 그 데이터는 무엇이든 될 수 있다. 컴퓨터를 충돌시키거나 컴퓨터를 대신하는 프로그램일 수 있다. 네트워킹 소프트웨어에서 편리한 버퍼 오버플로우 오류를 발견한 악의적인 프로그래머는 해당 오류를 이용하여 다른 컴퓨터를 속여 자신의 프로그램을 실행하도록 시도할 수 있다. 

완전히 Java로 작성된 소프트웨어의 경우 버퍼 오버플러우 오류가 불가능하다. 언어는 적절하게 할당되지 않은 메모리에 데이터를 저장하는 방법을 제공하지 않는다. 그렇게 하려면 할당되지 않은 메모리를 가리키는 포인터가 필요하거나 배열에 할당된 범위 밖에 있는 배열 위치를 참조해야 한다. 위에서 설명한 것처럼 Java에서는 이들 중 어느 것도 가능하지 않는다. 

언어 설계가 오류를 예방하거나 오류가 발생할 때 감지하는 데 도움이 될 수 있다는 것은 분명하다. 그렇게 하려면 프로그래머가 수행할 수 있는 작업을 제한해야 한다. 또는 포인터가 `null`인지 확인하는 등 추가 처리 시간이 걸리는 테스트가 필요하다. 일부 프로그래머는 추가 보안을 위해 지불하기에는 성능과 효율성을 희생하는 것이 너무 큰 대가라고 생각한다. 일부 응용 프로그램에서는 이것이 사실이다. 그러나 안전과 보안이 주요 고려 사항인 상황이 만이 있다. Java는 이러한 상황을 위해 설계되었다.

## 3. 여전한 문제가 Java에 남아있다.

Java 설계자가 자도으로 오류를 감지하지 않기로 선택한 영역이 하나 있는데 바로 수치 계산이다. Java에서 `int` 유형의 값은 32비트 이진수로 표시된다. 32비트를 사용하면 40억 개가 조금 넘는 다양한 값을 표현할 수 있다. `int` 유형의 값은 -2147483648 부터 2147483647까지이다. 계산 결과가 이 범위를 벗어나면 어떻게 되나? 예를 들어 `2147483647 + 1`은 무엇인가? 그리고 `2000000000 * 2`은 무엇인가? 각 경우의 수학적으로 올바른 결과는 `int` 유형의 값으로 표시될 수 없다. 정수 오버플로우 예는 다음과 같다. 대부분의 경우 정수 오버플러우는 오류로 간주되어야 한다. 그러나 Java는 이러한 오류를 자동으로 감지하지 않는다. 예를 들어 `2147483647 + 1` 값을 `-2147483648`로 계산한다.

섹션 3.2.2에서 논의된 3N+1 프로그램을 생각해 보자. 프로그램은 양의 정수 N에서 시작하여 특정 정수 시퀀스를 계산한다.

```java
while (N != 1) {
    if (N % 2 == 0)
        N = N /2;
    elsee
        N = 3 * N + 1;
    System.out.println(N);
}   
```

그러나 여기에는 문제가 있다. N이 너무 크면 정수 오버플로우로 인해 `3*N + 1`의 값이 수학적으로 정확하지 않는다. 문제는 `3*N+1 > 2147483647` 즉, `N > 2147483646/3` 일 때 발생한다. 완전히 올바른 프로그램을 위해서는 `3*N + 1`을 계산하기 전에 이 가능성을 확인해야 한다.

```java
while (N != 1) {
    if (N % 2 == 1)
        N = N / 2;
    else {
        if (N > 2147483646/3) {
            System.out.println("Sorry, but the value of N has become");
            System.out.println("too large for your computer!");
            break;
        }
        N = 3 * N + 1;
    }
    System.out.println(N);
}
```

여기서 문제는 `3N+1` 시퀀스를 계산하기 위한 원래 알고리즘이 잘못되었다는 것이 아니다. 문제는 32비트 정수를 사용하여 올바르게 구현할 수 없다는 것이다. 많은 프로그램은 이러한 유형의 문제를 무시한다. 그러나 정수 오버플로우 오류는 심각한 컴퓨터 오류의 원인이 되므로 완전히 견고한 프로그램은 정수 오버플로우 가능성을 고려해야 한다. (2000년 초에 바랭한 "Y2K" 버그는 사실 바로 이런 종류의 오류이다.)


`double` 유형의 숫자에는 더 많은 문제가 있다. `double` 유형의 값으로 표시될 수 있는 값 범위를 벗어날 때 발생하는 오버플로우 오류가 여전히 있다. 이 범위는 10의 308승 약 1.7배까지 확장된다. 이 범위를 넘는 숫자는 음수 값으로 "순환(wrap around)"되지 않는다. 대신, 실제 수치와 동일하지 않은 특수 값으로 표시된다. 특수 값 `Double.POSITIVE_INFINITY`, `Doulbe.NEGATIVE_INFINITY`은 유효한 값 범위를 벗어난 숫자를 나타낸다. 예를 들어 `20 * le308`은 `Double.POSITIVE_INFINITY`으로 계산된다. `double` 유형의 또 다른 특수 값, `Double.NaN`은 불법적이거나 정의되지 않은 결과를 나타낸다. ("Nan"은 "숫자가 아님"을 나타낸다.) 예를 들어 0ㅇ을 0으로 나누거나 음수의 제곱근을 취한 결과는 `Double.NaN`이다. `boolean` 값 함수 `Double.isNaN(x)`를 호출하여 숫자 x가 아닌 특별한 값 인지 테스트 할 수 있다.

실수의 경우 대부분의 실수가 컴퓨터에서만 대략적으로 표현될 수 있다는 추가적인 복잡성이 있다. 실수는 소수점 이하 자릿수가 무한할 수 있다. `double` 유형의 값은 약 15자리가지만 정확하다. 예를 들어 실수 1/3은 반복 소수 0.333333333333...이며, 유햔한 자릿수를 사용하여 이를 정확하게 나타낼 수 있는 방법은 없다. 실수를 사용한 계산에는 일반적으로 정확도가 떨어진다. 사실, 주의를 기울이지 않으면 그러한 계산을 많이 한 결과가 완전히 틀릴 수도 있다. 실수를 조작하는 알고리즘을 연구하는 데 전념하는 수치 분석으로 알려진 컴퓨터 과학의 전체 분야가 있다.

따라서 Java에서 발생할 수 있는 모든 오류를 자동으로 피하거나 감지할 수는 없다는 것을 알 수 있다. 또한 오류가 자동으로 감지된 경우에도 시스템의 기본 응답은 오류를 보고하고 프로그램을 종료하는 것이다. 이것이 거의 견고한 동작이 아니다. 따라서 Java 프로그래머는 여전히 오류를 피하고 처리하는 기술을 배워야 한다. 


