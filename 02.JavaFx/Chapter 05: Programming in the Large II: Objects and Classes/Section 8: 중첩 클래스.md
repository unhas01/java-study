# Section 8: 중첩 클래스

클래스는 꽤 중요한 개념인 것 같다. 클래스는 잠재적으로 복잡한 아이디어와 관련 데이터 및 동작을 나타내는 프로그램의 상위 수준 빌딩 블록이다. 나는 항상 몇 개의 데이터 스크랩을 함께 그룹화하기 위해 존재하는 아주 작은 클래스를 작성하는 것이 약간 어리석은 일이라고 느꼈다. 그러나 이러한 사소한 클래스는 유용하고 필수적인 경우가 많다. 다행스럽게도 Java에서는 한 클래스가 다른 클래스 내에 중첩될 수 있기 때문에 당혹감을 덜 수 있다. 나의 작은 클래스는 스스로 존재할 필요가 없다. 그것은 더 큰 클래스의 일부가 될 수 있다. 이는 대규모 클래스의 작업을 지원하기 위해 특별히 작은 클래스를 만들고 싶을 때 특히 유용하다. 그리고 구체적으로는 한 클래스의 정의를 다른 클래스 내에 중첩시키는 데에 다른 타당한 이유가 있다.

Java에서 중첩 클래스는 정의가 다른 클래스의 정의 내에 있는 모든 클래스이다. (실제로 클래스는 메서드 내부에 중첩될 수도 있으며, 메서드 자체도 클래스 내부에 있어야 한다.) 중첩 클래스는 명명되거나 익명일 수 있다. 이 섹션의 뒷부분에서 익명 클래스를 다시 한번 볼 것이다. 클래스에서 발생하는 대부분의 다른 항목과 마찬가지로 명명된 중첩 클래스는 정적이거나 비정적일 수 있다. 클래스와 마찬가지로 인터페이스도 클래스 정의 내에 중첩될 수 있으며 정적이거나 비정적일 수 있다. (실제로 인터페이스 정의에는 정적 중첩 클래스와 인터페이스가 포함될 수 있지만 이는 이 교과서에서 볼 수 있는 내용이 아니다.)

## 1. static 중첩 클래스

정적 중첩 클래스의 정의는 다른 클래스 내에 중첩되어 있고 선언의 일부로 `static` 수정자를 갖는다는 점을 제외하면 다른 클래스의 정의와 같다. static 중첩 클래스는 클래스의 정적 구조의 일부이다. 해당 클래스 내에서 일반적인 방법으로 객체를 생성하는 데 사용할 수 있다. 포함 클래스 외부에서 사용되는 경우 해당 이름은 포함 클래스의 멤버 자격을 나타내야 한다. 즉, static 중첩 클래스의 전체 이름은 `중첩된 클래스의 이름, 마침표, 중첩 클래스의 이름`으로 구성된다. 이는 클래스의 다른 정적 구성 요소와 유사하다. static 중첩 클래스는 static 멤버 변수가 클래스 자체의 일부인 것과 같은 방식으로 클래스 자체의 일부이다.

예를 들어 `WireFrameModel`이라는 클래스가 3차원 공간의 선 집합을 나타낸다고 가정해보자. (이러한 모델은 그래픽 프로그램에서 3차원 개체를 나타내는 데 사용된다.) `WireFrameModel`클래스에 단일 선을 나타내는 static 중첩 클래스 `Line`이 포함되어 있다고 가정해보자. `Line` 클래스 가 중첩된 `WireFrameModel` 클래스의 정의는 대략적으로 다음과 같다.

```java
public class WireFrameModel {

   . . . // other members of the WireFrameModel class
   
   static public class Line {
         // Represents a line from the point (x1,y1,z1)
         // to the point (x2,y2,z2) in 3-dimensional space.
      double x1, y1, z1;
      double x2, y2, z2;
   } // end class Line
   
   . . . // other members of the WireFrameModel class
   
} // end WireFrameModel
```

중첩 클래스의 전체 이름은 `WireFrameModel.Line`이다. 예를 들어 해당 이름은 변수를 선언하는 데 사용될 수 있다. `WireFrameModel` 클래스 내에서 `Line` 객체는 `new Line()` 생성자를 사용하여 생성된다. 클래스 외부에서는 `new WireFrameModel.Line()`이 사용된다.

static 중첩 클래스는 포함 클래스의 정적 멤버, 심지어 전용 멤버에 대한 모든 액세스 권한을 갖는다. 마찬가지로, 포함 클래스는 중첩 클래스의 멤버가 `private` 으로 표시되어 있더라도 해당 멤버에 대한 전체 액세스 권한을 가진다. 이는 중첩 클래스를 선언하는 또 다른 이유가 될 수 있다. 왜냐하면 해당 멤버를 다른 클래스에서 일반적으로 사용할 수 없도록 만들지 않고도 한 클래스에 다른 클래스의 전용 멤버에 대한 액세스 권한을 부여할 수 있기 때문이다. 또한 중첩된 클래스 자체는 비공개일 수 있다. 즉, 중첩된 클래스 내에서만 사용할 수 있다.

위의 클래스 정의를 컴파일하면 두 개의 클래스 파일이 생성된다. `Line`의 정의가 `WireFrameModel` 내에 중첩되어 있더라도 컴파일된 `Line` 클래스는 별도의 파일에 저장된다. `Line`의 클래스 파일 이름은 `WireFrameModel$Line.class` 이다.

<hr>

## 2. 내부 클래스 (Inner Classes)

비정적 중첩 클래스를 **내부 클래스(Inner classes)** 라고 한다. 실제로 내부 클래스는 static 중첩 클래스와 크게 다르지 않지만 비정적 중첩 클래스는 실제로 해당 정의가 중첩된 클래스가 아닌, 개체와 연결된다. 익숙해지는 데 시간이 걸릴 수 있다.

클래스의 비정적 멤버는 클래스 정의에 포함되어 있음에도 불구하고 실제로 클래스 자체의 일부가 아니다. 이는 클래스의 다른 비정적 부분과 마찬가지로 내부 클래스에도 적용된다. 클래스의 비정적 멤버는 해당 클래스에서 생성된 개체에 포함될 내용을 지정한다. 내부 클래스의 경우에도 적어도 논리적으로는 마찬가지이다. 이는 포함 클래스에 속하는 각 개체가 중첩 클래스의 자체 복사본을 갖는 것과 같다 (물론 문자 그대로 중첩 클래스에 대한 컴파일된 코드 복사본을 포함하지는 않는다). 이 복사본은 객체의 모든 인스턴스 메서드와 인스턴스 변수, 심지어 private 으로 선언된 변수에도 액세스할 수 있다. 서로 다른 두 개체에 있는 내부 클래스의 두 복사본은 참조하는 인스턴스 변수와 메서드가 서로 다른 개체에 있기 때문에 다르다. 실제로 중첩 클래스가 정적이어야 하는지 비정적이어야 하는지 결정하는 규칙은 간단하다. 중첩 클래스가 포함 클래스의 인스턴스 변수나 인스턴스 메서드를 사용해야 하는 경우 중첩 클래스를 비정적으로 만든다. 그렇지 않으면 정적일 수도 있다.

대부분의 경우 내부 클래스는 해당 클래스가 정의된 클래스 내에서만 사용된다. 이것이 사실이라면 내부 클래스를 사용하는 것은 실제로 다른 클래스를 사용하는 것과 크게 다르지 않다. 일반적인 방법으로 내부 클래스의 간단한 이름을 사용하여 변수를 만들고 개체를 선언할 수 있다(단, 클래스의 비정적 부분에서만 그렇게 할 수 있음).

포함하는 클래스 외부에서는 `variableName.NestedClassName` 형식의 이름을 사용하여 내부 클래스를 참조해야 한다. 여기서 `variableName`은 내부 클래스를 포함하는 개체를 참조하는 변수이다. 내부 클래스에 속하는 객체를 생성하려면 먼저 포함 클래스에 속하는 객체가 있어야 한다. (클래스 내부에서 작업할 때 객체 " this "가 암시적으로 사용된다.)

예제를 보는 것이 도움이 될 것이며 내부 클래스가 실제로 매우 자연스럽다는 것을 확신하게 될 것이다. 포커 게임을 나타내는 클래스를 생각해보자. 이 클래스에는 게임 플레이어를 나타내는 중첩 클래스가 포함될 수 있다. `PokerGame` 클래스 의 구조는 다음과 같다.

```java
public class PokerGame {  // Represents a game of poker.
    
    class Player {  // Represents one of the players in this game.
       .
       .
       .
    } // end class Player
    
    private Deck deck;      // A deck of cards for playing the game.
    private int pot;        // The amount of money that has been bet.
    
    .
    .
    .

} // end class PokerGame
```

`game`이 `PokerGame` 유형의 변수인 경우 개념적으로 `game`에는 `Player` 클래스의 자체 복사본이 포함된다. `PokerGame` 개체의 인스턴스 메서드에서는 다른 클래스와 마찬가지로 `new Player()` 라고 말하여 새 Player 개체가 생성된다. (Player 객체는 `game.new Player()` 와 같은 표현식을 사용하여 `PokerGame` 클래스 외부에서 생성될 수 있다. 그러나 이는 매우 드물다.) `Player` 객체는 `PokerGame` 의 `Deck` 및 `Pot` 인스턴스 변수에 액세스할 수 있다. 각 `PokerGame` 개체에는 자체 `deck`, `pot` 및 `Players`가 있다. 해당 포커 게임의 플레이어는 해당 게임의 덱과 포트를 사용한다. 다른 포커 게임의 플레이어는 다른 게임의 deck과 pot을 사용한다. 이것이 Player 클래스를 비정적으로 만드는 효과이다 . 즉, `Player` 객체를 특정 `PokerGame` 객체와 연결하고 해당 특정 게임에 대한 인스턴스 변수에 대한 액세스를 제공한다. 이는 플레이어가 행동하는 가장 자연스러운 방식이다. `Player` 객체는 특정 포커 게임의 플레이어를 나타낸다. 반면에 `Player`가 독립 클래스이거나 static 중첩 클래스인 경우 이는 특정 포커 게임과 무관한 포커 플레이어의 일반적인 아이디어를 나타냅니다.

## 3. 익명 내부 클래스 (Anonymous Inner Classes)

어떤 경우에는 내부 클래스를 작성한 다음 프로그램의 한 줄에서만 해당 클래스를 사용하는 경우도 있다. 그런 클래스를 만들 가치가 있을까? 실제로 그럴 수도 있지만 이와 같은 경우에는 익명의 내부 클래스를 사용할 수 있다. 익명 클래스는 다음 형식의 `new` 연산자를 변형하여 생성된다.

```java
new superclass-or-interface ( parameter-list ) {
    methods-and-variables
}
```

이 생성자는 이름을 지정하지 않고 새 클래스를 정의한다. 런타임 시 해당 클래스에 속하는 개체를 만든다. 이 형태의 `new` 연산자는 일반 `new`를 사용할 수 있는 모든 명령문에서 사용할 수 있다. 이 표현의 의도는 `수퍼클래스 또는 인터페이스와 동일 하지만 이러한 메서드 및 변수가 추가된 클래스에 속하는 새 객체`를 생성하는 것이다. 그 효과는 프로그램에서 필요한 지점에 고유하게 사용자 정의된 개체를 생성하는 것이다. 클래스가 아닌 인터페이스를 기반으로 익명 클래스를 만드는 것이 가능하다. 이 경우 익명 클래스는 인터페이스에 선언된 모든 메서드를 정의하여 인터페이스를 구현해야 한다. 인터페이스가 기본으로 사용되는 경우 매개변수 목록이 비어 있어야 한다. 그렇지 않으면 슈퍼클래스의 생성자에 대한 매개변수를 포함할 수 있다.

지금은 그다지 그럴듯하지 않은 예를 하나 살펴보도록하자. `Drawable` 이 다음과 같이 정의된 인터페이스라고 가정한다.

```java
Drawable redSquare = new Drawable() {
    public void draw(GraphicsContext g) {
        g.setFill(Color.RED);
        g.fillRect(10,10,100,100);
    }
};
```

그런 다음 `redSquare`는 `Drawable`을 구현하고 `draw()` 메서드가 호출될 때 빨간색 사각형을 그리는 개체를 참조한다. 그런데 명령문 끝에 있는 세미콜론은 클래스 정의의 일부가 아니다. 모든 선언문 끝에는 세미콜론이 필요하다.

실제 매개변수에는 익명 클래스가 사용되는 경우가 많다. 예를 들어 두 가지 다른 그래픽 컨텍스트에서 `Drawable`을 그리는 다음과 같은 간단한 방법을 보아라.

```java
void drawTwice( GraphicsContext g1, GraphicsContext g2, Drawable figure ) {
    figure.draw(g1);
    figure.draw(g2);
}
```

이 메서드를 호출하면 익명 내부 클래스를 사용하여 세 번째 매개 변수를 만들 수 있다. 예를 들어:
```java
drawTwice( firstG, secondG, new Drawable() {
    void draw(GraphicsContext g) {
        g.fillOval(10,10,100,100);
    }
} );
```

Java 클래스가 컴파일되면 각각의 익명 중첩 클래스는 별도의 클래스 파일을 생성한다. 예를 들어 메인 클래스의 이름이 `MainClass`인 경우 익명 중첩 클래스의 클래스 파일 이름은 `MainClass$1.class`, `MainClass$2.class`, `MainClass$3.class` 등이 된다.

물론 이 예에서 `Drawable`은 기능적 인터페이스이므로 익명 클래스 대신 람다 식을 사용할 수 있다. 마지막 예는 다음과 같이 간단하게 작성할 수 있다.

```java
drawTwice( firstG, secondG, g -> g.fillOval(10,10,100,100) );
```

redSquare는 다음 과 같이 정의될 수 있다.

```java
Drawable redSquare = g -> {
    g.setFill(Color.RED);
    g.fillRect(10,10,100,100);
};
```

이 접근 방식은 **추가 .class 파일을 생성하지 않는다는 장점**이 있다. 그러나 람다 식은 기능적 인터페이스에만 사용할 수 있는 반면 익명 클래스는 모든 인터페이스나 클래스에 사용할 수 있다.

<hr>

## 4. 지역 클래스와 람다 표현식

클래스는 서브루틴 정의 내에 정의될 수 있다. 이러한 클래스를 **로컬 클래스**라고 한다. 로컬 클래스는 해당 클래스가 정의된 서브루틴 내에서만 사용할 수 있다. 그러나 로컬 클래스에 의해 정의된 개체는 해당 서브루틴 외부에서 사용할 수 있다. 서브루틴의 값으로 반환되거나 다른 서브루틴에 매개변수로 전달될 수 있다. 이는 B 클래스가 A의 하위 클래스인 경우, 또는 A가 인터페이스인 경우 클래스 B가 인터페이스 A 를 구현하는 경우, 일부 클래스 B 에 속하는 객체를 A 유형의 변수에 할당할 수 있기 때문에 가능하다. 예를 들어 서브루틴이 `Drawable` 유형의 매개변수를 사용하는 경우 (여기서 `Drawable` 은 위에 정의된 인터페이스임) `Drawable`을 구현하는 모든 객체를 해당 서브루틴에 매개변수로 전달할 수 있다. 그리고 해당 객체는 로컬 클래스로 정의될 수 있다.

이 섹션 앞부분의 예에서는 `Drawable` 유형의 매개 변수를 사용하는 `drawTwice()` 메소드에 `Drawable` 유형의 사용자 정의된 객체를 전달했다. 이 예에서 클래스는 익명의 내부 클래스였다. 로컬 클래스는 익명인 경우가 많지만 필수는 아니다. 익명 클래스가 로컬 클래스인 경우가 많지만 반드시 필요한 것은 아니다. 예를 들어 익명 클래스를 사용하여 전역 변수의 초기 값을 정의할 수 있다. 이 경우 익명 클래스는 서브루틴에 포함되지 않으므로 로컬 클래스가 아니다.

지역 클래스의 정의는 해당 클래스가 정의된 서브루틴의 지역 변수를 사용할 수 있다. 또한 해당 서브루틴에 매개변수를 사용할 수도 있다. 그러나 로컬 클래스에서 이러한 변수 및 매개변수를 사용하는 데에는 제한이 있다. 로컬 변수 또는 매개변수는 `final`로 선언되어야 하며, 명시적으로 `final`로 선언되지 않은 경우 `실질적으로 final`이어야 한다. 매개변수를 참조하는 로컬 클래스를 포함하여 서브루틴 내에서 해당 값이 변경되지 않으면 매개변수는 사실상 final 이다. 지역 변수는 초기화된 후 해당 값이 변경되지 않으면 사실상 final 변수이다. 지역 클래스 정의에 사용되는 전역 변수에는 그러한 제한이 없다.

지역 변수 사용에 대한 동일한 제한은 익명 클래스와 매우 유사한 람다 식에도 적용된다. 다음은 단일 메소드 `double valueAt(double x))`를 정의하는 하위 섹션 4.5.2 의 `FunctionR2R` 기능적 인터페이스를 사용하는 예이다. 이 코드 세그먼트는 `FunctionR2R` 객체의 배열을 생성한다. 여기서 `multpliers`는 해당 매개 변수에 i를 곱하는 함수이다.

```java
FunctionR2R[] multipliers = new FunctionR2R[100];
for (int i = 0; i < 100; i++) {
   int n = i;
   multipliers[i] =  z -> n * z;
}
```

지역 변수 `n`은 사실상 final 이므로 람다 식에 사용할 수 있다. 반면에 `i` 변수는 사실상 final 변수가 아니기 때문에 람다 식에서 변수 `i`를 직접 사용하면 안된다. i++가 실행될 때 그 값이 변경된다. 또한 이 예제는 람다 식 대신 익명 클래스를 사용하여 작성할 수 있다.

```java
FunctionR2R[] multipliers = new FunctionR2R[100];
    for (int i = 0; i < 100; i++) {
        int n = i;
        multipliers[i] =  new FunctionR2R() {
            public double valueAt(double x) {
                return n * x;
            }
        };
    }
```


