# Section 5: this 와 super

객체 지향 프로그래밍의 기본 아이디어는 비교적 간단하고 명확하지만 미묘하고 익숙해지는 데 시간이 걸린다. 그리고 기본 아이디어 외에도 많은 세부 사항이 있다. 이 장의 나머지 부분에서는 이러한 세부 사항을 더 많이 다룬다. 처음부터 이 장의 모든 내용을 마스터할 필요는 없다. 이 섹션에서는 모든 인스턴스 메서드나 생성자에서 자동으로 정의되는 두 개의 변수 `this` 및 `super` 를 살펴볼 예정이다.

<hr>

## 1. 특수 변수 this

변수나 메소드를 참조하기 위해 `amount` 또는 `process()`와 같은 간단한 식별자를 사용한다는 것은 무엇을 의미할까? 대답은 프로그램에서 선언된 각 변수와 메서드에 액세스할 수 있는 위치와 방법을 알려주는 범위 규칙에 따라 달라진다. 메서드 정의 내에서 간단한 변수 이름은 **범위 내**, 즉 참조가 발생하는 소스 코드 지점에서 선언이 유효한 경우 지역 변수나 매개 변수를 참조할 수 있다. 그렇지 않은 경우 참조가 발생하는 클래스의 멤버 변수를 참조해야한다. 마찬가지로, 간단한 메서드 이름은 동일한 클래스의 메서드를 참조해야한다.

클래스의 static 멤버 에는 클래스 정의 내에서만 사용할 수 있는 간단한 이름이 있다. 클래스 외부에서 사용하려면 {class-name.simple-name} 형식의 전체 이름을 갖는다. 예를 들어, `Math.PI`는 `Math` 클래스에서 간단한 이름 `PI`를 static 정적 멤버 변수이다. 정의된 클래스 내에서도 static 멤버의 전체 이름을 사용하는 것이 가능하다. 때로는 static 멤버 변수의 단순 이름이 동일한 이름의 지역 변수나 매개변수에 의해 숨겨지는 경우처럼 필요할 수도 있다.

인스턴스 변수와 인스턴스 메서드에도 간단한 이름이 있다. 이러한 인스턴스 멤버의 간단한 이름은 인스턴스 멤버가 정의된 클래스의 인스턴스 메서드에서 사용할 수 있지만 static 메서드에서는 사용할 수 없다. 인스턴스 멤버에도 전체 이름이 있다. 하지만 인스턴스 변수나 인스턴스 메서드는 실제로 클래스가 아닌 객체에 포함되어 있으며 각 객체에는 고유한 버전이 있다는 점을 기억해라. 인스턴스 멤버의 전체 이름은 인스턴스 멤버를 포함하는 개체에 대한 참조로 시작된다. 예를 들어, `std`가 `Student` 유형의 개체를 참조하는 변수인 경우 `std.test1`은 해당 개체에 포함된 `test1` 이라는 인스턴스 변수의 전체 이름일 수 있다.

그러나 클래스 내부에서 간단한 이름을 사용하여 test1 과 같은 인스턴스 변수를 참조할 때 변수를 포함하는 개체는 어디에 있는가? 이 수수께끼에 대한 해결책은 간단하다. `test1`에 대한 참조가 일부 인스턴스 메서드의 정의에서 발생한다고 가정한다. 이 메서드는 `Student` 유형의 특정 개체의 일부입니다. 해당 메소드가 실행될 때 `test1`이라는 이름이 나타나는 것은 동일한 `object` 의 `test1` 변수를 나타낸다. (이것이 인스턴스 멤버의 간단한 이름을 정적 메서드에서 사용할 수 없는 이유이다. static 메서드가 실행되면 개체의 일부가 아니므로 인스턴스 멤버가 보이지 않는다!)

이는 정의된 동일한 클래스 내의 인스턴스 멤버에 대한 전체 이름에 대한 질문을 열어둔다. `이 메서드를 포함하는 개체`를 참조하는 방법이 필요하다. Java에서는 이러한 목적으로 `this` 라는 특수 변수를 정의한다. `this` 변수는 인스턴스 메소드의 소스 코드에서 메소드가 포함된 객체를 참조하는 데 사용될 수 있다. `this`라는 이름의 의도는 바로 이 메소드가 있는 `그 객체`를 참조하기 위한 것이다. `var`가 메소드와 동일한 객체의 인스턴스 변수인 경우 `this.var` 이다. 해당 변수의 전체 이름이다. `otherMethod()` 가 동일한 객체의 인스턴스 메서드라면 `this.otherMethod()` 라고 사용할 수 있다. 컴퓨터가 인스턴스 메서드를 실행할 때마다 자동으로 `this` 변수가 해당 메서드를 포함하는 개체를 참조하도록 설정된다.

(일부 객체지향 언어에서는 `this` 대신 `self`라는 이름을 사용한다. 여기서 객체는 메시지를 받고 어떤 작업을 수행하여 응답하는 엔터티로 간주된다. 해당 엔터티의 관점에서 보면 다음과 같은 인스턴스 변수가 있다. `self.name`은 엔터티 자체의 일부인 엔터티 자체 이름을 참조한다. `self.redraw()`와 같은 인스턴스 메서드를 호출하는 것은 "message to self: redraw!"라고 말하는 것과 같다.

`this`의 일반적인 용도 중 하나는 생성자이다. 예를 들어
```java
public class Student {

    private String name;  // Name of the student.
    
    public Student(String name) {
         // Constructor.  Create a student with specified name.
       this.name = name;
    }
      .
      .   // More variables and methods.
      .
}
```

생성자에서 `name`이라는 인스턴스 변수는 "name"이라는 형식 매개변수에 의해 숨겨진다. 그러나 인스턴스 변수는 여전히 전체 이름(`this.name`) 으로 참조할 수 있다. 할당문 `this.name = name`에서 오른쪽의 "name"은 형식 매개변수이고 해당 형식 매개변수의 값은 인스턴스 변수 `this.name` 에 할당된다. 이는 허용 가능한 스타일로 간주된다. 인스턴스 변수를 초기화하는 데 사용되는 형식 매개변수에 대해 새 이름을 떠올릴 필요가 없다. 인스턴스 변수와 동일한 이름을 매개변수에 사용할 수 있다.

`this`에는 다른 용도가 있다. 인스턴스 메서드를 작성할 때 해당 메서드가 포함된 객체를 서브루틴에 실제 매개변수로 전달해야 하는 경우가 있다. 이 경우 이를 실제 매개변수로 사용할 수 있다. 예를 들어, 객체의 문자열 표현을 인쇄하려면 `System.out.println(this);`라고 말할 수 있다. 또는 할당문의 다른 변수에 이 값을 할당할 수도 있다. 배열에 저장할 수 있다. 실제로 값 변경을 제외하고 다른 변수로 수행할 수 있는 모든 작업을 `this`으로 수행할 수 있다.(`final` 변수라고 생각하면 된다.)

<hr>

## 2. 특수 변수 super

Java는 또한 인스턴스 메소드 정의에 사용하기 위해 `super`라는 또 다른 특수 변수를 정의한다. `super` 변수는 서브클래스에서 사용하기 위한 것이다. 이처럼 `super`는 해당 메소드를 담고 있는 객체를 의미한다. 그러나 객체가 작성 중인 클래스에 속한다는 사실은 잊고, 해당 클래스의 슈퍼클래스에 속한다는 사실만 기억한다. 요점은 클래스가 슈퍼클래스에 대한 추가 및 수정 사항을 포함할 수 있다는 것이다. `super`는 이러한 추가 및 수정 사항에 대해 전혀 모른다. 슈퍼클래스의 메서드와 변수를 참조하는 데에만 사용할 수 있다.

작성 중인 클래스에서 `super.doSomething()` 메서드 호출을 사용한다고 가정해 보자. 이제 `super`는 동일한 클래스의 `doSomething()` 메소드에 대해 모르고 있다. 해당 클래스의 슈퍼클래스에 있는 것만 알고 있으므로 `super.doSomething()`은 슈퍼클래스에서 `doSomething()`이라는 메서드를 실행하려는 시도를 나타낸다. 슈퍼클래스에 그러한 메서드가 없으면 작성 중인 클래스에 `doSomething()` 메서드 가 있더라도 구문 오류가 발생한다.

`super`가 존재하는 이유는 하위 클래스의 항목에 의해 숨겨진 상위 클래스의 항목에 액세스할 수 있기 때문이다. 예를 들어, `super.var`은 항상 슈퍼클래스에 있는 `var`라는 인스턴스 변수를 참조한다. 이는 다음과 같은 이유로 유용할 수 있다. 클래스에 인스턴스 변수와 이름이 같은 인스턴스 변수가 슈퍼클래스에 포함된 경우 해당 클래스의 개체에는 실제로 이름이 같은 두 개의 변수가 포함된다. 하나는 클래스 자체의 일부로 정의되고 하나는 슈퍼클래스의 일부로 정의된다. 하위 클래스의 변수는 상위 클래스의 동일한 이름의 변수를 대체 하지 않는다. 단지 숨어있을 뿐이다. `super`를 사용하여 슈퍼클래스의 변수에 계속 액세스할 수 있다.

하위 클래스에 상위 클래스의 메서드와 동일한 시그니처를 가진 인스턴스 메서드가 포함되어 있으면 상위 클래스의 메서드도 같은 방식으로 숨겨진다. 하위 클래스의 메서드가 상위 클래스의 메서드를 재정의한다고 말한다. 그러나 역시 `super`를 사용하여 슈퍼클래스의 메서드에 액세스할 수 있다.

`super`의 주요 용도는 해당 동작을 완전히 대체하는 대신 상속된 메서드의 동작을 확장하는 새로운 메서드로 메서드를 재정의하는 것이다. 새 메서드는 `super`를 사용하여 슈퍼클래스에서 메서드를 호출한 다음 추가 코드를 추가하여 추가 동작을 제공할 수 있다. 예를 들어, `Roll()` 메서드를 포함하는 `pairOfDice` 클래스가 있다고 가정해보자. 컴퓨터 화면에 그려진 주사위 쌍을 나타내기 위해 서브클래스 `GraphicalDice`를 원한다고 가정해 보자. `GraphicalDice` 클래스의 `Roll()` 메소드는 `pairOfDice` 클래스의 `Roll()` 메소드가 수행하는 모든 작업을 수행해야 한다. 슈퍼클래스의 메소드를 호출하는 `super.roll()` 호출로 이를 표현할 수 있다. 그러나 그 외에도 `GraphicalDice` 개체의 `Roll()` 메서드는 새 값을 표시하기 위해 주사위를 다시 그려야 한다. `GraphicalDice` 클래스 는 다음과 같다.

```java
public class GraphicalDice extends PairOfDice {

    public void roll() {
            // Roll the dice, and redraw them.
         super.roll();  // Call the roll method from PairOfDice.
         redraw();      // Call a method to draw the dice.
    }
       .
       .  // More stuff, including definition of redraw().
       .
}
```

이를 통해 슈퍼클래스에서 메서드가 어떻게 구현되는지 모르더라도 `Roll()` 메서드의 동작을 확장할 수 있다.

## 3. 생성자로써의 super와 this

생성자는 상속되지 않는다. 즉, 기존 클래스를 확장하여 하위 클래스를 만드는 경우 슈퍼클래스의 생성자는 하위 클래스의 일부가 되지 않는다. 하위 클래스에 생성자를 원하는 경우 처음부터 새 생성자를 정의해야 한다. 하위 클래스에 생성자를 정의하지 않으면 컴퓨터는 매개 변수 없이 기본 생성자를 구성한다.

필요한 작업을 많이 수행하는 생성자가 슈퍼클래스에 있는 경우, 이는 문제가 될 수 있다. 하위 클래스에서 모든 작업을 반복해야 할 수도 있다! 슈퍼클래스에 대한 소스 코드가 없고 구현 방법조차 모르는 경우 이는 실제 문제가 될 수 있다. 슈퍼클래스의 생성자가 서브클래스에서 액세스할 수 없는 전용 멤버 변수를 사용하는 경우 이는 해결 불가능한 문제처럼 보일 수 있다.

분명히 이에 대한 몇 가지 수정 사항이 있어야 하며, 그러한 해결책이 존재한다. 여기에는 특수 변수 `super` 가 포함된다. 생성자의 첫 번째 명령문으로 `super`를 사용하여 슈퍼클래스에서 생성자를 호출할 수 있다. 이에 대한 표기법은 약간 오해의 소지가 있으며 다음과 같은 특정 상황에서만 사용할 수 있다. `super`를 서브루틴으로 호출하는 것처럼 보입니다( `super`가 서브루틴이 아니고 생성자를 동일하게 호출할 수 없음에도 불구하고. 어쨌든 다른 서브루틴을 호출하는 방식). 예를 들어, `pairOfDice` 클래스에 두 개의 정수를 매개변수로 사용하는 생성자가 있다고 가정해보자. 하위 클래스를 참고하여라.

```java
public class GraphicalDice extends PairOfDice {

     public GraphicalDice() {  // Constructor for this class.
     
         super(3,4);  // Call the constructor from the
                      //   PairOfDice class, with parameters 3, 4.
                      
         initializeGraphics();  // Do some initialization specific
                                //   to the GraphicalDice class.
     }
        .
        .  // More constructors, methods, variables...
        .
}
```

`super(3,4);` 문은 슈퍼클래스에서 생성자를 호출한다. 이 호출은 서브클래스에 있는 생성자의 첫 번째 줄이어야 한다. 이런 방식으로 슈퍼클래스에서 생성자를 명시적으로 호출하지 않으면 매개변수가 없는 슈퍼클래스의 기본 생성자가 자동으로 호출된다. (그리고 슈퍼클래스에 그러한 생성자가 없으면 컴파일러는 이를 구문 오류로 간주한다.)

동일한 클래스에서 다른 생성자를 호출하는 것처럼 특수 변수 `this`를 사용할 수 있다. 즉, 생성자의 첫 번째 줄은 서브루틴 이름이 `this`인 서브루틴 호출처럼 보일 수 있다. 결과적으로 동일한 클래스에 있는 다른 생성자의 본문이 실행된다. 이는 여러 다른 생성자에서 동일한 코드를 반복하지 않아도 되므로 매우 유용할 수 있다. 예를 들어, 섹션 4.7 에서 간접적으로 사용된 `mosaicCanvas.java를` 생각해 보자 . 모자이크캔버스(MosaicCanvas)는 색상이 있는 직사각형의 격자를 나타낸다. 여기에는 4개의 매개변수가 있는 생성자가 있다.

```java
public MosaicCanvas(int rows, int columns, 
                 int preferredBlockWidth, int preferredBlockHeight)
```

이 생성자는 여러 옵션을 제공하고 많은 초기화를 수행한다. 더 적은 수의 옵션으로 사용하기 쉬운 생성자를 제공하고 싶었지만 모든 초기화가 완료되어야 하므로 어쩔 수 없다. 클래스에는 다음 생성자도 포함되어 있다.

```java
public MosaicCanvas() {
    this(42,42);
}

public MosaicCanvas(int rows, int columns) {
    this(rows,columns,16,16);
}
```

이러한 각 생성자는 다른 생성자를 호출하기 위해 존재하며 일부 매개변수에 대한 상수 값을 제공한다. 예를 들어, `this(42,42)`는 여기에 나열된 두 번째 생성자를 호출하고 해당 생성자는 차례로 4개 매개 변수로 구성된 기본 생성자를 호출한다. 해당 기본 생성자는 결국 모든 경우에 호출되므로 모든 필수 초기화가 모든 경우에 완료된다.












