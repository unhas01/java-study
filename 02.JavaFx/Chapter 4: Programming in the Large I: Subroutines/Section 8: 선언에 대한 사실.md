# Section 8: 선언에 대한 사실

이전의 몇몇 장에서 언급했듯이 이름은 프로그래밍의 기본 이다. 이름을 선언하고 사용하는 것과 관련된 많은 세부 사항들이 존재한다. 필자는 그 세부사항들 중 일부를 피해왔다. 이 절에서 필자는 자바에서 변수를 선언하고 사용하는 것에 대해 (아직 완전한 진실은 아니지만) 대부분의 진실을 밝힐 것이다. 앞으로 자주 사용하게 되기에, "선언에서의 초기화(Initialization in Declarations)"와 "명명된 상수(Named Constants)"란 소재는 해당 관에서 특히 중요하다.

<hr>

## 1. 선언에서의 초기화
변수 선언이 실행되면 변수에 대한 메모리가 할당된다. 이 메모리는 해당 변수가 표현식에서 사용될 수 있기 전에 어떤 한정된 값을 가지기 위해 반드시 초기화되어야 한다. 지역 변수의 경우, 초기화를 수행하는 할당문이 선언에 밀접하게 뒤따르는 경우가 많다. 예를 들어,

```java
int count;    // count란 이름의 변수를 선언.
count = 0;    // count에 초기 값을 부여.
```

하지만, 선언문에 대한 진실은 변수의 초기화를 선언문에 포함시키는 것이 허용된다는 점이다. 따라서 위의 두 문장은 다음과 같이 축약할 수 있다:

```java
int count = 0;  // count를 선언하고 초기 값을 할당.
```

컴퓨터는 여전히 다음의 두 단계로 이 문장을 실행한다: 변수 `count`를 선언한 다음, 새로 생성된 변수에 값 0을 할당. 초기 값은 반드시 상수일 필요는 없다. 어떤 표현식도 가능하다. 하나의 선언문에 여러 변수를 초기화하는 것도 허용된다. 예를 들어,

```java
char firstInitial = 'D', secondInitial = 'E';

int x, y = 1;   // OK, 하지만 y만 초기화되었다!

int N = 3, M = N+2;  // OK, N은 그 값이 사용되기
                    //        전에 초기화되었다.
```

이러한 점은 특히 `for` 루프에서 일반적인데, 왜냐하면 루프 제어 변수가 초기화된 곳과 동일한 루프 안의 지점에서 해당 변수를 선언할 수 있도록 하기 때문이다. 루프 제어 변수는 일반적으로 루프 바깥의 나머지 프로그램과는 아무런 관계가 없기 때문에, 이것이 실제로 사용되는 프로그램의 부분에서 그 선언이 나타나는 것이 타당하다. 예를 들면:

```java
for ( int i = 0;  i < 10;  i++ ) {
    System.out.println(i);
}
```

이는 단순히 다음의 축약이라는 점을 기억해야 한다. 여기서 필자는 `i`가 `for` 문에 대하여 지역적으로 간주된다는 점과 `for` 루프의 종료 후에는 더 이상 존재하지 않는다는 점을 보여주기 위해 한 쌍의 중괄호를 추가하였다.

```java
{
    int i;
    for ( i = 0;  i < 10;  i++ ) {
        System.out.println(i);
    }
}
```

멤버 변수는 지역 변수와 마찬가지로 선언된 지점에서 초기화될 수 있다. 예를 들면:

```java
public class Bank {
    private static double interestRate = 0.05;
    private static int maxWithdrawal = 200;
    .
    .  // 더 많은 변수들과 서브루틴들.
    .ß
}
```

자바 인터프리터가 클래스를 불러들이는 즉시 정적 멤버 변수가 생성되며, 해당 초기화도 그 때에 이루어진다. 멤버 변수의 경우, 이는 단순히 할당문이 뒤따르는 선언의 축약이 아니다. 선언문은 서브루틴 밖에서 나타날 수 있는 유일한 유형의 문장이다. 할당문은 나타날 수 없으므로, 다음은 허용되지 않는 것이다:

```java
public class Bank {
    private static double interestRate;
    interestRate = 0.05;  // 허용되지 않음:
    .                     //    서브루틴 밖에는 있을 수 없음!:
```

이러한 사실 때문에, 멤버 변수의 선언에는 종종 초기 값이 포함된다. 실제로 제4장 제2절 제4관에서 언급한 바와 같이, 멤버 변수에 대한 초기 값이 제공되지 않는 경우, 기본 초기값이 사용된다. 예를 들어, 정수 멤버 변수인 `count`를 선언할 때, "`static int count;`"는 "`static int count = 0;`"과 동일하다.

심지어는 배열 변수조차 초기화될 수 있다. 배열은 단일 값이 아닌 여러 요소를 포함한다. 배열 변수를 초기화하기 위해, 쉼표(comma)로 구분되는 한 쌍의 중괄호 사이에 있는 값들의 목록을 제공할 수 있다. 예를 들면:

```java
int[] smallPrimes = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
```

이 문장에서 길이가 10인 int 배열이 생성되고 목록의 값들로 배열이 채워진다. 배열의 길이는 목록의 갯수에 따라 결정된다.

배열 초기화를 위한 이러한 구문은 할당문에서 **사용할 수 없다**는 점에 유의하라. 배열 변수가 선언될 때에만 선언문에서 이를 사용할 수 있다.

`new` 연산자를 사용하여 생성된 배열로 배열 변수를 초기화할 수도 있다(이는 할당문에서도 **사용할 수 있다**). 예를 들면:

```java
String[] nameList = new String[100];
```

그러나 이러한 경우에는, 당연하게도 모든 배열의 요소들이 기본 값을 가질 것이다.

<hr>

## 2. var로 변수 선언하기
자바 10은 변수에 대한 명시적 자료형을 지정하는 대신, "var"라는 단어를 사용하여 변수를 선언하는 새로운 방법을 도입했다. 선언에 대한 새로운 구문은 지역 변수, 즉 서브루틴 내부에 선언된 변수에 대해서만 사용할 수 있다(제4장 제2절 제4관 참조). 게다가 `var`를 사용하여 선언된 변수에는 반드시 초기 값이 제공되어야 한다. `var`로 선언되는 변수는 다른 변수와 마찬가지로 정의된 자료형이 있다. 자바 컴파일러는 초기 값의 자료형을 사용하여 해당 변수의 자료형을 정의한다. 예를 들어, 다음 선언문

```java
var interestRate = 0.05;
```

은 초기 값 0.05인 `interestRate`라는 지역 변수를 정의하는 데 사용될 수 있다. 0.05는 double 자료형의 값이기 때문에 해당 변수는 double 자료형이다. 그리고 `String[]` 자료형의 지역 변수 `nameList`는 다음과 같이 선언될 수 있다:

```java
var nameList = new String[100];
```

특히, `var`를 사용하여 `for` 루프 안에서 루프 제어 변수를 선언할 수 있다. 예를 들면,

```java
for ( var i = 0;  i < 10;  i++ ) {
    System.out.println(i);
}
```

이러한 모든 것이 특별히 유용해 보이지 않을 수도 있을 터이나, 제7장 제3절과 제10장에서 다루게 될 더욱 복잡해진 "매개변수화된 자료형(parameterized types)"에서 이는 더욱 유용해질 것이다.

<hr>

## 3. 명명된 상수
때때로 변수의 값은 초기화된 후에 변경되지 않도록 되어야 한다. 예를 들어, `interestRate`가 `0.05`란 값으로 초기화된 위의 예에서, 0.05는 프로그램 전체에서 통하는 값일 가능성이 상당히 높다. 그런 경우에 프로그래머는, 다른 의미없는 숫자 `0.05`에 의미있는 이름을 부여하기 위해 아마도 해당 변수 `interestRate`를 정의할 것이다. 프로그램이 "`principal += principal*0.05;`"이 아닌 "`principal += principal*interestRate;`"이라고 하면 무슨 일이 일어나고 있는지 이해하기가 더 쉽다.

자바에서는 변수 선언에 "`final`"이라는 제한자를 적용하여 변수가 초기화된 후 변수에 저장된 값을 변경할 수 없도록 할 수 있다. 예를 들어, 멤버 변수 `interestRate`가 다음과 같이 선언되었다면:

```java
public final static double interestRate = 0.05;
```

그러면 `interestRate`의 값을 프로그램의 다른 어느 곳에서도 변경하는 일은 불가능하게 된다. `interestRate`에 값을 할당하려고 하는 할당문은 프로그램을 컴파일할 때 구문 오류로 컴퓨터에 의해 거부될 것이다. (이자율(interest rate)에 대한 "최종(final)" 제한자는 상당히 타당할 것이다 — 은행은 이자율을 공표하고 싶을 수도 있으나, 임의의 사람들이 이를 변경하도록 내버려두지 않을 것은 분명하기 때문이다!)

`final` 제한자를 지역 변수와 심지어 형식적 매개변수에까지 적용하는 것은 허용되지만, 이는 멤버 변수에서 가장 유용하다. 프로그램 실행 내내 그 값이 일정하게 유지되기 때문에 필자는 종종 `final`로 선언된 정적 멤버 변수를 **명명된 상수(named constant)** 라고 언급할 것이다. 프로그램의 중요한 숫자들에 의미 있는 이름을 부여하기 위한 명명된 상수를 사용함으로써 프로그램의 가독성이 크게 향상될 수 있다. 명명된 상수에 대해 권장되는 스타일 규칙은 대문자로만 구성된 이름을 지정하며 필요한 경우 단어를 구분할 수 있는 밑줄(underscore) 문자를 사용하는 것이다. 예를 들어 이자율 상수에 대해 선호되는 스타일은 다음과 같을 것이다:

```java
public final static double INTEREST_RATE = 0.05;
```

이는 많은 명명된 상수를 정의하는 자바의 표준 클래스에서 일반적으로 사용되는 스타일이다. 예를 들어, Math 클래스에서 변수 `Math.PI`를 포함하는 것을 이미 보았을 것이다. 이 변수는 Math 클래스에서 "공개된(public) 최종의(final) 정적인(static)" double 자료형 변수로 선언된다. 마찬가지로 `Color` 클래스에는 `Color.RED` 및 `Color.YELLOW`처럼 공개된 최종의 정적인 `Color` 자료형 변수인 명명된 상수가 포함된다.

열거형 상수(제2장 제3절 제3관 참조) 또한 명명된 상수의 예이다. 열거형 정의인

```java
enum Alignment { LEFT, RIGHT, CENTER }
```

는 `Alignment.LEFT`, `Alignment.RIGHT`, 그리고 `Alignment.CENTER` 상수를 정의한다. 기술적으로, Alignment 는 클래스이며, 세 개의 상수는 해당 클래스의 `public final static` 멤버이다. 열거형을 정의하는 것은 자료형, 말하자면, int 자료형인 세 가지 상수를 정의하는 것과 마찬가지다:

```java
public static final int ALIGNMENT_LEFT = 0;
public static final int ALIGNMENT_RIGHT = 1;
public static final int ALIGNMENT_CENTER = 2;
```

사실, 열거형이 도입되기 전에는 이런 식으로 일이 진행되어야 했고, 지금도 많은 경우에 이런 식으로 행해지고 있는 것이다. 정수 상수를 사용하여 int 자료형의 변수를 정의하고 다른 종류의 정렬(alignment)을 나타내기 위해 `ALIGNMENT_LEFT`, `ALIGNMENT_RIGHT`, 또는 `ALIGNMENT_CENTER`에 값을 할당할 수 있을 것이다. 이런 방식의 유일한 문제점은 변수의 값이 정렬을 나타낸다는 의도를 컴퓨터가 알 길이 없다는 점과, 해당 변수에 할당된 값이 세 가지 유효한 정렬 값 중 하나가 아닌 경우 컴퓨터가 이의를 제기하지 않는다는 점이다. 반면에 열거형에서는, Alignment 자료형의 변수에 할당될 수 있는 유일한 값은 열거형의 정의에서 목록화된 상수 값이다. 변수에 잘못된 값을 할당하려는 시도는 프로그램이 컴파일될 때 컴퓨터가 감지하는 구문 오류이다. 이러한 추가적인 안전성은 열거형의 주요한 장점 중 하나이다.

<hr>

기묘한 일이지만, 명명된 상수를 사용하는 주된 이유 중 하나는 명명된 상수의 값을 쉽게 변경할 수 있기 때문이다. 물론 프로그램이 실행되는 동안에는 그 값을 바꿀 수 없다. 그러나 프로그램의 실행 사이에 소스 코드의 값을 변경하고 프로그램을 다시 컴파일하는 것은 쉬운 일이다. 이자율 예제를 생각해보자. 이자율의 값은 프로그램 전체에서 여러 번 사용될 가능성이 꽤나 크다. 은행이 이자율을 변경하고 해당 프로그램은 수정되어야 한다고 가정하자. 프로그램 전체에서 리터럴 숫자 0.05를 사용했다면, 프로그래머는 프로그램에서 이자율이 사용되는 각 지점을 추적해 새로운 값으로 이를 변경해야 할 것이다. (이는 0.05라는 숫자가 이자율 이외에 다른 의미를 가진 상태로 프로그램에서 나타날 수 있다는 점뿐만 아니라, 누군가가 이자율의 절반을 나타내기 위해 0.025를 사용했을수도 있다는 점 때문에 상황을 더욱 어렵게 한다.) 반면에, 명명된 상수 `INTEREST_RATE`가 선언되고 프로그램 전체에 걸쳐 일관성 있게 사용되는 경우에는, 상수가 초기화되는 단 하나의 행만을 변경하면 된다.

확장된 예로서, 필자는 이전 절의 `RandomMosaicWalk` 프로그램의 새로운 버전을 제시할 것이다. 이 버전은 모자이크에 있는 행의 갯수, 열의 갯수, 각각의 작은 정사각형의 크기를 나타내기 위해 명명된 상수를 사용한다. 세 개의 상수는 다음의 행처럼 `final static` 멤버 변수로 선언된다:

```java
final static int ROWS = 20;        // 모자이크의 행의 갯수.
final static int COLUMNS = 30;     // 모자이크의 열의 갯수.
final static int SQUARE_SIZE = 15; // 모자이크의 개별 정사각형 크기.
```

프로그램의 나머지 부분은 명명된 상수를 사용하도록 세심한 수정이 이루어진다. 예를 들어, 새로운 버전의 프로그램에서는, 다음 문장으로 모자이크 윈도우가 열린다:

```java
Mosaic.open(ROWS, COLUMNS, SQUARE_SIZE, SQUARE_SIZE);
```

때때로, 명명된 상수의 사용이 필요한 모든 장소를 찾기가 쉽지 않다. 명명된 상수를 일관성 있게 사용하지 않으면 어느 정도 취지를 벗어난 것이다. 모든 경우에 있어 제대로 프로그램이 작동하는지를 테스트하기 위해, 명명된 상수에 대해 여러 다른 값들을 사용하여 프로그램을 실행하는 것은 언제나 좋은 생각이다.

완전한 새로운 프로그램, `RandomMosaicWalk2`가 여기에 있으며, 이전 버전의 모든 수정사항이 빨간색으로 표시되었다. 특히 모자이크의 한쪽 가장자리에서 반대쪽 가장자리로 교란(disturbance)을 이동시킬 때 `ROWS`와 `COLUMNS` 상수가 `randomMove()`에서 어떻게 사용되는지를 유의하라. 공간을 절약하기 위해 대부분의 주석은 생략하였다.

(역주: 기술적인 문제로 빨간색 대신 **으로 대체합니다.)

```java
public class RandomMosaicWalk2 {

    final static int ROWS = 20;        // ** 모자이크에서 행의 갯수.
    final static int COLUMNS = 30;     // ** 모자이크에서 열의 갯수.
    final static int SQUARE_SIZE = 15; // ** 모자이크에서 각각의 정사각형 크기.

    static int currentRow;    // 교란을 포함하는 현재의 행.
    static int currentColumn; // 교란을 포함하는 현재의 열.

    public static void main(String[] args) {
        Mosaic.open( ROWS, COLUMNS, SQUARE_SIZE, SQUARE_SIZE );     // **
        fillWithRandomColors();
        currentRow = ROWS / 2;   // ** 윈도우의 중심에서 시작
        currentColumn = COLUMNS / 2;    // **
        while (true) {
            changeToRandomColor(currentRow, currentColumn);
            randomMove();
            Mosaic.delay(5);
        }
    }  // main 종료

    static void fillWithRandomColors() {
         for (int row=0; row < ROWS; row++) {   // **
            for (int column=0; column < COLUMNS; column++) {    // **
                changeToRandomColor(row, column);  
            }
         }
    }  // fillWithRandomColors 종료

    static void changeToRandomColor(int rowNum, int colNum) {
         int red = (int)(256*Math.random());    // 빨간색, 녹색, 파란색 요소에 대한
         int green = (int)(256*Math.random());  //     0에서 255 사이의 범위 안에서 
         int blue = (int)(256*Math.random());   //     무작위 수준을 선택.
         Mosaic.setColor(rowNum,colNum,red,green,blue);  
     }  // end changeToRandomColor

     static void randomMove() {
         int directionNum; // 방향을 선택하기 위해 무작위로 0, 1, 2, 또는 3을 설정.
         directionNum = (int)(4*Math.random());
         switch (directionNum) {
            case 0:  // move up 
               currentRow--;
               if (currentRow < 0)
                  currentRow = ROWS - 1;    // **
               break;
            case 1:  // move right
               currentColumn++;
               if (currentColumn >= COLUMNS)    // **
                  currentColumn = 0;
               break; 
            case 2:  // move down
               currentRow++;
               if (currentRow >= ROWS)      // **
                  currentRow = 0;
               break;
            case 3:  // move left  
               currentColumn--;
               if (currentColumn < 0)
                  currentColumn = COLUMNS - 1;  // **
               break; 
         }
     }  // randomMove 종료

} // 클래스 RandomMosaicWalk2 종료
```

<hr>
 
## 4. 명명 및 범위 규칙
변수 선언이 실행되면 해당 변수에 대해 메모리가 할당된다. 변수 이름은 해당 메모리 또는 메모리에 저장된 데이터를 참조하기 위해 최소한 프로그램 소스 코드의 일부에서 사용될 수 있다. 변수가 유효한 프로그램 소스 코드의 부분을 변수의 **범위(scope)** 라고 한다. 마찬가지로, 서브루틴 이름과 형식적 매개변수 이름의 범위를 참조할 수 있다.

정적 멤버 서브루틴의 경우 그 범위는 직선적이다. 정적 서브루틴의 범위는 그것이 정의된 클래스의 전체 소스 코드다. 즉, 서브루틴의 정의가 나타나는 지점 이전의 소스 코드 지점을 포함하여, 클래스의 어느 지점에서든지 서브루틴을 호출할 수 있다. 심지어 서브루틴 자신의 내부에서 해당 서브루틴을 호출하는 것도 가능하다. 이는 제9장 제1절에서 다루게 될, 상당히 상급의 주제인 "회귀(recursion)"이라고 불리는 예이다. 서브루틴이 `private`가 아닌 경우, 서브루틴이 정의된 클래스 밖에서도 전체 이름을 사용하여 해당 서브루틴에 접근할 수 있다.

클래스에서 정적 멤버 변수로 선언되는 변수의 경우, 상황은 비슷하지만 복잡한 점이 하나 있다. 멤버 변수와 이름이 같은 지역 변수나 형식적 매개변수를 사용하는 것은 허용된다. 이러한 경우, 지역 변수나 매개변수의 범위 내에서 멤버 변수가 **숨겨진다(hidden)**. 예를 들어, 다음과 같은 형식을 가진 `Game`이라는 클래스를 생각해보자:

```java
public class Game {

    static int count;  // 멤버 변수

    static void playGame() {
        int count;  // 지역 변수
          .
          .   // playGame()을 정의하는 몇몇 문장들
          .
    }

    .
    .   // 더 많은 변수들과 서브루틴들.
    .

}  // Game 종료
```

서브루틴 `playGame()`의 본체를 구성하는 문장에서, "`count`"라는 이름은 지역 변수를 가리킨다. `Game` 클래스의 나머지 부분에서 "`count`"는 멤버 변수를 가리킨다(다른 지역 변수나 `count`라는 매개변수에 의해 숨겨지지 않는 한). 하지만, `count`라는 멤버 변수는 `Game.count`라는 전체 이름으로도 참조할 수 있다. 일반적으로 전체 이름은 `count`가 정의된 클래스의 밖에서만 사용된다. 그러나 클래스 안에서 이를 사용하는 것을 금지하는 규칙은 없다. 전체 이름인 `Game.count`는 지역 변수 대신 멤버 변수를 참조하기 위해 `playGame()` 서브루틴 내부에서 사용될 수 있다. 따라서, 정적 멤버 변수의 범위는 이것이 정의되는 전체 클래스를 포함하지만, 멤버 변수의 간결한 이름이 지역 변수나 형식적 매개변수 이름에 의해 숨겨진 경우, 해당 멤버 변수는 반드시 {className.variableName} 형식의 전체 이름으로 참조되어야 한다는 것이 전체 범위 규칙이다. (비정적 멤버에 대한 범위 규칙은 정적 멤버에 대한 것과 유사하지만, 보게 될 바와 같이, 비정적 멤버는 정적 서브루틴에서 사용할 수 없다.)

서브루틴의 형식적 매개변수가 지니는 범위는 서브루틴 본체를 구성하는 블록이다. 지역 변수의 범위는 해당 변수를 정의하는 선언문에서 해당 선언이 나타나는 블록의 끝부분까지 확장된다. 위에서도 언급했듯이, "`for (int i=0; i < 10; i++)`"에서와 같이 `for` 문에서 `for` 루프의 루프 제어 변수를 선언할 수도 있다. 이러한 선언의 범위는 다음과 같은 특수한 경우로 간주된다: 이는 `for` 문 안에서만 유효하며 `for` 문이 포함된 블록의 나머지 부분까지 확장되지는 않는다.

중첩된 블록 안에 있더라도 그 범위 내에서 형식적 매개변수 또는 지역 변수의 이름을 재정의하는 것은 허용되지 않는다. 예를 들어, 이는 허용되지 않는다:

```java
void badSub(int y) {
    int x;
    while (y > 0) {
        int x;  // 오류: x는 이미 정의됨.
        .
        .
        .
    }
}
```

많은 언어에서, 이러한 방식은 허용되는 것이다; `while` 루프 안에서 이루어진 `x`의 선언은 원래의 선언을 감추게 된다. 이는 자바에서 허용되지 않는다; 하지만, 변수가 선언된 블록이 일단 종료되면, 그 이름을 자바에서 다시 사용할 수는 있게 된다. 예를 들면:

```java
void goodSub(int y) {
    while (y > 10) {
        int x;
        .
        .
        .
        // x의 범위는 여기서 끝난다.
    }
    while (y > 0) {
        int x;  // OK: 이전의 x 선언은 소멸되었다.
        .
        .
        .
    }
}
```

지역 변수 이름이 서브루틴 이름을 숨길 수 있는지 궁금할 것이다. 놀랄만한 까닭으로 이런 일은 있을 수 없다. 변수와 서브루틴이 서로 다른 이름을 가져야 한다는 규칙은 없다. 서브루틴 이름에는 항상 왼쪽 괄호가 뒤따르기 때문에, 컴퓨터는 언제나 어떤 이름이 변수 또는 서브루틴을 참조하는지를 알 수 있다. `count`라는 변수와 `count`라는 서브루틴을 동일한 클래스 안에서 사용하는 것은 완벽하게 허용된다. (필자가 `main()` 루틴을 이야기할 때처럼 괄호로 서브루틴 이름을 자주 쓰는 이유 중 하나가 바로 이것이다. 해당 괄호를 이름의 일부로 생각하는 것이 좋다.) 더욱 나아가더라도 말이다: 변수와 서브루틴의 이름을 정하기 위해 클래스 이름을 재사용하는 것도 허용된다. 자바의 구문 규칙은 컴퓨터가 해당 이름이 클래스 이름으로 사용되는 경우를 항상 알 수 있도록 보장한다. 클래스 이름은 자료형이므로 변수 및 형식적 매개변수를 선언하고 함수의 반환 자료형을 명시하는 데 사용될 수 있다. 이는 다음의 함수를 선언하는 `Insanity`라는 클래스의 사용이 허용된다는 것을 의미한다:

```java
static Insanity Insanity( Insanity Insanity ) { ... }
```

첫 번째 `Insanity`는 함수의 반환 자료형이다. 두 번째는 함수의 이름이며, 세 번째는 형식적 매개변수의 자료형, 네 번째는 형식적 매개변수의 이름이다. 하지만, 모든 것이 가능하다는 사실이 곧 좋은 아이디어는 아니라는 사실을 꼭 기억하길 바란다!
