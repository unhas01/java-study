# Section 1: 블랙박스

서브루틴은 몇몇 작업을 수행하기 위한 지시사항으로 구성되며, 함께 뭉쳐져(chunked) 이름이 지정된다. "묶음(chunking)"은 잠재적으로 매우 복잡한 작업을 하나의 개념으로 처리할 수 있게 한다. 해당 작업을 수행하기 위해 컴퓨터가 거쳐야 할 많은, 수많은 단계를 걱정하기보다는 그저 해당 서브루틴의 이름을 기억하기만 하면 된다. 프로그램이 해당 작업을 수행하기를 원할 때마다 서브루틴을 호출하기만 하면 된다. 서브루틴은 복잡성(complexity)을 다루는 주요한 도구다.

서브루틴은 그 "내부"를 볼 수 없기 때문에(혹은, 더 정확히 하자면, 보통은 그 내부를 **보고 싶지 않기** 때문인데, 왜냐하면 해당 서브루틴이 감추려고 하는 모든 복잡성을 처리해야 하기 때문이다) 서브루틴은 "블랙박스(black box)"라고 때때로 언급되기도 한다. 물론 다른 세계와 교류할 방법이 없는 블랙박스는 꽤나 쓸모가 없을 것이다. 블랙박스는 다른 세상과의 어떤 **인터페이스(interface)** 를 필요로 하는데, 이는 박스 안에 있는 것과 밖에 있는 것 사이에서 어느 정도 상호작용을 가능하게 한다. 물리적인 블랙박스는 누를 수 있는 버튼(button), 설정할 수 있는 다이얼(dial), 그리고 정보를 앞뒤로 전달하는 데 사용될 수 있는 슬롯(slot)을 가질 수도 있다. 복잡성을 숨기려고 하는 것이지, 만들려고 하는 것은 아니기 때문에 블랙박스에 관한 첫 번째 규칙이 성립한다:

```html
블랙박스의 인터페이스는 꽤나 직선적이고, 잘 정의되며, 이해하기 쉬워야 한다. 
(The interface of a black box should be fairly straightforward,
well-defined, and easy to understand.)
```

실제 세상에 블랙박스의 어떤 예가 있을까? 있다; 사실, 당신은 그들에게 둘러싸여 있다. 텔레비전, 자동차, 휴대폰, 냉장고, ... TV 인터페이스의 요소 — 켜기/끄기 스위치, 리모컨, 잊지 않고 전원에 플러그를 연결하는 것 — 를 이용하여 텔레비전을 켜고 끄고, 채널을 변경하고, 소리 크기를 설정할 수 있다. 실제로 이들이 어떻게 작동하는지를 이해하지 않더라도 말이다. 휴대폰도 마찬가지지만, 그 경우에는 인터페이스가 훨씬 더 복잡하다.

자, 블랙박스는 내부를 가지고 있다 — 즉 실제로 작업을 수행하는 서브루틴 안의 코드, 또는 당신의 텔레비전 안에 있는 모든 전자장치들 말이다. 블랙박스의 내부는 **구현(implementation)** 이라고 불린다. 블랙박스의 두 번째 규칙은 다음과 같다:

```html
블랙박스를 사용하려면 그 구현에 대해 알 필요는 없다; 그 인터페이스를 아는 것으로 충분하다. 
(To use a black box, you shouldn't need to know anything about its implementation; 
all you need to know is its interface.)
```

실제로 외부에서 본 박스의 행태에 변화가 없는 한, 구현을 **변경**하는 것은 가능해야 한다. 예를 들어, TV의 내부가 진공관에서 트랜지스터의 사용으로 바뀌었을 때, 사용자는 이에 대해 알 필요가 없었고 — 심지어 이들이 무엇을 의미하는지 알 필요도 없었다. 마찬가지로, 서브루틴을 사용하는 프로그램에 영향을 미치지 않고, 예를 들자면, 보다 효율적인 코드를 사용하기 위해 서브루틴의 내부를 다시 작성할 수 있어야 한다.

물론 블랙박스를 갖기 위해서는, 누군가가 애초에 구현을 설계하고 구축했어야 할 것이다. 블랙박스 아이디어는 블랙박스 사용자뿐만 아니라 구현자에게도 유리하게 작용한다. 무엇보다도, 블랙박스는 각기 다른 무한정의 상황에서 사용될 수도 있다. 블랙박스의 구현자는 이들에 대해 알 필요가 없다. 구현자는 해당 박스가 할당된 작업을 수행하고 나머지 세계와 올바르게 접촉(interface1)하는지 확인하기만 하면 된다. 블랙박스의 세 번째 규칙은 다음과 같다:

```html
블랙박스의 구현자는 박스를 사용할 대형 시스템에 대해 알 필요가 없어야 한다. 
(The implementor of a black box should not need to know anything 
about the larger systems in which the box will be used.)
```

이런 식으로 블랙박스는 세계를 두 부분으로 나눈다: 내부(구현)와 외부. 인터페이스는 경계면에 있으며, 이 두 부분을 연결한다.

<hr>

그건 그렇고, 인터페이스를 단지 박스와 세계의 나머지 사이의 물리적 연결로 생각해서는 **안 된다.** 인터페이스는 또한 박스가 무엇을 하고 물리적 인터페이스의 요소를 사용하여 어떻게 제어될 수 있는지에 대한 **명세(specification)** 를 포함한다. TV 세트에 전원 스위치가 있다고 하는 것만으로는 충분하지 않다; TV를 켜고 끄는 데 전원 스위치가 사용된다는 점을 명시할 필요가 있는 것이다!

이를 컴퓨터 과학 용어로 표현하기 위해, 서브루틴의 인터페이스는 구문적(syntactic) 요소뿐만 아니라 의미론적(semantic) 요소도 가지고 있다고 한다. 인터페이스의 구문적 부분은 서브루틴을 호출하기 위해 입력해야 하는 것을 알려준다. 의미론적 구성요소는 어떠한 작업을 서브루틴이 수행하는지를 정확히 명시한다. 허용되는 프로그램을 작성하려면 서브루틴의 구문적 명세를 알아야 한다. 서브루틴의 목적을 이해하고 효과적으로 사용하기 위해서는 서브루틴의 의미론적 명세를 알아야 한다. 필자는 인터페이스의 두 부분 — 구문적 요소와 의미론적 요소 — 을 집합적으로 서브루틴의 **계약(contract)** 이라 언급할 것이다.

서브루틴의 계약은 본질적으로 "나를 이용하기 위해 당신이 해야 할 일이 여기에 있고, 내가 당신을 위해 할 일이 여기에 있음을 보장한다"고 말한다. 서브루틴을 작성할 때 서브루틴에 대해 작성하는 주석들은 계약 내용을 아주 명확하게 만들어야 한다. (실제로는, 서브루틴의 계약은 종종 부적절하게 명시되어, 이를 사용해야 하는 프로그래머들의 후회와 짜증을 상당 부분 담당함을 인정해야 할 것이다.)

이 장의 나머지 부분에서, 필자는 블랙박스와 서브루틴에 대한 일반적인 생각에서 자바의 서브루틴을 작성하고 사용하는 것에 대한 명세로 전환할 것이다. 그러나 일반적인 아이디어와 원리를 명심해야 한다. 이들은 서브루틴이 애초에 존재하는 이유이자, 서브루틴을 사용하는 지침이다. 특히 제4장 제7절에서 이는 명확해질 것인데, 여기서 필자는 프로그램 개발의 도구로써 서브루틴에 대해 논의할 것이다.

<hr>

서브루틴이 프로그래밍에서 블랙박스의 유일한 예는 아니라는 점을 명심하라. 예를 들어, 클래스 또한 블랙박스다. 우리는 클래스가 인터페이스를 나타내는 "공개(public)" 부분과, 완전히 숨겨진 구현 안에 있는 "비공개(private)" 부분을 가질 수 있다는 점을 알게 될 것이다. 블랙박스의 모든 원리는 서브루틴뿐만 아니라 클래스에도 적용된다.

